//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class AccountService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined , cancelToken?: CancelToken | undefined): Promise<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsTenantAvailable(_response);
        });
    }

    protected processIsTenantAvailable(response: AxiosResponse): Promise<IsTenantAvailableOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = IsTenantAvailableOutput.fromJS(resultData200.result);
            return Promise.resolve<IsTenantAvailableOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IsTenantAvailableOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined , cancelToken?: CancelToken | undefined): Promise<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: AxiosResponse): Promise<RegisterOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegisterOutput.fromJS(resultData200.result);
            return Promise.resolve<RegisterOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegisterOutput>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerMember(body: RegisterMemberInput | undefined , cancelToken?: CancelToken | undefined): Promise<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/RegisterMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRegisterMember(_response);
        });
    }

    protected processRegisterMember(response: AxiosResponse): Promise<RegisterOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RegisterOutput.fromJS(resultData200.result);
            return Promise.resolve<RegisterOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegisterOutput>(null as any);
    }

    /**
     * @param email (optional) 
     * @return Success
     */
    forgotPasswordViaEmail(email: string | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/ForgotPasswordViaEmail?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processForgotPasswordViaEmail(_response);
        });
    }

    protected processForgotPasswordViaEmail(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param token (optional) 
     * @param email (optional) 
     * @param password (optional) 
     * @return Success
     */
    resetPasswordViaEmail(token: string | undefined, email: string | undefined, password: string | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPasswordViaEmail?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        if (password === null)
            throw new Error("The parameter 'password' cannot be null.");
        else if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetPasswordViaEmail(_response);
        });
    }

    protected processResetPasswordViaEmail(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class ApplicationExtService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param app_search (optional) 
     * @return Success
     */
    getAll(app_search: string | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationExtDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationExt/GetAll?";
        if (app_search === null)
            throw new Error("The parameter 'app_search' cannot be null.");
        else if (app_search !== undefined)
            url_ += "app_search=" + encodeURIComponent("" + app_search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ApplicationExtDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationExtDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<ApplicationExtDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationExtDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateApplicationExtInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationExtDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationExt/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<ApplicationExtDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationExtDto.fromJS(resultData200.result);
            return Promise.resolve<ApplicationExtDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationExtDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateApplicationExtInput | undefined , cancelToken?: CancelToken | undefined): Promise<ApplicationExtDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationExt/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<ApplicationExtDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ApplicationExtDto.fromJS(resultData200.result);
            return Promise.resolve<ApplicationExtDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ApplicationExtDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/ApplicationExt/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class AuditLogService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param impersonatorUserId (optional) 
     * @param exception (optional) 
     * @param browserInfo (optional) 
     * @param clientName (optional) 
     * @param clientIpAddress (optional) 
     * @param userId (optional) 
     * @param methodName (optional) 
     * @param serviceName (optional) 
     * @param skipCount (optional) 
     * @param maxValue (optional) 
     * @return Success
     */
    getAll(impersonatorUserId: number | undefined, exception: string | undefined, browserInfo: string | undefined, clientName: string | undefined, clientIpAddress: string | undefined, userId: number | undefined, methodName: string | undefined, serviceName: string | undefined, skipCount: number | undefined, maxValue: number | undefined , cancelToken?: CancelToken | undefined): Promise<AuditLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAll?";
        if (impersonatorUserId === null)
            throw new Error("The parameter 'impersonatorUserId' cannot be null.");
        else if (impersonatorUserId !== undefined)
            url_ += "ImpersonatorUserId=" + encodeURIComponent("" + impersonatorUserId) + "&";
        if (exception === null)
            throw new Error("The parameter 'exception' cannot be null.");
        else if (exception !== undefined)
            url_ += "Exception=" + encodeURIComponent("" + exception) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (clientName === null)
            throw new Error("The parameter 'clientName' cannot be null.");
        else if (clientName !== undefined)
            url_ += "ClientName=" + encodeURIComponent("" + clientName) + "&";
        if (clientIpAddress === null)
            throw new Error("The parameter 'clientIpAddress' cannot be null.");
        else if (clientIpAddress !== undefined)
            url_ += "ClientIpAddress=" + encodeURIComponent("" + clientIpAddress) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxValue === null)
            throw new Error("The parameter 'maxValue' cannot be null.");
        else if (maxValue !== undefined)
            url_ += "maxValue=" + encodeURIComponent("" + maxValue) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<AuditLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuditLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<AuditLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuditLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param au_lo_id (optional) 
     * @return Success
     */
    deleteAuditLog(au_lo_id: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/DeleteAuditLog?";
        if (au_lo_id === null)
            throw new Error("The parameter 'au_lo_id' cannot be null.");
        else if (au_lo_id !== undefined)
            au_lo_id && au_lo_id.forEach(item => { url_ += "au_lo_id=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAuditLog(_response);
        });
    }

    protected processDeleteAuditLog(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    deleteAllAuditLog(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/DeleteAllAuditLog";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAllAuditLog(_response);
        });
    }

    protected processDeleteAllAuditLog(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthorService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param au_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(au_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<AuthorDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Author/GetAll?";
        if (au_search === null)
            throw new Error("The parameter 'au_search' cannot be null.");
        else if (au_search !== undefined)
            url_ += "au_search=" + encodeURIComponent("" + au_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<AuthorDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthorDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<AuthorDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAuthor(body: CreateAuthorInput | undefined , cancelToken?: CancelToken | undefined): Promise<AuthorDto> {
        let url_ = this.baseUrl + "/api/services/app/Author/CreateAuthor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAuthor(_response);
        });
    }

    protected processCreateAuthor(response: AxiosResponse): Promise<AuthorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthorDto.fromJS(resultData200.result);
            return Promise.resolve<AuthorDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListAuthor(body: CreateAuthorInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<AuthorDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Author/CreateListAuthor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListAuthor(_response);
        });
    }

    protected processCreateListAuthor(response: AxiosResponse): Promise<AuthorDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuthorDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<AuthorDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAuthor(body: UpdateAuthorInput | undefined , cancelToken?: CancelToken | undefined): Promise<AuthorDto> {
        let url_ = this.baseUrl + "/api/services/app/Author/UpdateAuthor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAuthor(_response);
        });
    }

    protected processUpdateAuthor(response: AxiosResponse): Promise<AuthorDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthorDto.fromJS(resultData200.result);
            return Promise.resolve<AuthorDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthorDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePosition(body: UpdatePositionAuthorInput | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Author/ChangePosition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePosition(_response);
        });
    }

    protected processChangePosition(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Author/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Author/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Author/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class BillingService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param bi_code (optional) 
     * @param su_id (optional) 
     * @param co_id (optional) 
     * @param bi_export_from (optional) 
     * @param bi_export_to (optional) 
     * @param bi_status (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(bi_code: string | undefined, su_id: number | undefined, co_id: number | undefined, bi_export_from: Date | undefined, bi_export_to: Date | undefined, bi_status: BillStatus | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/GetAll?";
        if (bi_code === null)
            throw new Error("The parameter 'bi_code' cannot be null.");
        else if (bi_code !== undefined)
            url_ += "bi_code=" + encodeURIComponent("" + bi_code) + "&";
        if (su_id === null)
            throw new Error("The parameter 'su_id' cannot be null.");
        else if (su_id !== undefined)
            url_ += "su_id=" + encodeURIComponent("" + su_id) + "&";
        if (co_id === null)
            throw new Error("The parameter 'co_id' cannot be null.");
        else if (co_id !== undefined)
            url_ += "co_id=" + encodeURIComponent("" + co_id) + "&";
        if (bi_export_from === null)
            throw new Error("The parameter 'bi_export_from' cannot be null.");
        else if (bi_export_from !== undefined)
            url_ += "bi_export_from=" + encodeURIComponent(bi_export_from ? "" + bi_export_from.toISOString() : "") + "&";
        if (bi_export_to === null)
            throw new Error("The parameter 'bi_export_to' cannot be null.");
        else if (bi_export_to !== undefined)
            url_ += "bi_export_to=" + encodeURIComponent(bi_export_to ? "" + bi_export_to.toISOString() : "") + "&";
        if (bi_status === null)
            throw new Error("The parameter 'bi_status' cannot be null.");
        else if (bi_status !== undefined)
            url_ += "bi_status=" + encodeURIComponent("" + bi_status) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<BillingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBilling(body: CreateBillingInput | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/CreateBilling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateBilling(_response);
        });
    }

    protected processCreateBilling(response: AxiosResponse): Promise<BillingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBilling(body: UpdateBillingInput | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/UpdateBilling";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateBilling(_response);
        });
    }

    protected processUpdateBilling(response: AxiosResponse): Promise<BillingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPlanDetailArrInput(body: CreatePlanDetailArrInput | undefined , cancelToken?: CancelToken | undefined): Promise<BillingDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/CreatePlanDetailArrInput";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePlanDetailArrInput(_response);
        });
    }

    protected processCreatePlanDetailArrInput(response: AxiosResponse): Promise<BillingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingDto.fromJS(resultData200.result);
            return Promise.resolve<BillingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePosition(body: UpdatePositionBillingInput | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/ChangePosition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePosition(_response);
        });
    }

    protected processChangePosition(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param bi_id (optional) 
     * @return Success
     */
    delete(bi_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Billing/Delete?";
        if (bi_id === null)
            throw new Error("The parameter 'bi_id' cannot be null.");
        else if (bi_id !== undefined)
            url_ += "bi_id=" + encodeURIComponent("" + bi_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class BillingItemService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param bi_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(bi_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingItem/GetAll?";
        if (bi_id === null)
            throw new Error("The parameter 'bi_id' cannot be null.");
        else if (bi_id !== undefined)
            url_ += "bi_id=" + encodeURIComponent("" + bi_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<BillingItemDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingItemDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingItemDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingItemDtoPagedResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getByListId(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BillingItemDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingItem/GetByListId?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByListId(_response);
        });
    }

    protected processGetByListId(response: AxiosResponse): Promise<BillingItemDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingItemDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingItemDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingItemDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBillingItem(body: CreateBillingItemInput | undefined , cancelToken?: CancelToken | undefined): Promise<BillingItemDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingItem/CreateBillingItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateBillingItem(_response);
        });
    }

    protected processCreateBillingItem(response: AxiosResponse): Promise<BillingItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingItemDto.fromJS(resultData200.result);
            return Promise.resolve<BillingItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingItemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateBillingItem(body: UpdateBillingItemInput | undefined , cancelToken?: CancelToken | undefined): Promise<BillingItemDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingItem/UpdateBillingItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateBillingItem(_response);
        });
    }

    protected processUpdateBillingItem(response: AxiosResponse): Promise<BillingItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingItemDto.fromJS(resultData200.result);
            return Promise.resolve<BillingItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingItemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePosition(body: UpdatePositionBillingItemInput | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingItem/ChangePosition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePosition(_response);
        });
    }

    protected processChangePosition(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param pl_de_id (optional) 
     * @param bi_id (optional) 
     * @return Success
     */
    checkPlanDetailHasBilling(pl_de_id: number | undefined, bi_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingItemDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingItem/CheckPlanDetailHasBilling?";
        if (pl_de_id === null)
            throw new Error("The parameter 'pl_de_id' cannot be null.");
        else if (pl_de_id !== undefined)
            url_ += "pl_de_id=" + encodeURIComponent("" + pl_de_id) + "&";
        if (bi_id === null)
            throw new Error("The parameter 'bi_id' cannot be null.");
        else if (bi_id !== undefined)
            url_ += "bi_id=" + encodeURIComponent("" + bi_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPlanDetailHasBilling(_response);
        });
    }

    protected processCheckPlanDetailHasBilling(response: AxiosResponse): Promise<BillingItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingItemDto.fromJS(resultData200.result);
            return Promise.resolve<BillingItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingItemDto>(null as any);
    }

    /**
     * @param bi_it_id (optional) 
     * @return Success
     */
    delete(bi_it_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingItem/Delete?";
        if (bi_it_id === null)
            throw new Error("The parameter 'bi_it_id' cannot be null.");
        else if (bi_it_id !== undefined)
            url_ += "bi_it_id=" + encodeURIComponent("" + bi_it_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class BorrowReturningService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param us_id (optional) 
     * @return Success
     */
    findMemberById(us_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FindMemberBorrowDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/FindMemberById?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindMemberById(_response);
        });
    }

    protected processFindMemberById(response: AxiosResponse): Promise<FindMemberBorrowDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindMemberBorrowDto.fromJS(resultData200.result);
            return Promise.resolve<FindMemberBorrowDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindMemberBorrowDto>(null as any);
    }

    /**
     * @param dkcb (optional) 
     * @return Success
     */
    getDocumentInforByDKCB(dkcb: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetDocumentInforByDKCBDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/GetDocumentInforByDKCB?";
        if (dkcb === null)
            throw new Error("The parameter 'dkcb' cannot be null.");
        else if (dkcb !== undefined)
            url_ += "dkcb=" + encodeURIComponent("" + dkcb) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocumentInforByDKCB(_response);
        });
    }

    protected processGetDocumentInforByDKCB(response: AxiosResponse): Promise<GetDocumentInforByDKCBDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetDocumentInforByDKCBDto.fromJS(resultData200.result);
            return Promise.resolve<GetDocumentInforByDKCBDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDocumentInforByDKCBDto>(null as any);
    }

    /**
     * @param do_search (optional) 
     * @param author (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllDocumentToBorrow(do_search: string | undefined, author: string | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentBorrowDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/GetAllDocumentToBorrow?";
        if (do_search === null)
            throw new Error("The parameter 'do_search' cannot be null.");
        else if (do_search !== undefined)
            url_ += "do_search=" + encodeURIComponent("" + do_search) + "&";
        if (author === null)
            throw new Error("The parameter 'author' cannot be null.");
        else if (author !== undefined)
            url_ += "author=" + encodeURIComponent("" + author) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllDocumentToBorrow(_response);
        });
    }

    protected processGetAllDocumentToBorrow(response: AxiosResponse): Promise<DocumentBorrowDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentBorrowDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentBorrowDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentBorrowDtoPagedResultDto>(null as any);
    }

    /**
     * @param do_id (optional) 
     * @param dkcb (optional) 
     * @return Success
     */
    checkDocumentInforValidForBorrow(do_id: number | undefined, dkcb: string | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/CheckDocumentInforValidForBorrow?";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        if (dkcb === null)
            throw new Error("The parameter 'dkcb' cannot be null.");
        else if (dkcb !== undefined)
            url_ += "dkcb=" + encodeURIComponent("" + dkcb) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckDocumentInforValidForBorrow(_response);
        });
    }

    protected processCheckDocumentInforValidForBorrow(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param br_re_id (optional) 
     * @return Success
     */
    getDetailBorrowReturn(br_re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BorrowReturningDetailsWithListDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/GetDetailBorrowReturn?";
        if (br_re_id === null)
            throw new Error("The parameter 'br_re_id' cannot be null.");
        else if (br_re_id !== undefined)
            url_ += "br_re_id=" + encodeURIComponent("" + br_re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDetailBorrowReturn(_response);
        });
    }

    protected processGetDetailBorrowReturn(response: AxiosResponse): Promise<BorrowReturningDetailsWithListDocumentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BorrowReturningDetailsWithListDocumentDto.fromJS(resultData200.result);
            return Promise.resolve<BorrowReturningDetailsWithListDocumentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BorrowReturningDetailsWithListDocumentDto>(null as any);
    }

    /**
     * @param br_re_code (optional) 
     * @param us_id_borrow (optional) 
     * @param br_re_start_at (optional) 
     * @param br_re_end_at (optional) 
     * @param dkcb_code (optional) 
     * @param br_re_status (optional) 
     * @param br_re_method (optional) 
     * @param br_re_de_status (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(br_re_code: string | undefined, us_id_borrow: number | undefined, br_re_start_at: Date | undefined, br_re_end_at: Date | undefined, dkcb_code: string | undefined, br_re_status: BorrowReturningProcess[] | undefined, br_re_method: BorrowMethod | undefined, br_re_de_status: BorrowReturningDetailStatus | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BorrowReturningDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/GetAll?";
        if (br_re_code === null)
            throw new Error("The parameter 'br_re_code' cannot be null.");
        else if (br_re_code !== undefined)
            url_ += "br_re_code=" + encodeURIComponent("" + br_re_code) + "&";
        if (us_id_borrow === null)
            throw new Error("The parameter 'us_id_borrow' cannot be null.");
        else if (us_id_borrow !== undefined)
            url_ += "us_id_borrow=" + encodeURIComponent("" + us_id_borrow) + "&";
        if (br_re_start_at === null)
            throw new Error("The parameter 'br_re_start_at' cannot be null.");
        else if (br_re_start_at !== undefined)
            url_ += "br_re_start_at=" + encodeURIComponent(br_re_start_at ? "" + br_re_start_at.toISOString() : "") + "&";
        if (br_re_end_at === null)
            throw new Error("The parameter 'br_re_end_at' cannot be null.");
        else if (br_re_end_at !== undefined)
            url_ += "br_re_end_at=" + encodeURIComponent(br_re_end_at ? "" + br_re_end_at.toISOString() : "") + "&";
        if (dkcb_code === null)
            throw new Error("The parameter 'dkcb_code' cannot be null.");
        else if (dkcb_code !== undefined)
            url_ += "dkcb_code=" + encodeURIComponent("" + dkcb_code) + "&";
        if (br_re_status === null)
            throw new Error("The parameter 'br_re_status' cannot be null.");
        else if (br_re_status !== undefined)
            br_re_status && br_re_status.forEach(item => { url_ += "br_re_status=" + encodeURIComponent("" + item) + "&"; });
        if (br_re_method === null)
            throw new Error("The parameter 'br_re_method' cannot be null.");
        else if (br_re_method !== undefined)
            url_ += "br_re_method=" + encodeURIComponent("" + br_re_method) + "&";
        if (br_re_de_status === null)
            throw new Error("The parameter 'br_re_de_status' cannot be null.");
        else if (br_re_de_status !== undefined)
            url_ += "br_re_de_status=" + encodeURIComponent("" + br_re_de_status) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<BorrowReturningDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BorrowReturningDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BorrowReturningDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BorrowReturningDtoPagedResultDto>(null as any);
    }

    /**
     * @param br_re_de_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getByIdArr(br_re_de_id: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BorrowReturningIDetailDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/GetByIdArr?";
        if (br_re_de_id === null)
            throw new Error("The parameter 'br_re_de_id' cannot be null.");
        else if (br_re_de_id !== undefined)
            br_re_de_id && br_re_de_id.forEach(item => { url_ += "br_re_de_id=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByIdArr(_response);
        });
    }

    protected processGetByIdArr(response: AxiosResponse): Promise<BorrowReturningIDetailDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BorrowReturningIDetailDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BorrowReturningIDetailDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BorrowReturningIDetailDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAtDesk(body: CreateBorrowReturningAtDeskInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/CreateAtDesk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateAtDesk(_response);
        });
    }

    protected processCreateAtDesk(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateBorrowReturningInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deliveryDocument(body: DeliveryDocumentInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/DeliveryDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeliveryDocument(_response);
        });
    }

    protected processDeliveryDocument(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    returnDocument(body: ReturnDocumentInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/ReturnDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processReturnDocument(_response);
        });
    }

    protected processReturnDocument(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateBorrowReturningInput | undefined , cancelToken?: CancelToken | undefined): Promise<BorrowReturningDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<BorrowReturningDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BorrowReturningDto.fromJS(resultData200.result);
            return Promise.resolve<BorrowReturningDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BorrowReturningDto>(null as any);
    }

    /**
     * @param br_re_id (optional) 
     * @return Success
     */
    delete(br_re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/Delete?";
        if (br_re_id === null)
            throw new Error("The parameter 'br_re_id' cannot be null.");
        else if (br_re_id !== undefined)
            url_ += "br_re_id=" + encodeURIComponent("" + br_re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param br_re_de_id (optional) 
     * @return Success
     */
    deleteBorrowItem(br_re_de_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/DeleteBorrowItem?";
        if (br_re_de_id === null)
            throw new Error("The parameter 'br_re_de_id' cannot be null.");
        else if (br_re_de_id !== undefined)
            url_ += "br_re_de_id=" + encodeURIComponent("" + br_re_de_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteBorrowItem(_response);
        });
    }

    protected processDeleteBorrowItem(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param br_re_id (optional) 
     * @param br_re_desc (optional) 
     * @return Success
     */
    approve(br_re_id: number | undefined, br_re_desc: string | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/Approve?";
        if (br_re_id === null)
            throw new Error("The parameter 'br_re_id' cannot be null.");
        else if (br_re_id !== undefined)
            url_ += "br_re_id=" + encodeURIComponent("" + br_re_id) + "&";
        if (br_re_desc === null)
            throw new Error("The parameter 'br_re_desc' cannot be null.");
        else if (br_re_desc !== undefined)
            url_ += "br_re_desc=" + encodeURIComponent("" + br_re_desc) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApprove(_response);
        });
    }

    protected processApprove(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancel(body: CancelBorrowReturningInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/Cancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extend(body: ExtendtBorrowReturningInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/Extend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExtend(_response);
        });
    }

    protected processExtend(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param br_re_id (optional) 
     * @return Success
     */
    memberGetDetailBorrowReturn(br_re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BorrowReturningDetailsWithListDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/MemberGetDetailBorrowReturn?";
        if (br_re_id === null)
            throw new Error("The parameter 'br_re_id' cannot be null.");
        else if (br_re_id !== undefined)
            url_ += "br_re_id=" + encodeURIComponent("" + br_re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMemberGetDetailBorrowReturn(_response);
        });
    }

    protected processMemberGetDetailBorrowReturn(response: AxiosResponse): Promise<BorrowReturningDetailsWithListDocumentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BorrowReturningDetailsWithListDocumentDto.fromJS(resultData200.result);
            return Promise.resolve<BorrowReturningDetailsWithListDocumentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BorrowReturningDetailsWithListDocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    memberGetAllDocumentToBorrow(body: MemberSearchDocumentToBorrowInput | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentBorrowDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/MemberGetAllDocumentToBorrow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMemberGetAllDocumentToBorrow(_response);
        });
    }

    protected processMemberGetAllDocumentToBorrow(response: AxiosResponse): Promise<DocumentBorrowDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentBorrowDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentBorrowDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentBorrowDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    memberCreate(body: MemberCreateBorrowReturningInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/MemberCreate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMemberCreate(_response);
        });
    }

    protected processMemberCreate(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    memeberCancel(body: CancelBorrowReturningInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/MemeberCancel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMemeberCancel(_response);
        });
    }

    protected processMemeberCancel(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    memberGetAll(body: MemberSearchBorrowReturningInput | undefined , cancelToken?: CancelToken | undefined): Promise<BorrowReturningDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/MemberGetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMemberGetAll(_response);
        });
    }

    protected processMemberGetAll(response: AxiosResponse): Promise<BorrowReturningDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BorrowReturningDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BorrowReturningDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BorrowReturningDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    memberExtend(body: ExtendtBorrowReturningInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/MemberExtend";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMemberExtend(_response);
        });
    }

    protected processMemberExtend(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param do_id (optional) 
     * @return Success
     */
    memberGetDocumentBorrowById(do_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentBorrowDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturning/MemberGetDocumentBorrowById?";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMemberGetDocumentBorrowById(_response);
        });
    }

    protected processMemberGetDocumentBorrowById(response: AxiosResponse): Promise<DocumentBorrowDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentBorrowDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentBorrowDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentBorrowDto>(null as any);
    }
}

export class BorrowReturningLogService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param us_id_borrow (optional) 
     * @param br_re_lo_type (optional) 
     * @param start_date (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(us_id_borrow: number | undefined, br_re_lo_type: BorrowReturnLogType | undefined, start_date: Date | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<BorrowReturningLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturningLog/GetAll?";
        if (us_id_borrow === null)
            throw new Error("The parameter 'us_id_borrow' cannot be null.");
        else if (us_id_borrow !== undefined)
            url_ += "us_id_borrow=" + encodeURIComponent("" + us_id_borrow) + "&";
        if (br_re_lo_type === null)
            throw new Error("The parameter 'br_re_lo_type' cannot be null.");
        else if (br_re_lo_type !== undefined)
            url_ += "br_re_lo_type=" + encodeURIComponent("" + br_re_lo_type) + "&";
        if (start_date === null)
            throw new Error("The parameter 'start_date' cannot be null.");
        else if (start_date !== undefined)
            url_ += "start_date=" + encodeURIComponent(start_date ? "" + start_date.toISOString() : "") + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<BorrowReturningLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BorrowReturningLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BorrowReturningLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BorrowReturningLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    memberGetAll(body: MemberSearchBorrowReturningLogInput | undefined , cancelToken?: CancelToken | undefined): Promise<BorrowReturningLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/BorrowReturningLog/MemberGetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMemberGetAll(_response);
        });
    }

    protected processMemberGetAll(response: AxiosResponse): Promise<BorrowReturningLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BorrowReturningLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<BorrowReturningLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BorrowReturningLogDtoPagedResultDto>(null as any);
    }
}

export class CatalogingService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param do_in_search (optional) 
     * @param cata_resultDDC (optional) 
     * @param cata_resultTitle (optional) 
     * @param cata_resultColor (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(do_in_search: string | undefined, cata_resultDDC: string | undefined, cata_resultTitle: string | undefined, cata_resultColor: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<CatalogingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Cataloging/GetAll?";
        if (do_in_search === null)
            throw new Error("The parameter 'do_in_search' cannot be null.");
        else if (do_in_search !== undefined)
            url_ += "do_in_search=" + encodeURIComponent("" + do_in_search) + "&";
        if (cata_resultDDC === null)
            throw new Error("The parameter 'cata_resultDDC' cannot be null.");
        else if (cata_resultDDC !== undefined)
            url_ += "cata_resultDDC=" + encodeURIComponent("" + cata_resultDDC) + "&";
        if (cata_resultTitle === null)
            throw new Error("The parameter 'cata_resultTitle' cannot be null.");
        else if (cata_resultTitle !== undefined)
            url_ += "cata_resultTitle=" + encodeURIComponent("" + cata_resultTitle) + "&";
        if (cata_resultColor === null)
            throw new Error("The parameter 'cata_resultColor' cannot be null.");
        else if (cata_resultColor !== undefined)
            url_ += "cata_resultColor=" + encodeURIComponent("" + cata_resultColor) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<CatalogingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CatalogingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<CatalogingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CatalogingDtoPagedResultDto>(null as any);
    }

    /**
     * @param dkcb_code (optional) 
     * @return Success
     */
    getCatalogingFromDKCB(dkcb_code: string | undefined , cancelToken?: CancelToken | undefined): Promise<CatalogingDto> {
        let url_ = this.baseUrl + "/api/services/app/Cataloging/GetCatalogingFromDKCB?";
        if (dkcb_code === null)
            throw new Error("The parameter 'dkcb_code' cannot be null.");
        else if (dkcb_code !== undefined)
            url_ += "dkcb_code=" + encodeURIComponent("" + dkcb_code) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCatalogingFromDKCB(_response);
        });
    }

    protected processGetCatalogingFromDKCB(response: AxiosResponse): Promise<CatalogingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CatalogingDto.fromJS(resultData200.result);
            return Promise.resolve<CatalogingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CatalogingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCataloging(body: CreateCatalogingInput | undefined , cancelToken?: CancelToken | undefined): Promise<CatalogingDto> {
        let url_ = this.baseUrl + "/api/services/app/Cataloging/CreateCataloging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCataloging(_response);
        });
    }

    protected processCreateCataloging(response: AxiosResponse): Promise<CatalogingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CatalogingDto.fromJS(resultData200.result);
            return Promise.resolve<CatalogingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CatalogingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCataloging(body: UpdateCatalogingInput | undefined , cancelToken?: CancelToken | undefined): Promise<CatalogingDto> {
        let url_ = this.baseUrl + "/api/services/app/Cataloging/UpdateCataloging";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCataloging(_response);
        });
    }

    protected processUpdateCataloging(response: AxiosResponse): Promise<CatalogingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CatalogingDto.fromJS(resultData200.result);
            return Promise.resolve<CatalogingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CatalogingDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Cataloging/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class CategoryService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ca_search (optional) 
     * @return Success
     */
    getAll(ca_search: string | undefined , cancelToken?: CancelToken | undefined): Promise<CategoryDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/GetAll?";
        if (ca_search === null)
            throw new Error("The parameter 'ca_search' cannot be null.");
        else if (ca_search !== undefined)
            url_ += "ca_search=" + encodeURIComponent("" + ca_search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<CategoryDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<CategoryDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListCategory(body: CreateCategoryInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<CategoryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Category/CreateListCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListCategory(_response);
        });
    }

    protected processCreateListCategory(response: AxiosResponse): Promise<CategoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CategoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDto[]>(null as any);
    }

    /**
     * @param do_id (optional) 
     * @return Success
     */
    getCateByDoID(do_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/GetCateByDoID?";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCateByDoID(_response);
        });
    }

    protected processGetCateByDoID(response: AxiosResponse): Promise<CategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryDto.fromJS(resultData200.result);
            return Promise.resolve<CategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCategory(body: CreateCategoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/CreateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: AxiosResponse): Promise<CategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryDto.fromJS(resultData200.result);
            return Promise.resolve<CategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCategory(body: UpdateCategoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<CategoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/UpdateCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCategory(_response);
        });
    }

    protected processUpdateCategory(response: AxiosResponse): Promise<CategoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CategoryDto.fromJS(resultData200.result);
            return Promise.resolve<CategoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CategoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePosition(body: UpdatePositionCategoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/ChangePosition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePosition(_response);
        });
    }

    protected processChangePosition(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param ca_id (optional) 
     * @return Success
     */
    delete(ca_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Category/Delete?";
        if (ca_id === null)
            throw new Error("The parameter 'ca_id' cannot be null.");
        else if (ca_id !== undefined)
            url_ += "ca_id=" + encodeURIComponent("" + ca_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class CheckService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param day (optional) 
     * @param do_total_book_valid (optional) 
     * @param ignore_do_inside_check_plan (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDocumentWarningAll(day: number | undefined, do_total_book_valid: number | undefined, ignore_do_inside_check_plan: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/GetDocumentWarningAll?";
        if (day === null)
            throw new Error("The parameter 'day' cannot be null.");
        else if (day !== undefined)
            url_ += "day=" + encodeURIComponent("" + day) + "&";
        if (do_total_book_valid === null)
            throw new Error("The parameter 'do_total_book_valid' cannot be null.");
        else if (do_total_book_valid !== undefined)
            url_ += "do_total_book_valid=" + encodeURIComponent("" + do_total_book_valid) + "&";
        if (ignore_do_inside_check_plan === null)
            throw new Error("The parameter 'ignore_do_inside_check_plan' cannot be null.");
        else if (ignore_do_inside_check_plan !== undefined)
            url_ += "ignore_do_inside_check_plan=" + encodeURIComponent("" + ignore_do_inside_check_plan) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocumentWarningAll(_response);
        });
    }

    protected processGetDocumentWarningAll(response: AxiosResponse): Promise<DocumentDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDtoPagedResultDto>(null as any);
    }

    /**
     * @param ck_search (optional) 
     * @param ck_start_at (optional) 
     * @param ck_process (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ck_search: string | undefined, ck_start_at: Date | undefined, ck_process: CheckProcess | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<CheckDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/GetAll?";
        if (ck_search === null)
            throw new Error("The parameter 'ck_search' cannot be null.");
        else if (ck_search !== undefined)
            url_ += "ck_search=" + encodeURIComponent("" + ck_search) + "&";
        if (ck_start_at === null)
            throw new Error("The parameter 'ck_start_at' cannot be null.");
        else if (ck_start_at !== undefined)
            url_ += "ck_start_at=" + encodeURIComponent(ck_start_at ? "" + ck_start_at.toISOString() : "") + "&";
        if (ck_process === null)
            throw new Error("The parameter 'ck_process' cannot be null.");
        else if (ck_process !== undefined)
            url_ += "ck_process=" + encodeURIComponent("" + ck_process) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<CheckDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<CheckDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCheck(body: CreateCheckInput | undefined , cancelToken?: CancelToken | undefined): Promise<CheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/CreateCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCheck(_response);
        });
    }

    protected processCreateCheck(response: AxiosResponse): Promise<CheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckDto.fromJS(resultData200.result);
            return Promise.resolve<CheckDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCheck(body: UpdateCheckInput | undefined , cancelToken?: CancelToken | undefined): Promise<CheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/UpdateCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCheck(_response);
        });
    }

    protected processUpdateCheck(response: AxiosResponse): Promise<CheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckDto.fromJS(resultData200.result);
            return Promise.resolve<CheckDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckDto>(null as any);
    }

    /**
     * @param ck_id (optional) 
     * @return Success
     */
    delete(ck_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/Delete?";
        if (ck_id === null)
            throw new Error("The parameter 'ck_id' cannot be null.");
        else if (ck_id !== undefined)
            url_ += "ck_id=" + encodeURIComponent("" + ck_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeProcessOfManager(body: ChangeProcessCheckInput | undefined , cancelToken?: CancelToken | undefined): Promise<CheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/ChangeProcessOfManager";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeProcessOfManager(_response);
        });
    }

    protected processChangeProcessOfManager(response: AxiosResponse): Promise<CheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckDto.fromJS(resultData200.result);
            return Promise.resolve<CheckDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeProcessOfPlanRoom(body: ChangeProcessCheckInput | undefined , cancelToken?: CancelToken | undefined): Promise<CheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/ChangeProcessOfPlanRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeProcessOfPlanRoom(_response);
        });
    }

    protected processChangeProcessOfPlanRoom(response: AxiosResponse): Promise<CheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckDto.fromJS(resultData200.result);
            return Promise.resolve<CheckDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    waitApprove(body: ChangeProcessCheckInput | undefined , cancelToken?: CancelToken | undefined): Promise<CheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/WaitApprove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWaitApprove(_response);
        });
    }

    protected processWaitApprove(response: AxiosResponse): Promise<CheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckDto.fromJS(resultData200.result);
            return Promise.resolve<CheckDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckDto>(null as any);
    }

    /**
     * @param ck_id (optional) 
     * @return Success
     */
    changeStatusChecking(ck_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<CheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/ChangeStatusChecking?";
        if (ck_id === null)
            throw new Error("The parameter 'ck_id' cannot be null.");
        else if (ck_id !== undefined)
            url_ += "ck_id=" + encodeURIComponent("" + ck_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatusChecking(_response);
        });
    }

    protected processChangeStatusChecking(response: AxiosResponse): Promise<CheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckDto.fromJS(resultData200.result);
            return Promise.resolve<CheckDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckDto>(null as any);
    }

    /**
     * @param ck_id (optional) 
     * @return Success
     */
    changeStatusDone(ck_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<CheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/ChangeStatusDone?";
        if (ck_id === null)
            throw new Error("The parameter 'ck_id' cannot be null.");
        else if (ck_id !== undefined)
            url_ += "ck_id=" + encodeURIComponent("" + ck_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatusDone(_response);
        });
    }

    protected processChangeStatusDone(response: AxiosResponse): Promise<CheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckDto.fromJS(resultData200.result);
            return Promise.resolve<CheckDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onChangeStatusDocumentInfor(body: Document | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Check/onChangeStatusDocumentInfor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnChangeStatusDocumentInfor(_response);
        });
    }

    protected processOnChangeStatusDocumentInfor(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param ck_id (optional) 
     * @param dkcb (optional) 
     * @return Success
     */
    getDocumentInforByDKCBInCheck(ck_id: number | undefined, dkcb: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetDocumentInforByDKCBCheckDto> {
        let url_ = this.baseUrl + "/api/services/app/Check/GetDocumentInforByDKCBInCheck?";
        if (ck_id === null)
            throw new Error("The parameter 'ck_id' cannot be null.");
        else if (ck_id !== undefined)
            url_ += "ck_id=" + encodeURIComponent("" + ck_id) + "&";
        if (dkcb === null)
            throw new Error("The parameter 'dkcb' cannot be null.");
        else if (dkcb !== undefined)
            url_ += "dkcb=" + encodeURIComponent("" + dkcb) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocumentInforByDKCBInCheck(_response);
        });
    }

    protected processGetDocumentInforByDKCBInCheck(response: AxiosResponse): Promise<GetDocumentInforByDKCBCheckDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetDocumentInforByDKCBCheckDto.fromJS(resultData200.result);
            return Promise.resolve<GetDocumentInforByDKCBCheckDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetDocumentInforByDKCBCheckDto>(null as any);
    }
}

export class CheckItemService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ck_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ck_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<CheckItemDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CheckItem/GetAll?";
        if (ck_id === null)
            throw new Error("The parameter 'ck_id' cannot be null.");
        else if (ck_id !== undefined)
            url_ += "ck_id=" + encodeURIComponent("" + ck_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<CheckItemDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckItemDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<CheckItemDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckItemDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListCheckItem(body: CreateCheckItemInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<CheckItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/CheckItem/CreateListCheckItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListCheckItem(_response);
        });
    }

    protected processCreateListCheckItem(response: AxiosResponse): Promise<CheckItemDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CheckItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CheckItemDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckItemDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCheckItem(body: CreateCheckItemInput | undefined , cancelToken?: CancelToken | undefined): Promise<CheckItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CheckItem/CreateCheckItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateCheckItem(_response);
        });
    }

    protected processCreateCheckItem(response: AxiosResponse): Promise<CheckItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckItemDto.fromJS(resultData200.result);
            return Promise.resolve<CheckItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckItemDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCheckItem(body: UpdateCheckItemInput | undefined , cancelToken?: CancelToken | undefined): Promise<CheckItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CheckItem/UpdateCheckItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateCheckItem(_response);
        });
    }

    protected processUpdateCheckItem(response: AxiosResponse): Promise<CheckItemDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckItemDto.fromJS(resultData200.result);
            return Promise.resolve<CheckItemDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckItemDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/CheckItem/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class CitationService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ci_year_publish (optional) 
     * @param ci_date_access (optional) 
     * @param ci_type (optional) 
     * @param ci_structure (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ci_year_publish: string | undefined, ci_date_access: Date | undefined, ci_type: CitationType | undefined, ci_structure: CitationStructure | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<CitationDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Citation/GetAll?";
        if (ci_year_publish === null)
            throw new Error("The parameter 'ci_year_publish' cannot be null.");
        else if (ci_year_publish !== undefined)
            url_ += "ci_year_publish=" + encodeURIComponent("" + ci_year_publish) + "&";
        if (ci_date_access === null)
            throw new Error("The parameter 'ci_date_access' cannot be null.");
        else if (ci_date_access !== undefined)
            url_ += "ci_date_access=" + encodeURIComponent(ci_date_access ? "" + ci_date_access.toISOString() : "") + "&";
        if (ci_type === null)
            throw new Error("The parameter 'ci_type' cannot be null.");
        else if (ci_type !== undefined)
            url_ += "ci_type=" + encodeURIComponent("" + ci_type) + "&";
        if (ci_structure === null)
            throw new Error("The parameter 'ci_structure' cannot be null.");
        else if (ci_structure !== undefined)
            url_ += "ci_structure=" + encodeURIComponent("" + ci_structure) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<CitationDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CitationDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<CitationDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CitationDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCitation(body: CreateOrUpdateCitationInput | undefined , cancelToken?: CancelToken | undefined): Promise<CitationDto> {
        let url_ = this.baseUrl + "/api/services/app/Citation/CreateOrUpdateCitation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrUpdateCitation(_response);
        });
    }

    protected processCreateOrUpdateCitation(response: AxiosResponse): Promise<CitationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CitationDto.fromJS(resultData200.result);
            return Promise.resolve<CitationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CitationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListCitation(body: CreateListCitationInput | undefined , cancelToken?: CancelToken | undefined): Promise<CitationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Citation/CreateListCitation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListCitation(_response);
        });
    }

    protected processCreateListCitation(response: AxiosResponse): Promise<CitationDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CitationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<CitationDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CitationDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onMapDocument(body: Citation | undefined , cancelToken?: CancelToken | undefined): Promise<CitationDto> {
        let url_ = this.baseUrl + "/api/services/app/Citation/onMapDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnMapDocument(_response);
        });
    }

    protected processOnMapDocument(response: AxiosResponse): Promise<CitationDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CitationDto.fromJS(resultData200.result);
            return Promise.resolve<CitationDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CitationDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onResultCitation(body: Citation | undefined , cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/Citation/onResultCitation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnResultCitation(_response);
        });
    }

    protected processOnResultCitation(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @param do_id (optional) 
     * @return Success
     */
    delete(do_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Citation/Delete?";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Citation/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class ConfigurationService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeUiTheme(body: ChangeUiThemeInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeUiTheme(_response);
        });
    }

    protected processChangeUiTheme(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ContractService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param pl_id (optional) 
     * @param co_search (optional) 
     * @param co_status (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(pl_id: number | undefined, co_search: string | undefined, co_status: ContractStatus | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ContractDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetAll?";
        if (pl_id === null)
            throw new Error("The parameter 'pl_id' cannot be null.");
        else if (pl_id !== undefined)
            url_ += "pl_id=" + encodeURIComponent("" + pl_id) + "&";
        if (co_search === null)
            throw new Error("The parameter 'co_search' cannot be null.");
        else if (co_search !== undefined)
            url_ += "co_search=" + encodeURIComponent("" + co_search) + "&";
        if (co_status === null)
            throw new Error("The parameter 'co_status' cannot be null.");
        else if (co_status !== undefined)
            url_ += "co_status=" + encodeURIComponent("" + co_status) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ContractDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContractDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ContractDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContractDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createContract(body: CreateContractInput | undefined , cancelToken?: CancelToken | undefined): Promise<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/CreateContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateContract(_response);
        });
    }

    protected processCreateContract(response: AxiosResponse): Promise<ContractDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContractDto.fromJS(resultData200.result);
            return Promise.resolve<ContractDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContractDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContract(body: UpdateContractInput | undefined , cancelToken?: CancelToken | undefined): Promise<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/UpdateContract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateContract(_response);
        });
    }

    protected processUpdateContract(response: AxiosResponse): Promise<ContractDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContractDto.fromJS(resultData200.result);
            return Promise.resolve<ContractDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContractDto>(null as any);
    }

    /**
     * @param co_id (optional) 
     * @return Success
     */
    confirmDone(co_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<ContractDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/ConfirmDone?";
        if (co_id === null)
            throw new Error("The parameter 'co_id' cannot be null.");
        else if (co_id !== undefined)
            url_ += "co_id=" + encodeURIComponent("" + co_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmDone(_response);
        });
    }

    protected processConfirmDone(response: AxiosResponse): Promise<ContractDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ContractDto.fromJS(resultData200.result);
            return Promise.resolve<ContractDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContractDto>(null as any);
    }

    /**
     * @param co_id (optional) 
     * @return Success
     */
    delete(co_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/Delete?";
        if (co_id === null)
            throw new Error("The parameter 'co_id' cannot be null.");
        else if (co_id !== undefined)
            url_ += "co_id=" + encodeURIComponent("" + co_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param pl_title (optional) 
     * @return Success
     */
    getAllPlan(pl_title: string | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetAllPlan?";
        if (pl_title === null)
            throw new Error("The parameter 'pl_title' cannot be null.");
        else if (pl_title !== undefined)
            url_ += "pl_title=" + encodeURIComponent("" + pl_title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPlan(_response);
        });
    }

    protected processGetAllPlan(response: AxiosResponse): Promise<PlanDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDtoListResultDto>(null as any);
    }

    /**
     * @param co_id (optional) 
     * @return Success
     */
    getAllBillingItem(co_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BillingItemDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Contract/GetAllBillingItem?";
        if (co_id === null)
            throw new Error("The parameter 'co_id' cannot be null.");
        else if (co_id !== undefined)
            url_ += "co_id=" + encodeURIComponent("" + co_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllBillingItem(_response);
        });
    }

    protected processGetAllBillingItem(response: AxiosResponse): Promise<BillingItemDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BillingItemDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<BillingItemDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BillingItemDtoListResultDto>(null as any);
    }
}

export class DashboardService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getDashboard(  cancelToken?: CancelToken | undefined): Promise<DashboardDto> {
        let url_ = this.baseUrl + "/api/services/app/Dashboard/GetDashboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDashboard(_response);
        });
    }

    protected processGetDashboard(response: AxiosResponse): Promise<DashboardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DashboardDto.fromJS(resultData200.result);
            return Promise.resolve<DashboardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DashboardDto>(null as any);
    }
}

export class DictionariesService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param dic_search (optional) 
     * @param dic_ty_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(dic_search: string | undefined, dic_ty_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DictionariesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Dictionaries/GetAll?";
        if (dic_search === null)
            throw new Error("The parameter 'dic_search' cannot be null.");
        else if (dic_search !== undefined)
            url_ += "dic_search=" + encodeURIComponent("" + dic_search) + "&";
        if (dic_ty_id === null)
            throw new Error("The parameter 'dic_ty_id' cannot be null.");
        else if (dic_ty_id !== undefined)
            url_ += "dic_ty_id=" + encodeURIComponent("" + dic_ty_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<DictionariesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DictionariesDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DictionariesDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionariesDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDictionariesInput | undefined , cancelToken?: CancelToken | undefined): Promise<DictionariesDto> {
        let url_ = this.baseUrl + "/api/services/app/Dictionaries/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<DictionariesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DictionariesDto.fromJS(resultData200.result);
            return Promise.resolve<DictionariesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionariesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListDictionaries(body: CreateDictionariesInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<DictionariesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Dictionaries/CreateListDictionaries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListDictionaries(_response);
        });
    }

    protected processCreateListDictionaries(response: AxiosResponse): Promise<DictionariesDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DictionariesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DictionariesDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionariesDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDictionariesInput | undefined , cancelToken?: CancelToken | undefined): Promise<DictionariesDto> {
        let url_ = this.baseUrl + "/api/services/app/Dictionaries/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<DictionariesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DictionariesDto.fromJS(resultData200.result);
            return Promise.resolve<DictionariesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionariesDto>(null as any);
    }

    /**
     * @param dic_id (optional) 
     * @return Success
     */
    delete(dic_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Dictionaries/Delete?";
        if (dic_id === null)
            throw new Error("The parameter 'dic_id' cannot be null.");
        else if (dic_id !== undefined)
            url_ += "dic_id=" + encodeURIComponent("" + dic_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Dictionaries/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Dictionaries/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class DictionaryTypeService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param dic_ty_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(dic_ty_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DictionaryTypeDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DictionaryType/GetAll?";
        if (dic_ty_search === null)
            throw new Error("The parameter 'dic_ty_search' cannot be null.");
        else if (dic_ty_search !== undefined)
            url_ += "dic_ty_search=" + encodeURIComponent("" + dic_ty_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<DictionaryTypeDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DictionaryTypeDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DictionaryTypeDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionaryTypeDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateDictionaryTypeInput | undefined , cancelToken?: CancelToken | undefined): Promise<DictionaryTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DictionaryType/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<DictionaryTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DictionaryTypeDto.fromJS(resultData200.result);
            return Promise.resolve<DictionaryTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionaryTypeDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createList(body: CreateDictionaryTypeInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<DictionaryTypeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DictionaryType/CreateList";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateList(_response);
        });
    }

    protected processCreateList(response: AxiosResponse): Promise<DictionaryTypeDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DictionaryTypeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DictionaryTypeDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionaryTypeDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateDictionaryTypeInput | undefined , cancelToken?: CancelToken | undefined): Promise<DictionaryTypeDto> {
        let url_ = this.baseUrl + "/api/services/app/DictionaryType/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<DictionaryTypeDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DictionaryTypeDto.fromJS(resultData200.result);
            return Promise.resolve<DictionaryTypeDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionaryTypeDto>(null as any);
    }

    /**
     * @param dic_ty_id (optional) 
     * @return Success
     */
    delete(dic_ty_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DictionaryType/Delete?";
        if (dic_ty_id === null)
            throw new Error("The parameter 'dic_ty_id' cannot be null.");
        else if (dic_ty_id !== undefined)
            url_ += "dic_ty_id=" + encodeURIComponent("" + dic_ty_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param dic_ty_id (optional) 
     * @param is_active (optional) 
     * @return Success
     */
    changeStatus(dic_ty_id: number | undefined, is_active: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DictionaryType/ChangeStatus?";
        if (dic_ty_id === null)
            throw new Error("The parameter 'dic_ty_id' cannot be null.");
        else if (dic_ty_id !== undefined)
            url_ += "dic_ty_id=" + encodeURIComponent("" + dic_ty_id) + "&";
        if (is_active === null)
            throw new Error("The parameter 'is_active' cannot be null.");
        else if (is_active !== undefined)
            url_ += "is_active=" + encodeURIComponent("" + is_active) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DictionaryType/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/DictionaryType/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class DocumentService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param do_title (optional) 
     * @param do_date_publish (optional) 
     * @param do_identifier (optional) 
     * @param to_id (optional) 
     * @param ca_id (optional) 
     * @param author (optional) 
     * @param do_status (optional) 
     * @param do_borrow_status (optional) 
     * @param do_date_available (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(do_title: string | undefined, do_date_publish: string | undefined, do_identifier: string | undefined, to_id: number | undefined, ca_id: number | undefined, author: string | undefined, do_status: DocumentStatus | undefined, do_borrow_status: DocumentBorrowType | undefined, do_date_available: Date | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/GetAll?";
        if (do_title === null)
            throw new Error("The parameter 'do_title' cannot be null.");
        else if (do_title !== undefined)
            url_ += "do_title=" + encodeURIComponent("" + do_title) + "&";
        if (do_date_publish === null)
            throw new Error("The parameter 'do_date_publish' cannot be null.");
        else if (do_date_publish !== undefined)
            url_ += "do_date_publish=" + encodeURIComponent("" + do_date_publish) + "&";
        if (do_identifier === null)
            throw new Error("The parameter 'do_identifier' cannot be null.");
        else if (do_identifier !== undefined)
            url_ += "do_identifier=" + encodeURIComponent("" + do_identifier) + "&";
        if (to_id === null)
            throw new Error("The parameter 'to_id' cannot be null.");
        else if (to_id !== undefined)
            url_ += "to_id=" + encodeURIComponent("" + to_id) + "&";
        if (ca_id === null)
            throw new Error("The parameter 'ca_id' cannot be null.");
        else if (ca_id !== undefined)
            url_ += "ca_id=" + encodeURIComponent("" + ca_id) + "&";
        if (author === null)
            throw new Error("The parameter 'author' cannot be null.");
        else if (author !== undefined)
            url_ += "author=" + encodeURIComponent("" + author) + "&";
        if (do_status === null)
            throw new Error("The parameter 'do_status' cannot be null.");
        else if (do_status !== undefined)
            url_ += "do_status=" + encodeURIComponent("" + do_status) + "&";
        if (do_borrow_status === null)
            throw new Error("The parameter 'do_borrow_status' cannot be null.");
        else if (do_borrow_status !== undefined)
            url_ += "do_borrow_status=" + encodeURIComponent("" + do_borrow_status) + "&";
        if (do_date_available === null)
            throw new Error("The parameter 'do_date_available' cannot be null.");
        else if (do_date_available !== undefined)
            url_ += "do_date_available=" + encodeURIComponent(do_date_available ? "" + do_date_available.toISOString() : "") + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<DocumentDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDocument(body: CreateDocumentInput | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/CreateDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDocument(_response);
        });
    }

    protected processCreateDocument(response: AxiosResponse): Promise<DocumentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDto>(null as any);
    }

    /**
     * @param to_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    onImportDocument(to_id: number | undefined, body: ImportDocumentInput | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/onImportDocument?";
        if (to_id === null)
            throw new Error("The parameter 'to_id' cannot be null.");
        else if (to_id !== undefined)
            url_ += "to_id=" + encodeURIComponent("" + to_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnImportDocument(_response);
        });
    }

    protected processOnImportDocument(response: AxiosResponse): Promise<DocumentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    importDocuments(body: ImportDocumentInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Document/ImportDocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processImportDocuments(_response);
        });
    }

    protected processImportDocuments(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocument(body: UpdateDocumentInput | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/UpdateDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDocument(_response);
        });
    }

    protected processUpdateDocument(response: AxiosResponse): Promise<DocumentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDto>(null as any);
    }

    /**
     * @param do_id (optional) 
     * @return Success
     */
    delete(do_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/Delete?";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Document/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class DocumentInforService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param do_id (optional) 
     * @param do_title (optional) 
     * @param do_in_isbn (optional) 
     * @param dkcb_code (optional) 
     * @param do_in_status (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(do_id: number | undefined, do_title: string | undefined, do_in_isbn: string | undefined, dkcb_code: string | undefined, do_in_status: DocumentItemStatus | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentInforDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentInfor/GetAll?";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        if (do_title === null)
            throw new Error("The parameter 'do_title' cannot be null.");
        else if (do_title !== undefined)
            url_ += "do_title=" + encodeURIComponent("" + do_title) + "&";
        if (do_in_isbn === null)
            throw new Error("The parameter 'do_in_isbn' cannot be null.");
        else if (do_in_isbn !== undefined)
            url_ += "do_in_isbn=" + encodeURIComponent("" + do_in_isbn) + "&";
        if (dkcb_code === null)
            throw new Error("The parameter 'dkcb_code' cannot be null.");
        else if (dkcb_code !== undefined)
            url_ += "dkcb_code=" + encodeURIComponent("" + dkcb_code) + "&";
        if (do_in_status === null)
            throw new Error("The parameter 'do_in_status' cannot be null.");
        else if (do_in_status !== undefined)
            url_ += "do_in_status=" + encodeURIComponent("" + do_in_status) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<DocumentInforDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentInforDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentInforDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentInforDtoPagedResultDto>(null as any);
    }

    /**
     * @param do_in_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByIdArr(do_in_id: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentInforDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentInfor/GetAllByIdArr?";
        if (do_in_id === null)
            throw new Error("The parameter 'do_in_id' cannot be null.");
        else if (do_in_id !== undefined)
            do_in_id && do_in_id.forEach(item => { url_ += "do_in_id=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByIdArr(_response);
        });
    }

    protected processGetAllByIdArr(response: AxiosResponse): Promise<DocumentInforDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentInforDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentInforDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentInforDtoPagedResultDto>(null as any);
    }

    /**
     * @param do_in_isbn (optional) 
     * @return Success
     */
    getDocumentInforForISBN(do_in_isbn: string | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentInforDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentInfor/GetDocumentInforForISBN?";
        if (do_in_isbn === null)
            throw new Error("The parameter 'do_in_isbn' cannot be null.");
        else if (do_in_isbn !== undefined)
            url_ += "do_in_isbn=" + encodeURIComponent("" + do_in_isbn) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocumentInforForISBN(_response);
        });
    }

    protected processGetDocumentInforForISBN(response: AxiosResponse): Promise<DocumentInforDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentInforDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentInforDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentInforDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDocumentInfor(body: CreateDocumentInforInput | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentInforDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentInfor/CreateDocumentInfor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDocumentInfor(_response);
        });
    }

    protected processCreateDocumentInfor(response: AxiosResponse): Promise<DocumentInforDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentInforDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentInforDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentInforDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListDocumentInfor(body: CreateDocumentInforInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentInforDto[]> {
        let url_ = this.baseUrl + "/api/services/app/DocumentInfor/CreateListDocumentInfor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListDocumentInfor(_response);
        });
    }

    protected processCreateListDocumentInfor(response: AxiosResponse): Promise<DocumentInforDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentInforDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<DocumentInforDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentInforDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDocumentInfor(body: UpdateDocumentInforInput | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentInforDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentInfor/UpdateDocumentInfor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDocumentInfor(_response);
        });
    }

    protected processUpdateDocumentInfor(response: AxiosResponse): Promise<DocumentInforDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentInforDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentInforDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentInforDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeStatusDocumentInforCheck(body: ChangeStatusDocumentInforCheckInput | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentInforDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentInfor/ChangeStatusDocumentInforCheck";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatusDocumentInforCheck(_response);
        });
    }

    protected processChangeStatusDocumentInforCheck(response: AxiosResponse): Promise<DocumentInforDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentInforDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentInforDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentInforDto>(null as any);
    }

    /**
     * @param do_in_id (optional) 
     * @return Success
     */
    delete(do_in_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentInfor/Delete?";
        if (do_in_id === null)
            throw new Error("The parameter 'do_in_id' cannot be null.");
        else if (do_in_id !== undefined)
            url_ += "do_in_id=" + encodeURIComponent("" + do_in_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class DocumentLogService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param do_id (optional) 
     * @param do_lo_action (optional) 
     * @param us_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(do_id: number | undefined, do_lo_action: DocumentLogAction | undefined, us_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentLog/GetAll?";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        if (do_lo_action === null)
            throw new Error("The parameter 'do_lo_action' cannot be null.");
        else if (do_lo_action !== undefined)
            url_ += "do_lo_action=" + encodeURIComponent("" + do_lo_action) + "&";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<DocumentLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDocumentLog(body: CreateDocumentLogInput | undefined , cancelToken?: CancelToken | undefined): Promise<DocumentLogDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentLog/CreateDocumentLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateDocumentLog(_response);
        });
    }

    protected processCreateDocumentLog(response: AxiosResponse): Promise<DocumentLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentLogDto.fromJS(resultData200.result);
            return Promise.resolve<DocumentLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentLogDto>(null as any);
    }

    /**
     * @param do_lo_id (optional) 
     * @return Success
     */
    delete(do_lo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/DocumentLog/Delete?";
        if (do_lo_id === null)
            throw new Error("The parameter 'do_lo_id' cannot be null.");
        else if (do_lo_id !== undefined)
            url_ += "do_lo_id=" + encodeURIComponent("" + do_lo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class FieldsService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param fie_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fie_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FieldsDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Fields/GetAll?";
        if (fie_search === null)
            throw new Error("The parameter 'fie_search' cannot be null.");
        else if (fie_search !== undefined)
            url_ += "fie_search=" + encodeURIComponent("" + fie_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FieldsDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FieldsDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FieldsDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FieldsDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFields(body: CreateFieldsInput | undefined , cancelToken?: CancelToken | undefined): Promise<FieldsDto> {
        let url_ = this.baseUrl + "/api/services/app/Fields/CreateFields";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFields(_response);
        });
    }

    protected processCreateFields(response: AxiosResponse): Promise<FieldsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FieldsDto.fromJS(resultData200.result);
            return Promise.resolve<FieldsDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FieldsDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListField(body: CreateFieldsInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<FieldsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Fields/CreateListField";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListField(_response);
        });
    }

    protected processCreateListField(response: AxiosResponse): Promise<FieldsDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FieldsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<FieldsDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FieldsDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePosition(body: UpdatePositionFieldInput | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Fields/ChangePosition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePosition(_response);
        });
    }

    protected processChangePosition(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateFieldsInput | undefined , cancelToken?: CancelToken | undefined): Promise<FieldsDto> {
        let url_ = this.baseUrl + "/api/services/app/Fields/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<FieldsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FieldsDto.fromJS(resultData200.result);
            return Promise.resolve<FieldsDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FieldsDto>(null as any);
    }

    /**
     * @param fie_id (optional) 
     * @return Success
     */
    delete(fie_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Fields/Delete?";
        if (fie_id === null)
            throw new Error("The parameter 'fie_id' cannot be null.");
        else if (fie_id !== undefined)
            url_ += "fie_id=" + encodeURIComponent("" + fie_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Fields/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Fields/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class FileDocumentService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param fi_do_search (optional) 
     * @param do_title (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fi_do_search: string | undefined, do_title: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FileDocumentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FileDocument/GetAll?";
        if (fi_do_search === null)
            throw new Error("The parameter 'fi_do_search' cannot be null.");
        else if (fi_do_search !== undefined)
            url_ += "fi_do_search=" + encodeURIComponent("" + fi_do_search) + "&";
        if (do_title === null)
            throw new Error("The parameter 'do_title' cannot be null.");
        else if (do_title !== undefined)
            url_ += "do_title=" + encodeURIComponent("" + do_title) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FileDocumentDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDocumentDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FileDocumentDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDocumentDtoPagedResultDto>(null as any);
    }

    /**
     * @param do_id (optional) 
     * @param fi_do_desc (optional) 
     * @param isDownload (optional) 
     * @param filePayload (optional) 
     * @return Success
     */
    createFileDocument(do_id: number | undefined, fi_do_desc: string | undefined, isDownload: boolean | undefined, filePayload: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<FileDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/FileDocument/CreateFileDocument?";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        if (fi_do_desc === null)
            throw new Error("The parameter 'fi_do_desc' cannot be null.");
        else if (fi_do_desc !== undefined)
            url_ += "fi_do_desc=" + encodeURIComponent("" + fi_do_desc) + "&";
        if (isDownload === null)
            throw new Error("The parameter 'isDownload' cannot be null.");
        else if (isDownload !== undefined)
            url_ += "isDownload=" + encodeURIComponent("" + isDownload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filePayload === null || filePayload === undefined)
            throw new Error("The parameter 'filePayload' cannot be null.");
        else
            content_.append("filePayload", filePayload.data, filePayload.fileName ? filePayload.fileName : "filePayload");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFileDocument(_response);
        });
    }

    protected processCreateFileDocument(response: AxiosResponse): Promise<FileDocumentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDocumentDto.fromJS(resultData200.result);
            return Promise.resolve<FileDocumentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDocumentDto>(null as any);
    }

    /**
     * @param fi_do_id (optional) 
     * @param do_id (optional) 
     * @param fi_do_desc (optional) 
     * @param isDownload (optional) 
     * @param filePayload (optional) 
     * @return Success
     */
    updateFileDocument(fi_do_id: number | undefined, do_id: number | undefined, fi_do_desc: string | undefined, isDownload: boolean | undefined, filePayload: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<FileDocumentDto> {
        let url_ = this.baseUrl + "/api/services/app/FileDocument/UpdateFileDocument?";
        if (fi_do_id === null)
            throw new Error("The parameter 'fi_do_id' cannot be null.");
        else if (fi_do_id !== undefined)
            url_ += "fi_do_id=" + encodeURIComponent("" + fi_do_id) + "&";
        if (do_id === null)
            throw new Error("The parameter 'do_id' cannot be null.");
        else if (do_id !== undefined)
            url_ += "do_id=" + encodeURIComponent("" + do_id) + "&";
        if (fi_do_desc === null)
            throw new Error("The parameter 'fi_do_desc' cannot be null.");
        else if (fi_do_desc !== undefined)
            url_ += "fi_do_desc=" + encodeURIComponent("" + fi_do_desc) + "&";
        if (isDownload === null)
            throw new Error("The parameter 'isDownload' cannot be null.");
        else if (isDownload !== undefined)
            url_ += "isDownload=" + encodeURIComponent("" + isDownload) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filePayload === null || filePayload === undefined)
            throw new Error("The parameter 'filePayload' cannot be null.");
        else
            content_.append("filePayload", filePayload.data, filePayload.fileName ? filePayload.fileName : "filePayload");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFileDocument(_response);
        });
    }

    protected processUpdateFileDocument(response: AxiosResponse): Promise<FileDocumentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileDocumentDto.fromJS(resultData200.result);
            return Promise.resolve<FileDocumentDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileDocumentDto>(null as any);
    }

    /**
     * @param fi_do_id (optional) 
     * @return Success
     */
    delete(fi_do_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FileDocument/Delete?";
        if (fi_do_id === null)
            throw new Error("The parameter 'fi_do_id' cannot be null.");
        else if (fi_do_id !== undefined)
            url_ += "fi_do_id=" + encodeURIComponent("" + fi_do_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param fi_do_id (optional) 
     * @return Success
     */
    increaseView(fi_do_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FileDocument/IncreaseView?";
        if (fi_do_id === null)
            throw new Error("The parameter 'fi_do_id' cannot be null.");
        else if (fi_do_id !== undefined)
            url_ += "fi_do_id=" + encodeURIComponent("" + fi_do_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIncreaseView(_response);
        });
    }

    protected processIncreaseView(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param fi_do_id (optional) 
     * @return Success
     */
    saveFileDriver(fi_do_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/FileDocument/SaveFileDriver?";
        if (fi_do_id === null)
            throw new Error("The parameter 'fi_do_id' cannot be null.");
        else if (fi_do_id !== undefined)
            url_ += "fi_do_id=" + encodeURIComponent("" + fi_do_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSaveFileDriver(_response);
        });
    }

    protected processSaveFileDriver(response: AxiosResponse): Promise<FilesOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDto>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @param us_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    onCreateFilesOfUser(fo_id: number | undefined, us_id: number | undefined, body: FilesOfUser | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/FileDocument/onCreateFilesOfUser?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnCreateFilesOfUser(_response);
        });
    }

    protected processOnCreateFilesOfUser(response: AxiosResponse): Promise<FilesOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDto>(null as any);
    }
}

export class FileOrFolderLogService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param fi_fo_id (optional) 
     * @param fi_fo_is_file (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fi_fo_id: number | undefined, fi_fo_is_file: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FileOrFolderLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FileOrFolderLog/GetAll?";
        if (fi_fo_id === null)
            throw new Error("The parameter 'fi_fo_id' cannot be null.");
        else if (fi_fo_id !== undefined)
            url_ += "fi_fo_id=" + encodeURIComponent("" + fi_fo_id) + "&";
        if (fi_fo_is_file === null)
            throw new Error("The parameter 'fi_fo_is_file' cannot be null.");
        else if (fi_fo_is_file !== undefined)
            url_ += "fi_fo_is_file=" + encodeURIComponent("" + fi_fo_is_file) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FileOrFolderLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FileOrFolderLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FileOrFolderLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileOrFolderLogDtoPagedResultDto>(null as any);
    }
}

export class FilesService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param fi_name (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(fi_name: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FilesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Files/GetAll?";
        if (fi_name === null)
            throw new Error("The parameter 'fi_name' cannot be null.");
        else if (fi_name !== undefined)
            url_ += "fi_name=" + encodeURIComponent("" + fi_name) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FilesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FilesDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesDtoPagedResultDto>(null as any);
    }

    /**
     * @param fileType (optional) 
     * @param filePayload (optional) 
     * @return Success
     */
    createFiles(fileType: number | undefined, filePayload: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<FilesDto> {
        let url_ = this.baseUrl + "/api/services/app/Files/CreateFiles?";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filePayload === null || filePayload === undefined)
            throw new Error("The parameter 'filePayload' cannot be null.");
        else
            content_.append("filePayload", filePayload.data, filePayload.fileName ? filePayload.fileName : "filePayload");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFiles(_response);
        });
    }

    protected processCreateFiles(response: AxiosResponse): Promise<FilesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesDto.fromJS(resultData200.result);
            return Promise.resolve<FilesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesDto>(null as any);
    }

    /**
     * @param fileType (optional) 
     * @param inputList (optional) 
     * @return Success
     */
    createListFile(fileType: number | undefined, inputList: FileParameter[] | undefined , cancelToken?: CancelToken | undefined): Promise<FilesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Files/CreateListFile?";
        if (fileType === null)
            throw new Error("The parameter 'fileType' cannot be null.");
        else if (fileType !== undefined)
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (inputList === null || inputList === undefined)
            throw new Error("The parameter 'inputList' cannot be null.");
        else
            inputList.forEach(item_ => content_.append("inputList", item_.data, item_.fileName ? item_.fileName : "inputList") );

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListFile(_response);
        });
    }

    protected processCreateListFile(response: AxiosResponse): Promise<FilesDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FilesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<FilesDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesDto[]>(null as any);
    }

    /**
     * @param fi_id (optional) 
     * @return Success
     */
    delete(fi_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Files/Delete?";
        if (fi_id === null)
            throw new Error("The parameter 'fi_id' cannot be null.");
        else if (fi_id !== undefined)
            url_ += "fi_id=" + encodeURIComponent("" + fi_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class FilesOfUserService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param us_id (optional) 
     * @param fi_us_name (optional) 
     * @param fo_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(us_id: number | undefined, fi_us_name: string | undefined, fo_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/GetAll?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (fi_us_name === null)
            throw new Error("The parameter 'fi_us_name' cannot be null.");
        else if (fi_us_name !== undefined)
            url_ += "fi_us_name=" + encodeURIComponent("" + fi_us_name) + "&";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FilesOfUserDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDtoPagedResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllDataDriver(  cancelToken?: CancelToken | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/GetAllDataDriver";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllDataDriver(_response);
        });
    }

    protected processGetAllDataDriver(response: AxiosResponse): Promise<number> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<number>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @param filePayload (optional) 
     * @return Success
     */
    createFilesOfUser(fo_id: number | undefined, filePayload: FileParameter | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/CreateFilesOfUser?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (filePayload === null || filePayload === undefined)
            throw new Error("The parameter 'filePayload' cannot be null.");
        else
            content_.append("filePayload", filePayload.data, filePayload.fileName ? filePayload.fileName : "filePayload");

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFilesOfUser(_response);
        });
    }

    protected processCreateFilesOfUser(response: AxiosResponse): Promise<FilesOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param fi_us_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    onCreateFilesOfUserRoles(us_id: number | undefined, fi_us_id: number | undefined, body: FolderRoles | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/onCreateFilesOfUserRoles?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (fi_us_id === null)
            throw new Error("The parameter 'fi_us_id' cannot be null.");
        else if (fi_us_id !== undefined)
            url_ += "fi_us_id=" + encodeURIComponent("" + fi_us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnCreateFilesOfUserRoles(_response);
        });
    }

    protected processOnCreateFilesOfUserRoles(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @param us_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    onCreateFilesOfUser(fo_id: number | undefined, us_id: number | undefined, body: FilesOfUser | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/onCreateFilesOfUser?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnCreateFilesOfUser(_response);
        });
    }

    protected processOnCreateFilesOfUser(response: AxiosResponse): Promise<FilesOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFilesOfUser(body: UpdateFilesOfUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/UpdateFilesOfUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFilesOfUser(_response);
        });
    }

    protected processUpdateFilesOfUser(response: AxiosResponse): Promise<FilesOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDto>(null as any);
    }

    /**
     * @param fi_us_id (optional) 
     * @return Success
     */
    markerFile(fi_us_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/MarkerFile?";
        if (fi_us_id === null)
            throw new Error("The parameter 'fi_us_id' cannot be null.");
        else if (fi_us_id !== undefined)
            url_ += "fi_us_id=" + encodeURIComponent("" + fi_us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkerFile(_response);
        });
    }

    protected processMarkerFile(response: AxiosResponse): Promise<FilesOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeTypeFileOfUser(body: ChangeTypeFileOfUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/ChangeTypeFileOfUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeTypeFileOfUser(_response);
        });
    }

    protected processChangeTypeFileOfUser(response: AxiosResponse): Promise<FilesOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeParentFileOfUser(body: ChangeParentFileOfUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/ChangeParentFileOfUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeParentFileOfUser(_response);
        });
    }

    protected processChangeParentFileOfUser(response: AxiosResponse): Promise<FilesOfUserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserDto>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @return Success
     */
    checkFolder(fo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/CheckFolder?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckFolder(_response);
        });
    }

    protected processCheckFolder(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param fi_us_id (optional) 
     * @return Success
     */
    delete(fi_us_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUser/Delete?";
        if (fi_us_id === null)
            throw new Error("The parameter 'fi_us_id' cannot be null.");
        else if (fi_us_id !== undefined)
            url_ += "fi_us_id=" + encodeURIComponent("" + fi_us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class FilesOfUserRolesService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param us_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(us_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserRolesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUserRoles/GetAll?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FilesOfUserRolesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserRolesDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserRolesDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserRolesDtoPagedResultDto>(null as any);
    }

    /**
     * @param fi_us_id (optional) 
     * @return Success
     */
    getAllUserRolesById(fi_us_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserRolesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUserRoles/GetAllUserRolesById?";
        if (fi_us_id === null)
            throw new Error("The parameter 'fi_us_id' cannot be null.");
        else if (fi_us_id !== undefined)
            url_ += "fi_us_id=" + encodeURIComponent("" + fi_us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllUserRolesById(_response);
        });
    }

    protected processGetAllUserRolesById(response: AxiosResponse): Promise<FilesOfUserRolesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserRolesDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserRolesDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserRolesDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFilesOfUserRoles(body: CreateFilesOfUserRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUserRoles/CreateFilesOfUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFilesOfUserRoles(_response);
        });
    }

    protected processCreateFilesOfUserRoles(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFilesOfUserRoles(body: UpdateFilesOfUserRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUserRoles/UpdateFilesOfUserRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFilesOfUserRoles(_response);
        });
    }

    protected processUpdateFilesOfUserRoles(response: AxiosResponse): Promise<FilesOfUserRolesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserRolesDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserRolesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserRolesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFilesOfUserWithRoles(body: UpdateFilesOfUserWithRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUserRoles/UpdateFilesOfUserWithRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFilesOfUserWithRoles(_response);
        });
    }

    protected processUpdateFilesOfUserWithRoles(response: AxiosResponse): Promise<FilesOfUserRolesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserRolesDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserRolesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserRolesDto>(null as any);
    }

    /**
     * @param fi_ro_id (optional) 
     * @return Success
     */
    markerFileRoles(fi_ro_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FilesOfUserRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUserRoles/MarkerFileRoles?";
        if (fi_ro_id === null)
            throw new Error("The parameter 'fi_ro_id' cannot be null.");
        else if (fi_ro_id !== undefined)
            url_ += "fi_ro_id=" + encodeURIComponent("" + fi_ro_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkerFileRoles(_response);
        });
    }

    protected processMarkerFileRoles(response: AxiosResponse): Promise<FilesOfUserRolesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FilesOfUserRolesDto.fromJS(resultData200.result);
            return Promise.resolve<FilesOfUserRolesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FilesOfUserRolesDto>(null as any);
    }

    /**
     * @param fi_ro_id (optional) 
     * @return Success
     */
    delete(fi_ro_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FilesOfUserRoles/Delete?";
        if (fi_ro_id === null)
            throw new Error("The parameter 'fi_ro_id' cannot be null.");
        else if (fi_ro_id !== undefined)
            url_ += "fi_ro_id=" + encodeURIComponent("" + fi_ro_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class FolderService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getAllFolder(  cancelToken?: CancelToken | undefined): Promise<FolderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/GetAllFolder";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllFolder(_response);
        });
    }

    protected processGetAllFolder(response: AxiosResponse): Promise<FolderDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDtoPagedResultDto>(null as any);
    }

    /**
     * @param name (optional) 
     * @param type (optional) 
     * @param marker (optional) 
     * @param us_id_owner (optional) 
     * @param link (optional) 
     * @param last_updated_at_from (optional) 
     * @param last_updated_at_to (optional) 
     * @return Success
     */
    getAll(name: string | undefined, type: TypeFileFolder | undefined, marker: boolean | undefined, us_id_owner: number | undefined, link: string | undefined, last_updated_at_from: Date | undefined, last_updated_at_to: Date | undefined , cancelToken?: CancelToken | undefined): Promise<ResourceDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/GetAll?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (marker === null)
            throw new Error("The parameter 'marker' cannot be null.");
        else if (marker !== undefined)
            url_ += "marker=" + encodeURIComponent("" + marker) + "&";
        if (us_id_owner === null)
            throw new Error("The parameter 'us_id_owner' cannot be null.");
        else if (us_id_owner !== undefined)
            url_ += "us_id_owner=" + encodeURIComponent("" + us_id_owner) + "&";
        if (link === null)
            throw new Error("The parameter 'link' cannot be null.");
        else if (link !== undefined)
            url_ += "link=" + encodeURIComponent("" + link) + "&";
        if (last_updated_at_from === null)
            throw new Error("The parameter 'last_updated_at_from' cannot be null.");
        else if (last_updated_at_from !== undefined)
            url_ += "last_updated_at_from=" + encodeURIComponent(last_updated_at_from ? "" + last_updated_at_from.toISOString() : "") + "&";
        if (last_updated_at_to === null)
            throw new Error("The parameter 'last_updated_at_to' cannot be null.");
        else if (last_updated_at_to !== undefined)
            url_ += "last_updated_at_to=" + encodeURIComponent(last_updated_at_to ? "" + last_updated_at_to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ResourceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResourceDto.fromJS(resultData200.result);
            return Promise.resolve<ResourceDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResourceDto>(null as any);
    }

    /**
     * @param link (optional) 
     * @return Success
     */
    getParentBreadcrumb(link: string | undefined , cancelToken?: CancelToken | undefined): Promise<FolderDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/GetParentBreadcrumb?";
        if (link === null)
            throw new Error("The parameter 'link' cannot be null.");
        else if (link !== undefined)
            url_ += "link=" + encodeURIComponent("" + link) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetParentBreadcrumb(_response);
        });
    }

    protected processGetParentBreadcrumb(response: AxiosResponse): Promise<FolderDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDtoPagedResultDto>(null as any);
    }

    /**
     * @param link (optional) 
     * @return Success
     */
    getResoundByLink(link: string | undefined , cancelToken?: CancelToken | undefined): Promise<ResourceDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/GetResoundByLink?";
        if (link === null)
            throw new Error("The parameter 'link' cannot be null.");
        else if (link !== undefined)
            url_ += "link=" + encodeURIComponent("" + link) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetResoundByLink(_response);
        });
    }

    protected processGetResoundByLink(response: AxiosResponse): Promise<ResourceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResourceDto.fromJS(resultData200.result);
            return Promise.resolve<ResourceDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResourceDto>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @return Success
     */
    getFolderById(fo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FolderDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/GetFolderById?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetFolderById(_response);
        });
    }

    protected processGetFolderById(response: AxiosResponse): Promise<FolderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFolder(body: CreateFolderInput | undefined , cancelToken?: CancelToken | undefined): Promise<FolderDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/CreateFolder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFolder(_response);
        });
    }

    protected processCreateFolder(response: AxiosResponse): Promise<FolderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    onCreateFolder(us_id: number | undefined, body: CreateFolderInput | undefined , cancelToken?: CancelToken | undefined): Promise<FolderDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/onCreateFolder?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnCreateFolder(_response);
        });
    }

    protected processOnCreateFolder(response: AxiosResponse): Promise<FolderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param fo_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    onCreateFolderRoles(us_id: number | undefined, fo_id: number | undefined, body: FolderRoles | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Folder/onCreateFolderRoles?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnCreateFolderRoles(_response);
        });
    }

    protected processOnCreateFolderRoles(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFolder(body: UpdateFolderInput | undefined , cancelToken?: CancelToken | undefined): Promise<FolderDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/UpdateFolder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFolder(_response);
        });
    }

    protected processUpdateFolder(response: AxiosResponse): Promise<FolderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDto>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @return Success
     */
    markerFolder(fo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FolderDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/MarkerFolder?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkerFolder(_response);
        });
    }

    protected processMarkerFolder(response: AxiosResponse): Promise<FolderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeTypeFolder(body: ChangeTypeFolderInput | undefined , cancelToken?: CancelToken | undefined): Promise<FolderDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/ChangeTypeFolder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeTypeFolder(_response);
        });
    }

    protected processChangeTypeFolder(response: AxiosResponse): Promise<FolderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeParentFolder(body: ChangeParentFolderInput | undefined , cancelToken?: CancelToken | undefined): Promise<FolderDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/ChangeParentFolder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeParentFolder(_response);
        });
    }

    protected processChangeParentFolder(response: AxiosResponse): Promise<FolderDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderDto.fromJS(resultData200.result);
            return Promise.resolve<FolderDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderDto>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @return Success
     */
    checkFolder(fo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Folder/CheckFolder?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckFolder(_response);
        });
    }

    protected processCheckFolder(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @return Success
     */
    delete(fo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/Delete?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @return Success
     */
    onDeleteFolderRoles(fo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/onDeleteFolderRoles?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnDeleteFolderRoles(_response);
        });
    }

    protected processOnDeleteFolderRoles(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param fi_us_id (optional) 
     * @return Success
     */
    onDeleteFileRoles(fi_us_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Folder/onDeleteFileRoles?";
        if (fi_us_id === null)
            throw new Error("The parameter 'fi_us_id' cannot be null.");
        else if (fi_us_id !== undefined)
            url_ += "fi_us_id=" + encodeURIComponent("" + fi_us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnDeleteFileRoles(_response);
        });
    }

    protected processOnDeleteFileRoles(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class FolderRolesService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param us_id (optional) 
     * @param fo_id (optional) 
     * @param marker (optional) 
     * @param fo_ro_role (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(us_id: number | undefined, fo_id: number | undefined, marker: boolean | undefined, fo_ro_role: ResourceRoleStatus | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<FolderRolesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/GetAll?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        if (marker === null)
            throw new Error("The parameter 'marker' cannot be null.");
        else if (marker !== undefined)
            url_ += "marker=" + encodeURIComponent("" + marker) + "&";
        if (fo_ro_role === null)
            throw new Error("The parameter 'fo_ro_role' cannot be null.");
        else if (fo_ro_role !== undefined)
            url_ += "fo_ro_role=" + encodeURIComponent("" + fo_ro_role) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<FolderRolesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderRolesDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FolderRolesDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderRolesDtoPagedResultDto>(null as any);
    }

    /**
     * @param link (optional) 
     * @return Success
     */
    getAllParentBreadcrumb(link: string | undefined , cancelToken?: CancelToken | undefined): Promise<FolderRolesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/GetAllParentBreadcrumb?";
        if (link === null)
            throw new Error("The parameter 'link' cannot be null.");
        else if (link !== undefined)
            url_ += "link=" + encodeURIComponent("" + link) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllParentBreadcrumb(_response);
        });
    }

    protected processGetAllParentBreadcrumb(response: AxiosResponse): Promise<FolderRolesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderRolesDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FolderRolesDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderRolesDtoPagedResultDto>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param parentId (optional) 
     * @param body (optional) 
     * @return Success
     */
    onGetParentBreadcrumb(us_id: number | undefined, parentId: number | undefined, body: FolderRolesDto[] | undefined , cancelToken?: CancelToken | undefined): Promise<FolderRolesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/onGetParentBreadcrumb?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        if (parentId === null)
            throw new Error("The parameter 'parentId' cannot be null.");
        else if (parentId !== undefined)
            url_ += "parentId=" + encodeURIComponent("" + parentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnGetParentBreadcrumb(_response);
        });
    }

    protected processOnGetParentBreadcrumb(response: AxiosResponse): Promise<FolderRolesDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FolderRolesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<FolderRolesDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderRolesDto[]>(null as any);
    }

    /**
     * @param link (optional) 
     * @param marker (optional) 
     * @return Success
     */
    getResoundRolesByLink(link: string | undefined, marker: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<ResourceRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/GetResoundRolesByLink?";
        if (link === null)
            throw new Error("The parameter 'link' cannot be null.");
        else if (link !== undefined)
            url_ += "link=" + encodeURIComponent("" + link) + "&";
        if (marker === null)
            throw new Error("The parameter 'marker' cannot be null.");
        else if (marker !== undefined)
            url_ += "marker=" + encodeURIComponent("" + marker) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetResoundRolesByLink(_response);
        });
    }

    protected processGetResoundRolesByLink(response: AxiosResponse): Promise<ResourceRolesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResourceRolesDto.fromJS(resultData200.result);
            return Promise.resolve<ResourceRolesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResourceRolesDto>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @return Success
     */
    getAllUserRolesById(fo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FolderRolesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/GetAllUserRolesById?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllUserRolesById(_response);
        });
    }

    protected processGetAllUserRolesById(response: AxiosResponse): Promise<FolderRolesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderRolesDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<FolderRolesDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderRolesDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListFolderRoles(body: CreateFolderRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/CreateListFolderRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListFolderRoles(_response);
        });
    }

    protected processCreateListFolderRoles(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param fo_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    createFilesRoles(fo_id: number | undefined, body: CreateFilesOfUserRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/CreateFilesRoles?";
        if (fo_id === null)
            throw new Error("The parameter 'fo_id' cannot be null.");
        else if (fo_id !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFilesRoles(_response);
        });
    }

    protected processCreateFilesRoles(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param us_idQuery (optional) 
     * @param fo_idQuery (optional) 
     * @param fo_ro_role (optional) 
     * @return Success
     */
    getChildByFoID(us_idQuery: number[] | undefined, fo_idQuery: number | undefined, fo_ro_role: ResourceRoleStatus | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/GetChildByFoID?";
        if (us_idQuery === null)
            throw new Error("The parameter 'us_idQuery' cannot be null.");
        else if (us_idQuery !== undefined)
            us_idQuery && us_idQuery.forEach(item => { url_ += "us_id=" + encodeURIComponent("" + item) + "&"; });
        if (fo_idQuery === null)
            throw new Error("The parameter 'fo_idQuery' cannot be null.");
        else if (fo_idQuery !== undefined)
            url_ += "fo_id=" + encodeURIComponent("" + fo_idQuery) + "&";
        if (fo_ro_role === null)
            throw new Error("The parameter 'fo_ro_role' cannot be null.");
        else if (fo_ro_role !== undefined)
            url_ += "fo_ro_role=" + encodeURIComponent("" + fo_ro_role) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetChildByFoID(_response);
        });
    }

    protected processGetChildByFoID(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param fo_id_parent (optional) 
     * @param body (optional) 
     * @return Success
     */
    createFolderRoles(fo_id_parent: number | undefined, body: CreateFolderRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/CreateFolderRoles?";
        if (fo_id_parent === null)
            throw new Error("The parameter 'fo_id_parent' cannot be null.");
        else if (fo_id_parent !== undefined)
            url_ += "fo_id_parent=" + encodeURIComponent("" + fo_id_parent) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateFolderRoles(_response);
        });
    }

    protected processCreateFolderRoles(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFolderRoles(body: UpdateFolderRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<FolderRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/UpdateFolderRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFolderRoles(_response);
        });
    }

    protected processUpdateFolderRoles(response: AxiosResponse): Promise<FolderRolesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderRolesDto.fromJS(resultData200.result);
            return Promise.resolve<FolderRolesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderRolesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateFolderWithRoles(body: UpdateFolderWithRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<FolderRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/UpdateFolderWithRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateFolderWithRoles(_response);
        });
    }

    protected processUpdateFolderWithRoles(response: AxiosResponse): Promise<FolderRolesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderRolesDto.fromJS(resultData200.result);
            return Promise.resolve<FolderRolesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderRolesDto>(null as any);
    }

    /**
     * @param fo_ro_id (optional) 
     * @return Success
     */
    markerFolderRoles(fo_ro_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<FolderRolesDto> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/MarkerFolderRoles?";
        if (fo_ro_id === null)
            throw new Error("The parameter 'fo_ro_id' cannot be null.");
        else if (fo_ro_id !== undefined)
            url_ += "fo_ro_id=" + encodeURIComponent("" + fo_ro_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMarkerFolderRoles(_response);
        });
    }

    protected processMarkerFolderRoles(response: AxiosResponse): Promise<FolderRolesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FolderRolesDto.fromJS(resultData200.result);
            return Promise.resolve<FolderRolesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FolderRolesDto>(null as any);
    }

    /**
     * @param fo_ro_id (optional) 
     * @return Success
     */
    delete(fo_ro_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/FolderRoles/Delete?";
        if (fo_ro_id === null)
            throw new Error("The parameter 'fo_ro_id' cannot be null.");
        else if (fo_ro_id !== undefined)
            url_ += "fo_ro_id=" + encodeURIComponent("" + fo_ro_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class GDictionariesService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param dic_search (optional) 
     * @param dic_ty_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(dic_search: string | undefined, dic_ty_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<DictionariesDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GDictionaries/GetAll?";
        if (dic_search === null)
            throw new Error("The parameter 'dic_search' cannot be null.");
        else if (dic_search !== undefined)
            url_ += "dic_search=" + encodeURIComponent("" + dic_search) + "&";
        if (dic_ty_id === null)
            throw new Error("The parameter 'dic_ty_id' cannot be null.");
        else if (dic_ty_id !== undefined)
            url_ += "dic_ty_id=" + encodeURIComponent("" + dic_ty_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<DictionariesDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DictionariesDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<DictionariesDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DictionariesDtoPagedResultDto>(null as any);
    }
}

export class GDocumentService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param do_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getDocuments(do_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GDocumentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GDocument/GetDocuments?";
        if (do_search === null)
            throw new Error("The parameter 'do_search' cannot be null.");
        else if (do_search !== undefined)
            url_ += "do_search=" + encodeURIComponent("" + do_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDocuments(_response);
        });
    }

    protected processGetDocuments(response: AxiosResponse): Promise<GDocumentDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GDocumentDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GDocumentDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GDocumentDtoPagedResultDto>(null as any);
    }

    /**
     * @param do_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getByView(do_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GDocumentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GDocument/GetByView?";
        if (do_search === null)
            throw new Error("The parameter 'do_search' cannot be null.");
        else if (do_search !== undefined)
            url_ += "do_search=" + encodeURIComponent("" + do_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByView(_response);
        });
    }

    protected processGetByView(response: AxiosResponse): Promise<GDocumentDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GDocumentDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GDocumentDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GDocumentDtoPagedResultDto>(null as any);
    }

    /**
     * @param do_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getByBorrow(do_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GDocumentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GDocument/GetByBorrow?";
        if (do_search === null)
            throw new Error("The parameter 'do_search' cannot be null.");
        else if (do_search !== undefined)
            url_ += "do_search=" + encodeURIComponent("" + do_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByBorrow(_response);
        });
    }

    protected processGetByBorrow(response: AxiosResponse): Promise<GDocumentDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GDocumentDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GDocumentDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GDocumentDtoPagedResultDto>(null as any);
    }

    /**
     * @param do_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getNewest(do_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GDocumentDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/GDocument/GetNewest?";
        if (do_search === null)
            throw new Error("The parameter 'do_search' cannot be null.");
        else if (do_search !== undefined)
            url_ += "do_search=" + encodeURIComponent("" + do_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetNewest(_response);
        });
    }

    protected processGetNewest(response: AxiosResponse): Promise<GDocumentDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GDocumentDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GDocumentDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GDocumentDtoPagedResultDto>(null as any);
    }
}

export class HostSettingsService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getAllSettings(  cancelToken?: CancelToken | undefined): Promise<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSettings(_response);
        });
    }

    protected processGetAllSettings(response: AxiosResponse): Promise<HostSettingsEditDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = HostSettingsEditDto.fromJS(resultData200.result);
            return Promise.resolve<HostSettingsEditDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<HostSettingsEditDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAllSettings(_response);
        });
    }

    protected processUpdateAllSettings(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendTestEmail(_response);
        });
    }

    protected processSendTestEmail(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailMember(body: SendEmailMemberInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendEmailMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSendEmailMember(_response);
        });
    }

    protected processSendEmailMember(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(  cancelToken?: CancelToken | undefined): Promise<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetEnabledSocialLoginSettings(_response);
        });
    }

    protected processGetEnabledSocialLoginSettings(response: AxiosResponse): Promise<ExternalLoginSettingsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalLoginSettingsDto.fromJS(resultData200.result);
            return Promise.resolve<ExternalLoginSettingsDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalLoginSettingsDto>(null as any);
    }
}

export class LanguagesService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param la_title (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(la_title: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<LanguagesDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Languages/GetAll?";
        if (la_title === null)
            throw new Error("The parameter 'la_title' cannot be null.");
        else if (la_title !== undefined)
            url_ += "la_title=" + encodeURIComponent("" + la_title) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<LanguagesDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguagesDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<LanguagesDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguagesDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateLanguagesInput | undefined , cancelToken?: CancelToken | undefined): Promise<LanguagesDto> {
        let url_ = this.baseUrl + "/api/services/app/Languages/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<LanguagesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguagesDto.fromJS(resultData200.result);
            return Promise.resolve<LanguagesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguagesDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListLanguages(body: CreateLanguagesInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<LanguagesDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Languages/CreateListLanguages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListLanguages(_response);
        });
    }

    protected processCreateListLanguages(response: AxiosResponse): Promise<LanguagesDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LanguagesDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<LanguagesDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguagesDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateLanguagesInput | undefined , cancelToken?: CancelToken | undefined): Promise<LanguagesDto> {
        let url_ = this.baseUrl + "/api/services/app/Languages/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<LanguagesDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LanguagesDto.fromJS(resultData200.result);
            return Promise.resolve<LanguagesDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LanguagesDto>(null as any);
    }

    /**
     * @param la_id (optional) 
     * @return Success
     */
    delete(la_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Languages/Delete?";
        if (la_id === null)
            throw new Error("The parameter 'la_id' cannot be null.");
        else if (la_id !== undefined)
            url_ += "la_id=" + encodeURIComponent("" + la_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Languages/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Languages/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class Marc21Service {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param mar_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(mar_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<Marc21DtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Marc21/GetAll?";
        if (mar_search === null)
            throw new Error("The parameter 'mar_search' cannot be null.");
        else if (mar_search !== undefined)
            url_ += "mar_search=" + encodeURIComponent("" + mar_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<Marc21DtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Marc21DtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<Marc21DtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Marc21DtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMarc21(body: CreateMarc21Input | undefined , cancelToken?: CancelToken | undefined): Promise<Marc21Dto> {
        let url_ = this.baseUrl + "/api/services/app/Marc21/CreateMarc21";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMarc21(_response);
        });
    }

    protected processCreateMarc21(response: AxiosResponse): Promise<Marc21Dto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Marc21Dto.fromJS(resultData200.result);
            return Promise.resolve<Marc21Dto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Marc21Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListMarc21(body: CreateMarc21Input[] | undefined , cancelToken?: CancelToken | undefined): Promise<Marc21Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/Marc21/CreateListMarc21";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListMarc21(_response);
        });
    }

    protected processCreateListMarc21(response: AxiosResponse): Promise<Marc21Dto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Marc21Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<Marc21Dto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Marc21Dto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMarc21(body: UpdateMarc21Input | undefined , cancelToken?: CancelToken | undefined): Promise<Marc21Dto> {
        let url_ = this.baseUrl + "/api/services/app/Marc21/UpdateMarc21";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMarc21(_response);
        });
    }

    protected processUpdateMarc21(response: AxiosResponse): Promise<Marc21Dto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Marc21Dto.fromJS(resultData200.result);
            return Promise.resolve<Marc21Dto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Marc21Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePosition(body: UpdatePositionMarc21Input | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Marc21/ChangePosition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePosition(_response);
        });
    }

    protected processChangePosition(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Marc21/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Marc21/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Marc21/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class MemberService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param me_search (optional) 
     * @param me_status (optional) 
     * @param fieldSort (optional) 
     * @param sort (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(me_search: string | undefined, me_status: MemberRegisterStatus | undefined, fieldSort: string | undefined, sort: SORT | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MemberDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetAll?";
        if (me_search === null)
            throw new Error("The parameter 'me_search' cannot be null.");
        else if (me_search !== undefined)
            url_ += "me_search=" + encodeURIComponent("" + me_search) + "&";
        if (me_status === null)
            throw new Error("The parameter 'me_status' cannot be null.");
        else if (me_status !== undefined)
            url_ += "me_status=" + encodeURIComponent("" + me_status) + "&";
        if (fieldSort === null)
            throw new Error("The parameter 'fieldSort' cannot be null.");
        else if (fieldSort !== undefined)
            url_ += "fieldSort=" + encodeURIComponent("" + fieldSort) + "&";
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            url_ += "sort=" + encodeURIComponent("" + sort) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MemberDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MemberDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberDtoPagedResultDto>(null as any);
    }

    /**
     * @param me_id_arr (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByIdArr(me_id_arr: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MemberDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetAllByIdArr?";
        if (me_id_arr === null)
            throw new Error("The parameter 'me_id_arr' cannot be null.");
        else if (me_id_arr !== undefined)
            me_id_arr && me_id_arr.forEach(item => { url_ += "me_id_arr=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByIdArr(_response);
        });
    }

    protected processGetAllByIdArr(response: AxiosResponse): Promise<MemberDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MemberDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMember(body: CreateMemberInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/CreateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMember(_response);
        });
    }

    protected processCreateMember(response: AxiosResponse): Promise<MemberDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberDto.fromJS(resultData200.result);
            return Promise.resolve<MemberDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListMembers(body: CreateMemberInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<MemberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Member/CreateListMembers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListMembers(_response);
        });
    }

    protected processCreateListMembers(response: AxiosResponse): Promise<MemberDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(MemberDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<MemberDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onCreateUser(body: MemberDto | undefined , cancelToken?: CancelToken | undefined): Promise<User> {
        let url_ = this.baseUrl + "/api/services/app/Member/onCreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnCreateUser(_response);
        });
    }

    protected processOnCreateUser(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200.result);
            return Promise.resolve<User>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMember(body: UpdateMemberInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/UpdateMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMember(_response);
        });
    }

    protected processUpdateMember(response: AxiosResponse): Promise<MemberDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberDto.fromJS(resultData200.result);
            return Promise.resolve<MemberDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassWordMember(body: ChangePassWordMemberInput | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/ChangePassWordMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassWordMember(_response);
        });
    }

    protected processChangePassWordMember(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param me_id (optional) 
     * @return Success
     */
    delete(me_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/Delete?";
        if (me_id === null)
            throw new Error("The parameter 'me_id' cannot be null.");
        else if (me_id !== undefined)
            url_ += "me_id=" + encodeURIComponent("" + me_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeStatusMember(body: ChangeStatusMemberInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/ChangeStatusMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeStatusMember(_response);
        });
    }

    protected processChangeStatusMember(response: AxiosResponse): Promise<MemberDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberDto.fromJS(resultData200.result);
            return Promise.resolve<MemberDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberDto>(null as any);
    }

    /**
     * @param me_id (optional) 
     * @return Success
     */
    lockMember(me_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<MemberDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/LockMember?";
        if (me_id === null)
            throw new Error("The parameter 'me_id' cannot be null.");
        else if (me_id !== undefined)
            url_ += "me_id=" + encodeURIComponent("" + me_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLockMember(_response);
        });
    }

    protected processLockMember(response: AxiosResponse): Promise<MemberDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberDto.fromJS(resultData200.result);
            return Promise.resolve<MemberDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberDto>(null as any);
    }

    /**
     * @param me_id (optional) 
     * @param isLock (optional) 
     * @return Success
     */
    onLockCard(me_id: number | undefined, isLock: boolean | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Member/onLockCard?";
        if (me_id === null)
            throw new Error("The parameter 'me_id' cannot be null.");
        else if (me_id !== undefined)
            url_ += "me_id=" + encodeURIComponent("" + me_id) + "&";
        if (isLock === null)
            throw new Error("The parameter 'isLock' cannot be null.");
        else if (isLock !== undefined)
            url_ += "isLock=" + encodeURIComponent("" + isLock) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnLockCard(_response);
        });
    }

    protected processOnLockCard(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class MemberCardService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param me_id (optional) 
     * @param me_ca_number (optional) 
     * @param me_ca_code (optional) 
     * @param me_ca_status (optional) 
     * @param me_ca_use_from (optional) 
     * @param me_ca_use_to (optional) 
     * @param me_ca_type (optional) 
     * @param me_ca_is_locked (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(me_id: number | undefined, me_ca_number: string | undefined, me_ca_code: string | undefined, me_ca_status: MCardStatus | undefined, me_ca_use_from: Date | undefined, me_ca_use_to: Date | undefined, me_ca_type: MCardType | undefined, me_ca_is_locked: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/GetAll?";
        if (me_id === null)
            throw new Error("The parameter 'me_id' cannot be null.");
        else if (me_id !== undefined)
            url_ += "me_id=" + encodeURIComponent("" + me_id) + "&";
        if (me_ca_number === null)
            throw new Error("The parameter 'me_ca_number' cannot be null.");
        else if (me_ca_number !== undefined)
            url_ += "me_ca_number=" + encodeURIComponent("" + me_ca_number) + "&";
        if (me_ca_code === null)
            throw new Error("The parameter 'me_ca_code' cannot be null.");
        else if (me_ca_code !== undefined)
            url_ += "me_ca_code=" + encodeURIComponent("" + me_ca_code) + "&";
        if (me_ca_status === null)
            throw new Error("The parameter 'me_ca_status' cannot be null.");
        else if (me_ca_status !== undefined)
            url_ += "me_ca_status=" + encodeURIComponent("" + me_ca_status) + "&";
        if (me_ca_use_from === null)
            throw new Error("The parameter 'me_ca_use_from' cannot be null.");
        else if (me_ca_use_from !== undefined)
            url_ += "me_ca_use_from=" + encodeURIComponent(me_ca_use_from ? "" + me_ca_use_from.toISOString() : "") + "&";
        if (me_ca_use_to === null)
            throw new Error("The parameter 'me_ca_use_to' cannot be null.");
        else if (me_ca_use_to !== undefined)
            url_ += "me_ca_use_to=" + encodeURIComponent(me_ca_use_to ? "" + me_ca_use_to.toISOString() : "") + "&";
        if (me_ca_type === null)
            throw new Error("The parameter 'me_ca_type' cannot be null.");
        else if (me_ca_type !== undefined)
            url_ += "me_ca_type=" + encodeURIComponent("" + me_ca_type) + "&";
        if (me_ca_is_locked === null)
            throw new Error("The parameter 'me_ca_is_locked' cannot be null.");
        else if (me_ca_is_locked !== undefined)
            url_ += "me_ca_is_locked=" + encodeURIComponent("" + me_ca_is_locked) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MemberCardDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDtoPagedResultDto>(null as any);
    }

    /**
     * @param me_ca_id_arr (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByIdArr(me_ca_id_arr: number[] | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/GetAllByIdArr?";
        if (me_ca_id_arr === null)
            throw new Error("The parameter 'me_ca_id_arr' cannot be null.");
        else if (me_ca_id_arr !== undefined)
            me_ca_id_arr && me_ca_id_arr.forEach(item => { url_ += "me_ca_id_arr=" + encodeURIComponent("" + item) + "&"; });
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllByIdArr(_response);
        });
    }

    protected processGetAllByIdArr(response: AxiosResponse): Promise<MemberCardDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMemberCard(body: CreateMemberCardInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/CreateMemberCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMemberCard(_response);
        });
    }

    protected processCreateMemberCard(response: AxiosResponse): Promise<MemberCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDto>(null as any);
    }

    /**
     * @param me_ca_id (optional) 
     * @return Success
     */
    delete(me_ca_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/Delete?";
        if (me_ca_id === null)
            throw new Error("The parameter 'me_ca_id' cannot be null.");
        else if (me_ca_id !== undefined)
            url_ += "me_ca_id=" + encodeURIComponent("" + me_ca_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param me_ca_id (optional) 
     * @return Success
     */
    lockCard(me_ca_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/LockCard?";
        if (me_ca_id === null)
            throw new Error("The parameter 'me_ca_id' cannot be null.");
        else if (me_ca_id !== undefined)
            url_ += "me_ca_id=" + encodeURIComponent("" + me_ca_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLockCard(_response);
        });
    }

    protected processLockCard(response: AxiosResponse): Promise<MemberCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    approveMemberCard(body: ApproveMemberCardInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/ApproveMemberCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processApproveMemberCard(_response);
        });
    }

    protected processApproveMemberCard(response: AxiosResponse): Promise<MemberCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extendTimeCard(body: ExtendTimeMemberCardInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/ExtendTimeCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExtendTimeCard(_response);
        });
    }

    protected processExtendTimeCard(response: AxiosResponse): Promise<MemberCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rechargeCard(body: RechargeCardInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/RechargeCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRechargeCard(_response);
        });
    }

    protected processRechargeCard(response: AxiosResponse): Promise<MemberCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeMoneyCard(body: RechargeCardInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberCard/ChangeMoneyCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeMoneyCard(_response);
        });
    }

    protected processChangeMoneyCard(response: AxiosResponse): Promise<MemberCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDto>(null as any);
    }
}

export class MemberLogService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param me_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(me_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<MemberLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberLog/GetAll?";
        if (me_id === null)
            throw new Error("The parameter 'me_id' cannot be null.");
        else if (me_id !== undefined)
            url_ += "me_id=" + encodeURIComponent("" + me_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<MemberLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<MemberLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMemberLog(body: CreateMemberLogInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberLogDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberLog/CreateMemberLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMemberLog(_response);
        });
    }

    protected processCreateMemberLog(response: AxiosResponse): Promise<MemberLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberLogDto.fromJS(resultData200.result);
            return Promise.resolve<MemberLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberLogDto>(null as any);
    }

    /**
     * @param me_lo_id (optional) 
     * @return Success
     */
    delete(me_lo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/MemberLog/Delete?";
        if (me_lo_id === null)
            throw new Error("The parameter 'me_lo_id' cannot be null.");
        else if (me_lo_id !== undefined)
            url_ += "me_lo_id=" + encodeURIComponent("" + me_lo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class OrganizationUnitService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getOrganizationUnits(  cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrganizationUnits(_response);
        });
    }

    protected processGetOrganizationUnits(response: AxiosResponse): Promise<OrganizationUnitDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDtoListResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitUserListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrganizationUnitUsers(_response);
        });
    }

    protected processGetOrganizationUnitUsers(response: AxiosResponse): Promise<OrganizationUnitUserListDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitUserListDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitUserListDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitUserListDtoPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitRoleListDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetOrganizationUnitRoles(_response);
        });
    }

    protected processGetOrganizationUnitRoles(response: AxiosResponse): Promise<OrganizationUnitRoleListDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitRoleListDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitRoleListDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitRoleListDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateOrganizationUnit(_response);
        });
    }

    protected processCreateOrganizationUnit(response: AxiosResponse): Promise<OrganizationUnitDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateOrganizationUnit(_response);
        });
    }

    protected processUpdateOrganizationUnit(response: AxiosResponse): Promise<OrganizationUnitDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMoveOrganizationUnit(_response);
        });
    }

    protected processMoveOrganizationUnit(response: AxiosResponse): Promise<OrganizationUnitDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = OrganizationUnitDto.fromJS(resultData200.result);
            return Promise.resolve<OrganizationUnitDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<OrganizationUnitDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteOrganizationUnit(_response);
        });
    }

    protected processDeleteOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveUserFromOrganizationUnit(_response);
        });
    }

    protected processRemoveUserFromOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processRemoveRoleFromOrganizationUnit(_response);
        });
    }

    protected processRemoveRoleFromOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddUsersToOrganizationUnit(_response);
        });
    }

    protected processAddUsersToOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddRolesToOrganizationUnit(_response);
        });
    }

    protected processAddRolesToOrganizationUnit(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined , cancelToken?: CancelToken | undefined): Promise<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindUsers(_response);
        });
    }

    protected processFindUsers(response: AxiosResponse): Promise<NameValueDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NameValueDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<NameValueDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameValueDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined , cancelToken?: CancelToken | undefined): Promise<NameValueDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processFindRoles(_response);
        });
    }

    protected processFindRoles(response: AxiosResponse): Promise<NameValueDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = NameValueDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<NameValueDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<NameValueDtoPagedResultDto>(null as any);
    }
}

export class PlanService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param pl_title (optional) 
     * @param pl_process (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(pl_title: string | undefined, pl_process: PlanProcess | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/GetAll?";
        if (pl_title === null)
            throw new Error("The parameter 'pl_title' cannot be null.");
        else if (pl_title !== undefined)
            url_ += "pl_title=" + encodeURIComponent("" + pl_title) + "&";
        if (pl_process === null)
            throw new Error("The parameter 'pl_process' cannot be null.");
        else if (pl_process !== undefined)
            url_ += "pl_process=" + encodeURIComponent("" + pl_process) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PlanDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDtoPagedResultDto>(null as any);
    }

    /**
     * @param co_id (optional) 
     * @return Success
     */
    getPlanByContractId(co_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/GetPlanByContractId?";
        if (co_id === null)
            throw new Error("The parameter 'co_id' cannot be null.");
        else if (co_id !== undefined)
            url_ += "co_id=" + encodeURIComponent("" + co_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPlanByContractId(_response);
        });
    }

    protected processGetPlanByContractId(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPlan(body: CreatePlanInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/CreatePlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePlan(_response);
        });
    }

    protected processCreatePlan(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePlan(body: UpdatePlanInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/UpdatePlan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePlan(_response);
        });
    }

    protected processUpdatePlan(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getByListPlan(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/GetByListPlan?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByListPlan(_response);
        });
    }

    protected processGetByListPlan(response: AxiosResponse): Promise<PlanDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDtoListResultDto>(null as any);
    }

    /**
     * @param pl_id (optional) 
     * @return Success
     */
    delete(pl_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/Delete?";
        if (pl_id === null)
            throw new Error("The parameter 'pl_id' cannot be null.");
        else if (pl_id !== undefined)
            url_ += "pl_id=" + encodeURIComponent("" + pl_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeProcessOfManager(body: ChangeProcessPlanInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/ChangeProcessOfManager";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeProcessOfManager(_response);
        });
    }

    protected processChangeProcessOfManager(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeProcessOfPlanRoom(body: ChangeProcessPlanInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/ChangeProcessOfPlanRoom";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeProcessOfPlanRoom(_response);
        });
    }

    protected processChangeProcessOfPlanRoom(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    waitApprove(body: ChangeProcessPlanInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/WaitApprove";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWaitApprove(_response);
        });
    }

    protected processWaitApprove(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    confirmDone(body: ConfirmPlanDoneInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDto> {
        let url_ = this.baseUrl + "/api/services/app/Plan/ConfirmDone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processConfirmDone(_response);
        });
    }

    protected processConfirmDone(response: AxiosResponse): Promise<PlanDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDto>(null as any);
    }
}

export class PlanDetailService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param pl_id (optional) 
     * @return Success
     */
    getAll(pl_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDetailDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PlanDetail/GetAll?";
        if (pl_id === null)
            throw new Error("The parameter 'pl_id' cannot be null.");
        else if (pl_id !== undefined)
            url_ += "pl_id=" + encodeURIComponent("" + pl_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PlanDetailDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDetailDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDetailDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDetailDtoListResultDto>(null as any);
    }

    /**
     * @param co_id (optional) 
     * @return Success
     */
    getByContractId(co_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDetailDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PlanDetail/GetByContractId?";
        if (co_id === null)
            throw new Error("The parameter 'co_id' cannot be null.");
        else if (co_id !== undefined)
            url_ += "co_id=" + encodeURIComponent("" + co_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByContractId(_response);
        });
    }

    protected processGetByContractId(response: AxiosResponse): Promise<PlanDetailDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDetailDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDetailDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDetailDtoListResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    getByListPlanDetail(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDetailDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PlanDetail/GetByListPlanDetail?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetByListPlanDetail(_response);
        });
    }

    protected processGetByListPlanDetail(response: AxiosResponse): Promise<PlanDetailDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDetailDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDetailDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDetailDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPlanDetail(body: CreatePlanDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/PlanDetail/CreatePlanDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePlanDetail(_response);
        });
    }

    protected processCreatePlanDetail(response: AxiosResponse): Promise<PlanDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDetailDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDetailDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListPlanDetail(body: CreatePlanDetailInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/PlanDetail/CreateListPlanDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListPlanDetail(_response);
        });
    }

    protected processCreateListPlanDetail(response: AxiosResponse): Promise<PlanDetailDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PlanDetailDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PlanDetailDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDetailDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePlanDetail(body: UpdatePlanDetailInput | undefined , cancelToken?: CancelToken | undefined): Promise<PlanDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/PlanDetail/UpdatePlanDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePlanDetail(_response);
        });
    }

    protected processUpdatePlanDetail(response: AxiosResponse): Promise<PlanDetailDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PlanDetailDto.fromJS(resultData200.result);
            return Promise.resolve<PlanDetailDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PlanDetailDto>(null as any);
    }

    /**
     * @param pl_de_id (optional) 
     * @return Success
     */
    delete(pl_de_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PlanDetail/Delete?";
        if (pl_de_id === null)
            throw new Error("The parameter 'pl_de_id' cannot be null.");
        else if (pl_de_id !== undefined)
            url_ += "pl_de_id=" + encodeURIComponent("" + pl_de_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class PublisherService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param pu_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(pu_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PublisherDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Publisher/GetAll?";
        if (pu_search === null)
            throw new Error("The parameter 'pu_search' cannot be null.");
        else if (pu_search !== undefined)
            url_ += "pu_search=" + encodeURIComponent("" + pu_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PublisherDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublisherDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<PublisherDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublisherDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPublisher(body: CreatePublisherInput | undefined , cancelToken?: CancelToken | undefined): Promise<PublisherDto> {
        let url_ = this.baseUrl + "/api/services/app/Publisher/CreatePublisher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePublisher(_response);
        });
    }

    protected processCreatePublisher(response: AxiosResponse): Promise<PublisherDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublisherDto.fromJS(resultData200.result);
            return Promise.resolve<PublisherDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublisherDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListPublisher(body: CreatePublisherInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<PublisherDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Publisher/CreateListPublisher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListPublisher(_response);
        });
    }

    protected processCreateListPublisher(response: AxiosResponse): Promise<PublisherDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PublisherDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PublisherDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublisherDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePublisher(body: UpdatePublisherInput | undefined , cancelToken?: CancelToken | undefined): Promise<PublisherDto> {
        let url_ = this.baseUrl + "/api/services/app/Publisher/UpdatePublisher";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePublisher(_response);
        });
    }

    protected processUpdatePublisher(response: AxiosResponse): Promise<PublisherDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublisherDto.fromJS(resultData200.result);
            return Promise.resolve<PublisherDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublisherDto>(null as any);
    }

    /**
     * @param pu_id (optional) 
     * @return Success
     */
    delete(pu_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Publisher/Delete?";
        if (pu_id === null)
            throw new Error("The parameter 'pu_id' cannot be null.");
        else if (pu_id !== undefined)
            url_ += "pu_id=" + encodeURIComponent("" + pu_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Publisher/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Publisher/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class PublishLogService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param pu_re_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(pu_re_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PublishLogDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishLog/GetAll?";
        if (pu_re_id === null)
            throw new Error("The parameter 'pu_re_id' cannot be null.");
        else if (pu_re_id !== undefined)
            url_ += "pu_re_id=" + encodeURIComponent("" + pu_re_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PublishLogDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublishLogDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<PublishLogDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublishLogDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPublishLog(body: CreatePublishLogInput | undefined , cancelToken?: CancelToken | undefined): Promise<PublishLogDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishLog/CreatePublishLog";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePublishLog(_response);
        });
    }

    protected processCreatePublishLog(response: AxiosResponse): Promise<PublishLogDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublishLogDto.fromJS(resultData200.result);
            return Promise.resolve<PublishLogDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublishLogDto>(null as any);
    }

    /**
     * @param pu_lo_id (optional) 
     * @return Success
     */
    delete(pu_lo_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishLog/Delete?";
        if (pu_lo_id === null)
            throw new Error("The parameter 'pu_lo_id' cannot be null.");
        else if (pu_lo_id !== undefined)
            url_ += "pu_lo_id=" + encodeURIComponent("" + pu_lo_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class PublishRegisterService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param pu_re_name (optional) 
     * @param ca_id (optional) 
     * @param pu_re_receive_type (optional) 
     * @param me_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(pu_re_name: string | undefined, ca_id: number | undefined, pu_re_receive_type: TypePublishRegister | undefined, me_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PublishRegisterDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishRegister/GetAll?";
        if (pu_re_name === null)
            throw new Error("The parameter 'pu_re_name' cannot be null.");
        else if (pu_re_name !== undefined)
            url_ += "pu_re_name=" + encodeURIComponent("" + pu_re_name) + "&";
        if (ca_id === null)
            throw new Error("The parameter 'ca_id' cannot be null.");
        else if (ca_id !== undefined)
            url_ += "ca_id=" + encodeURIComponent("" + ca_id) + "&";
        if (pu_re_receive_type === null)
            throw new Error("The parameter 'pu_re_receive_type' cannot be null.");
        else if (pu_re_receive_type !== undefined)
            url_ += "pu_re_receive_type=" + encodeURIComponent("" + pu_re_receive_type) + "&";
        if (me_id === null)
            throw new Error("The parameter 'me_id' cannot be null.");
        else if (me_id !== undefined)
            url_ += "me_id=" + encodeURIComponent("" + me_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PublishRegisterDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublishRegisterDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<PublishRegisterDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublishRegisterDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPublishRegister(body: CreatePublishRegisterInput | undefined , cancelToken?: CancelToken | undefined): Promise<PublishRegisterDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishRegister/CreatePublishRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePublishRegister(_response);
        });
    }

    protected processCreatePublishRegister(response: AxiosResponse): Promise<PublishRegisterDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublishRegisterDto.fromJS(resultData200.result);
            return Promise.resolve<PublishRegisterDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublishRegisterDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePublishRegister(body: UpdatePublishRegisterInput | undefined , cancelToken?: CancelToken | undefined): Promise<PublishRegisterDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishRegister/UpdatePublishRegister";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePublishRegister(_response);
        });
    }

    protected processUpdatePublishRegister(response: AxiosResponse): Promise<PublishRegisterDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublishRegisterDto.fromJS(resultData200.result);
            return Promise.resolve<PublishRegisterDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublishRegisterDto>(null as any);
    }
}

export class PublishSettingService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param ca_id (optional) 
     * @param pu_se_type (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(ca_id: number | undefined, pu_se_type: PublishSettingType | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PublishSettingDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishSetting/GetAll?";
        if (ca_id === null)
            throw new Error("The parameter 'ca_id' cannot be null.");
        else if (ca_id !== undefined)
            url_ += "ca_id=" + encodeURIComponent("" + ca_id) + "&";
        if (pu_se_type === null)
            throw new Error("The parameter 'pu_se_type' cannot be null.");
        else if (pu_se_type !== undefined)
            url_ += "pu_se_type=" + encodeURIComponent("" + pu_se_type) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PublishSettingDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublishSettingDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<PublishSettingDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublishSettingDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPublishSetting(body: CreatePublishSettingInput | undefined , cancelToken?: CancelToken | undefined): Promise<PublishSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishSetting/CreatePublishSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreatePublishSetting(_response);
        });
    }

    protected processCreatePublishSetting(response: AxiosResponse): Promise<PublishSettingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublishSettingDto.fromJS(resultData200.result);
            return Promise.resolve<PublishSettingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublishSettingDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePublishSetting(body: UpdatePublishSettingInput | undefined , cancelToken?: CancelToken | undefined): Promise<PublishSettingDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishSetting/UpdatePublishSetting";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePublishSetting(_response);
        });
    }

    protected processUpdatePublishSetting(response: AxiosResponse): Promise<PublishSettingDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PublishSettingDto.fromJS(resultData200.result);
            return Promise.resolve<PublishSettingDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PublishSettingDto>(null as any);
    }

    /**
     * @param re_id (optional) 
     * @return Success
     */
    delete(re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/PublishSetting/Delete?";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class PunishService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param br_re_id (optional) 
     * @param dkcb_code (optional) 
     * @param us_id_borrow (optional) 
     * @param us_id_create (optional) 
     * @param pun_error (optional) 
     * @param pun_created_at (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(br_re_id: number | undefined, dkcb_code: string | undefined, us_id_borrow: number | undefined, us_id_create: number | undefined, pun_error: PunishError | undefined, pun_created_at: Date | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<PunishDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Punish/GetAll?";
        if (br_re_id === null)
            throw new Error("The parameter 'br_re_id' cannot be null.");
        else if (br_re_id !== undefined)
            url_ += "br_re_id=" + encodeURIComponent("" + br_re_id) + "&";
        if (dkcb_code === null)
            throw new Error("The parameter 'dkcb_code' cannot be null.");
        else if (dkcb_code !== undefined)
            url_ += "dkcb_code=" + encodeURIComponent("" + dkcb_code) + "&";
        if (us_id_borrow === null)
            throw new Error("The parameter 'us_id_borrow' cannot be null.");
        else if (us_id_borrow !== undefined)
            url_ += "us_id_borrow=" + encodeURIComponent("" + us_id_borrow) + "&";
        if (us_id_create === null)
            throw new Error("The parameter 'us_id_create' cannot be null.");
        else if (us_id_create !== undefined)
            url_ += "us_id_create=" + encodeURIComponent("" + us_id_create) + "&";
        if (pun_error === null)
            throw new Error("The parameter 'pun_error' cannot be null.");
        else if (pun_error !== undefined)
            url_ += "pun_error=" + encodeURIComponent("" + pun_error) + "&";
        if (pun_created_at === null)
            throw new Error("The parameter 'pun_created_at' cannot be null.");
        else if (pun_created_at !== undefined)
            url_ += "pun_created_at=" + encodeURIComponent(pun_created_at ? "" + pun_created_at.toISOString() : "") + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<PunishDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PunishDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<PunishDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PunishDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListPunish(body: CreatePunishInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<PunishDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Punish/CreateListPunish";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListPunish(_response);
        });
    }

    protected processCreateListPunish(response: AxiosResponse): Promise<PunishDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PunishDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PunishDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PunishDto[]>(null as any);
    }

    /**
     * @param us_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    onCreatePunish(us_id: number | undefined, body: CreatePunishInput | undefined , cancelToken?: CancelToken | undefined): Promise<PunishDto> {
        let url_ = this.baseUrl + "/api/services/app/Punish/onCreatePunish?";
        if (us_id === null)
            throw new Error("The parameter 'us_id' cannot be null.");
        else if (us_id !== undefined)
            url_ += "us_id=" + encodeURIComponent("" + us_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnCreatePunish(_response);
        });
    }

    protected processOnCreatePunish(response: AxiosResponse): Promise<PunishDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PunishDto.fromJS(resultData200.result);
            return Promise.resolve<PunishDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PunishDto>(null as any);
    }

    /**
     * @param me_id (optional) 
     * @param money (optional) 
     * @return Success
     */
    onPunishMoneyMember(me_id: number | undefined, money: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Punish/onPunishMoneyMember?";
        if (me_id === null)
            throw new Error("The parameter 'me_id' cannot be null.");
        else if (me_id !== undefined)
            url_ += "me_id=" + encodeURIComponent("" + me_id) + "&";
        if (money === null)
            throw new Error("The parameter 'money' cannot be null.");
        else if (money !== undefined)
            url_ += "money=" + encodeURIComponent("" + money) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnPunishMoneyMember(_response);
        });
    }

    protected processOnPunishMoneyMember(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class ReceiptService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param rec_code (optional) 
     * @param co_id (optional) 
     * @param us_id_browser (optional) 
     * @param rec_status (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(rec_code: string | undefined, co_id: number | undefined, us_id_browser: number | undefined, rec_status: ReceiptStatus | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReceiptDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Receipt/GetAll?";
        if (rec_code === null)
            throw new Error("The parameter 'rec_code' cannot be null.");
        else if (rec_code !== undefined)
            url_ += "rec_code=" + encodeURIComponent("" + rec_code) + "&";
        if (co_id === null)
            throw new Error("The parameter 'co_id' cannot be null.");
        else if (co_id !== undefined)
            url_ += "co_id=" + encodeURIComponent("" + co_id) + "&";
        if (us_id_browser === null)
            throw new Error("The parameter 'us_id_browser' cannot be null.");
        else if (us_id_browser !== undefined)
            url_ += "us_id_browser=" + encodeURIComponent("" + us_id_browser) + "&";
        if (rec_status === null)
            throw new Error("The parameter 'rec_status' cannot be null.");
        else if (rec_status !== undefined)
            url_ += "rec_status=" + encodeURIComponent("" + rec_status) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ReceiptDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReceiptDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReceiptDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiptDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReceipt(body: CreateReceiptInput | undefined , cancelToken?: CancelToken | undefined): Promise<ReceiptDto> {
        let url_ = this.baseUrl + "/api/services/app/Receipt/CreateReceipt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateReceipt(_response);
        });
    }

    protected processCreateReceipt(response: AxiosResponse): Promise<ReceiptDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReceiptDto.fromJS(resultData200.result);
            return Promise.resolve<ReceiptDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiptDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReceipt(body: UpdateReceiptInput | undefined , cancelToken?: CancelToken | undefined): Promise<ReceiptDto> {
        let url_ = this.baseUrl + "/api/services/app/Receipt/UpdateReceipt";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateReceipt(_response);
        });
    }

    protected processUpdateReceipt(response: AxiosResponse): Promise<ReceiptDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReceiptDto.fromJS(resultData200.result);
            return Promise.resolve<ReceiptDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReceiptDto>(null as any);
    }

    /**
     * @param rec_id (optional) 
     * @return Success
     */
    catalogingReceipt(rec_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Receipt/CatalogingReceipt?";
        if (rec_id === null)
            throw new Error("The parameter 'rec_id' cannot be null.");
        else if (rec_id !== undefined)
            url_ += "rec_id=" + encodeURIComponent("" + rec_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCatalogingReceipt(_response);
        });
    }

    protected processCatalogingReceipt(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    onUpdateStatusBillingByReceiveId(body: Receipt | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Receipt/onUpdateStatusBillingByReceiveId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnUpdateStatusBillingByReceiveId(_response);
        });
    }

    protected processOnUpdateStatusBillingByReceiveId(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param rec_id (optional) 
     * @return Success
     */
    delete(rec_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Receipt/Delete?";
        if (rec_id === null)
            throw new Error("The parameter 'rec_id' cannot be null.");
        else if (rec_id !== undefined)
            url_ += "rec_id=" + encodeURIComponent("" + rec_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class ReponsitoryService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param re_search (optional) 
     * @param re_type (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(re_search: string | undefined, re_type: ReponsitoryType | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<ReponsitoryDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reponsitory/GetAll?";
        if (re_search === null)
            throw new Error("The parameter 're_search' cannot be null.");
        else if (re_search !== undefined)
            url_ += "re_search=" + encodeURIComponent("" + re_search) + "&";
        if (re_type === null)
            throw new Error("The parameter 're_type' cannot be null.");
        else if (re_type !== undefined)
            url_ += "re_type=" + encodeURIComponent("" + re_type) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<ReponsitoryDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReponsitoryDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<ReponsitoryDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReponsitoryDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReponsitory(body: CreateReponsitoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<ReponsitoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Reponsitory/CreateReponsitory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateReponsitory(_response);
        });
    }

    protected processCreateReponsitory(response: AxiosResponse): Promise<ReponsitoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReponsitoryDto.fromJS(resultData200.result);
            return Promise.resolve<ReponsitoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReponsitoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListReponsitory(body: CreateReponsitoryInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<ReponsitoryDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Reponsitory/CreateListReponsitory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListReponsitory(_response);
        });
    }

    protected processCreateListReponsitory(response: AxiosResponse): Promise<ReponsitoryDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ReponsitoryDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ReponsitoryDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReponsitoryDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateReponsitory(body: UpdateReponsitoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<ReponsitoryDto> {
        let url_ = this.baseUrl + "/api/services/app/Reponsitory/UpdateReponsitory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateReponsitory(_response);
        });
    }

    protected processUpdateReponsitory(response: AxiosResponse): Promise<ReponsitoryDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ReponsitoryDto.fromJS(resultData200.result);
            return Promise.resolve<ReponsitoryDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ReponsitoryDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePosition(body: UpdatePositionReponsitoryInput | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reponsitory/ChangePosition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePosition(_response);
        });
    }

    protected processChangePosition(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param re_id (optional) 
     * @return Success
     */
    delete(re_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Reponsitory/Delete?";
        if (re_id === null)
            throw new Error("The parameter 're_id' cannot be null.");
        else if (re_id !== undefined)
            url_ += "re_id=" + encodeURIComponent("" + re_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class RoleService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateRoleInput | undefined , cancelToken?: CancelToken | undefined): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * @param permission (optional) 
     * @return Success
     */
    getRoles(permission: string | undefined , cancelToken?: CancelToken | undefined): Promise<RoleListDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<RoleListDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleListDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<RoleListDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleListDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: RoleDto | undefined , cancelToken?: CancelToken | undefined): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getAllPermissions(  cancelToken?: CancelToken | undefined): Promise<PermissionDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllPermissions(_response);
        });
    }

    protected processGetAllPermissions(response: AxiosResponse): Promise<PermissionDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PermissionDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<PermissionDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PermissionDtoListResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoleForEdit(_response);
        });
    }

    protected processGetRoleForEdit(response: AxiosResponse): Promise<GetRoleForEditOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRoleForEditOutput.fromJS(resultData200.result);
            return Promise.resolve<GetRoleForEditOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRoleForEditOutput>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<RoleDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<RoleDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<RoleDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDtoPagedResultDto>(null as any);
    }
}

export class SessionService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(  cancelToken?: CancelToken | undefined): Promise<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCurrentLoginInformations(_response);
        });
    }

    protected processGetCurrentLoginInformations(response: AxiosResponse): Promise<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200.result);
            return Promise.resolve<GetCurrentLoginInformationsOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetCurrentLoginInformationsOutput>(null as any);
    }

    /**
     * @return Success
     */
    getInformationsToManager(  cancelToken?: CancelToken | undefined): Promise<GetInforToManagerOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetInformationsToManager";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetInformationsToManager(_response);
        });
    }

    protected processGetInformationsToManager(response: AxiosResponse): Promise<GetInforToManagerOutput> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetInforToManagerOutput.fromJS(resultData200.result);
            return Promise.resolve<GetInforToManagerOutput>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetInforToManagerOutput>(null as any);
    }

    /**
     * @return Success
     */
    getMemberInformations(  cancelToken?: CancelToken | undefined): Promise<FindMemberBorrowDto> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetMemberInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetMemberInformations(_response);
        });
    }

    protected processGetMemberInformations(response: AxiosResponse): Promise<FindMemberBorrowDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = FindMemberBorrowDto.fromJS(resultData200.result);
            return Promise.resolve<FindMemberBorrowDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FindMemberBorrowDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMemberInformation(body: UpdateMemberSesionInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberSessionDto> {
        let url_ = this.baseUrl + "/api/services/app/Session/updateMemberInformation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMemberInformation(_response);
        });
    }

    protected processUpdateMemberInformation(response: AxiosResponse): Promise<MemberSessionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberSessionDto.fromJS(resultData200.result);
            return Promise.resolve<MemberSessionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberSessionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMemberAvatar(body: UpdateMemberAvatarSesionInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberSessionDto> {
        let url_ = this.baseUrl + "/api/services/app/Session/updateMemberAvatar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMemberAvatar(_response);
        });
    }

    protected processUpdateMemberAvatar(response: AxiosResponse): Promise<MemberSessionDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberSessionDto.fromJS(resultData200.result);
            return Promise.resolve<MemberSessionDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberSessionDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMemberCard(body: CreateUpdateMemberCardSesionInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDto> {
        let url_ = this.baseUrl + "/api/services/app/Session/CreateMemberCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateMemberCard(_response);
        });
    }

    protected processCreateMemberCard(response: AxiosResponse): Promise<MemberCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateMemberCard(body: CreateUpdateMemberCardSesionInput | undefined , cancelToken?: CancelToken | undefined): Promise<MemberCardDto> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateMemberCard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateMemberCard(_response);
        });
    }

    protected processUpdateMemberCard(response: AxiosResponse): Promise<MemberCardDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = MemberCardDto.fromJS(resultData200.result);
            return Promise.resolve<MemberCardDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<MemberCardDto>(null as any);
    }
}

export class StatisticStorageService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param sta_name (optional) 
     * @param sta_status (optional) 
     * @param pr_id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(sta_name: string | undefined, sta_status: StatisticStorageStatus | undefined, pr_id: number | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticStorageDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorage/GetAll?";
        if (sta_name === null)
            throw new Error("The parameter 'sta_name' cannot be null.");
        else if (sta_name !== undefined)
            url_ += "sta_name=" + encodeURIComponent("" + sta_name) + "&";
        if (sta_status === null)
            throw new Error("The parameter 'sta_status' cannot be null.");
        else if (sta_status !== undefined)
            url_ += "sta_status=" + encodeURIComponent("" + sta_status) + "&";
        if (pr_id === null)
            throw new Error("The parameter 'pr_id' cannot be null.");
        else if (pr_id !== undefined)
            url_ += "pr_id=" + encodeURIComponent("" + pr_id) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<StatisticStorageDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticStorageDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticStorageDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticStorageDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createStatisticStorage(body: CreateStatisticStorageInput | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticStorageDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorage/CreateStatisticStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateStatisticStorage(_response);
        });
    }

    protected processCreateStatisticStorage(response: AxiosResponse): Promise<StatisticStorageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticStorageDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticStorageDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticStorageDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateStatisticStorage(body: UpdateStatisticStorageInput | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticStorageDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorage/UpdateStatisticStorage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateStatisticStorage(_response);
        });
    }

    protected processUpdateStatisticStorage(response: AxiosResponse): Promise<StatisticStorageDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticStorageDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticStorageDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticStorageDto>(null as any);
    }

    /**
     * @param sta_id (optional) 
     * @return Success
     */
    delete(sta_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorage/Delete?";
        if (sta_id === null)
            throw new Error("The parameter 'sta_id' cannot be null.");
        else if (sta_id !== undefined)
            url_ += "sta_id=" + encodeURIComponent("" + sta_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }
}

export class StatisticStorageLibraryService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    statisticBorrowMostDocument(body: SearchStatisticBorrowMostInput | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBorrowMostDocumentDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticBorrowMostDocument";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBorrowMostDocument(_response);
        });
    }

    protected processStatisticBorrowMostDocument(response: AxiosResponse): Promise<StatisticBorrowMostDocumentDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBorrowMostDocumentDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBorrowMostDocumentDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBorrowMostDocumentDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    statisticBorrowMostLibrarian(body: SearchStatisticBorrowMostInput | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBorrowMostLibrarianDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticBorrowMostLibrarian";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBorrowMostLibrarian(_response);
        });
    }

    protected processStatisticBorrowMostLibrarian(response: AxiosResponse): Promise<StatisticBorrowMostLibrarianDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBorrowMostLibrarianDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBorrowMostLibrarianDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBorrowMostLibrarianDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    statisticBorrowMostMember(body: SearchStatisticBorrowMostInput | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBorrowMostMemberDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticBorrowMostMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBorrowMostMember(_response);
        });
    }

    protected processStatisticBorrowMostMember(response: AxiosResponse): Promise<StatisticBorrowMostMemberDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBorrowMostMemberDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBorrowMostMemberDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBorrowMostMemberDtoListResultDto>(null as any);
    }

    /**
     * @return Success
     */
    statisticBorrowReturningWithCategory(  cancelToken?: CancelToken | undefined): Promise<StatisticBorrowReturningWithCategoryDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticBorrowReturningWithCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBorrowReturningWithCategory(_response);
        });
    }

    protected processStatisticBorrowReturningWithCategory(response: AxiosResponse): Promise<StatisticBorrowReturningWithCategoryDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBorrowReturningWithCategoryDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBorrowReturningWithCategoryDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBorrowReturningWithCategoryDtoListResultDto>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    statisticBorrowReturningWithMonth(year: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticBorrowReturningWithMonthDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticBorrowReturningWithMonth?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticBorrowReturningWithMonth(_response);
        });
    }

    protected processStatisticBorrowReturningWithMonth(response: AxiosResponse): Promise<StatisticBorrowReturningWithMonthDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticBorrowReturningWithMonthDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticBorrowReturningWithMonthDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticBorrowReturningWithMonthDtoListResultDto>(null as any);
    }

    /**
     * @return Success
     */
    statisticContractWithSupplier(  cancelToken?: CancelToken | undefined): Promise<StatisticContractWithSupplierDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticContractWithSupplier";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticContractWithSupplier(_response);
        });
    }

    protected processStatisticContractWithSupplier(response: AxiosResponse): Promise<StatisticContractWithSupplierDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticContractWithSupplierDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticContractWithSupplierDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticContractWithSupplierDtoListResultDto>(null as any);
    }

    /**
     * @return Success
     */
    statisticPlanMostMoney(  cancelToken?: CancelToken | undefined): Promise<StatisticPlanMostMoneyDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticPlanMostMoney";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticPlanMostMoney(_response);
        });
    }

    protected processStatisticPlanMostMoney(response: AxiosResponse): Promise<StatisticPlanMostMoneyDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticPlanMostMoneyDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticPlanMostMoneyDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticPlanMostMoneyDtoListResultDto>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    statisticPlanWithMonth(year: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticPlanWithMonthDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticPlanWithMonth?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticPlanWithMonth(_response);
        });
    }

    protected processStatisticPlanWithMonth(response: AxiosResponse): Promise<StatisticPlanWithMonthDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticPlanWithMonthDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticPlanWithMonthDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticPlanWithMonthDtoListResultDto>(null as any);
    }

    /**
     * @return Success
     */
    statisticStatusOfDocumentsWithCategory(  cancelToken?: CancelToken | undefined): Promise<StatisticStatusOfDocumentsWithCategoryDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticStatusOfDocumentsWithCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticStatusOfDocumentsWithCategory(_response);
        });
    }

    protected processStatisticStatusOfDocumentsWithCategory(response: AxiosResponse): Promise<StatisticStatusOfDocumentsWithCategoryDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticStatusOfDocumentsWithCategoryDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticStatusOfDocumentsWithCategoryDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticStatusOfDocumentsWithCategoryDtoListResultDto>(null as any);
    }

    /**
     * @param year (optional) 
     * @return Success
     */
    statisticStatusOfMembers(year: number | undefined , cancelToken?: CancelToken | undefined): Promise<StatisticStatusOfMembersDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/StatisticStorageLibrary/StatisticStatusOfMembers?";
        if (year === null)
            throw new Error("The parameter 'year' cannot be null.");
        else if (year !== undefined)
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processStatisticStatusOfMembers(_response);
        });
    }

    protected processStatisticStatusOfMembers(response: AxiosResponse): Promise<StatisticStatusOfMembersDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatisticStatusOfMembersDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<StatisticStatusOfMembersDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatisticStatusOfMembersDtoListResultDto>(null as any);
    }
}

export class SubFieldMarc21Service {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param mar_id (optional) 
     * @param sub_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(mar_id: number | undefined, sub_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<SubFieldMarc21DtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SubFieldMarc21/GetAll?";
        if (mar_id === null)
            throw new Error("The parameter 'mar_id' cannot be null.");
        else if (mar_id !== undefined)
            url_ += "mar_id=" + encodeURIComponent("" + mar_id) + "&";
        if (sub_search === null)
            throw new Error("The parameter 'sub_search' cannot be null.");
        else if (sub_search !== undefined)
            url_ += "sub_search=" + encodeURIComponent("" + sub_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<SubFieldMarc21DtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SubFieldMarc21DtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<SubFieldMarc21DtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubFieldMarc21DtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSubFieldMarc21(body: CreateSubFieldMarc21Input | undefined , cancelToken?: CancelToken | undefined): Promise<SubFieldMarc21Dto> {
        let url_ = this.baseUrl + "/api/services/app/SubFieldMarc21/CreateSubFieldMarc21";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSubFieldMarc21(_response);
        });
    }

    protected processCreateSubFieldMarc21(response: AxiosResponse): Promise<SubFieldMarc21Dto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SubFieldMarc21Dto.fromJS(resultData200.result);
            return Promise.resolve<SubFieldMarc21Dto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubFieldMarc21Dto>(null as any);
    }

    /**
     * @param mar_id (optional) 
     * @param body (optional) 
     * @return Success
     */
    onCreateSubFieldMarc21(mar_id: number | undefined, body: CreateSubFieldWithCodeMarc21Input | undefined , cancelToken?: CancelToken | undefined): Promise<SubFieldMarc21Dto> {
        let url_ = this.baseUrl + "/api/services/app/SubFieldMarc21/onCreateSubFieldMarc21?";
        if (mar_id === null)
            throw new Error("The parameter 'mar_id' cannot be null.");
        else if (mar_id !== undefined)
            url_ += "mar_id=" + encodeURIComponent("" + mar_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processOnCreateSubFieldMarc21(_response);
        });
    }

    protected processOnCreateSubFieldMarc21(response: AxiosResponse): Promise<SubFieldMarc21Dto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SubFieldMarc21Dto.fromJS(resultData200.result);
            return Promise.resolve<SubFieldMarc21Dto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubFieldMarc21Dto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListSubFieldMarc21(body: CreateSubFieldWithCodeMarc21Input[] | undefined , cancelToken?: CancelToken | undefined): Promise<SubFieldMarc21Dto[]> {
        let url_ = this.baseUrl + "/api/services/app/SubFieldMarc21/CreateListSubFieldMarc21";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListSubFieldMarc21(_response);
        });
    }

    protected processCreateListSubFieldMarc21(response: AxiosResponse): Promise<SubFieldMarc21Dto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubFieldMarc21Dto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SubFieldMarc21Dto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubFieldMarc21Dto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubFieldMarc21(body: UpdateSubFieldMarc21Input | undefined , cancelToken?: CancelToken | undefined): Promise<SubFieldMarc21Dto> {
        let url_ = this.baseUrl + "/api/services/app/SubFieldMarc21/UpdateSubFieldMarc21";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSubFieldMarc21(_response);
        });
    }

    protected processUpdateSubFieldMarc21(response: AxiosResponse): Promise<SubFieldMarc21Dto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SubFieldMarc21Dto.fromJS(resultData200.result);
            return Promise.resolve<SubFieldMarc21Dto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SubFieldMarc21Dto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SubFieldMarc21/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/SubFieldMarc21/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/SubFieldMarc21/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class SupplierService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param su_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(su_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/GetAll?";
        if (su_search === null)
            throw new Error("The parameter 'su_search' cannot be null.");
        else if (su_search !== undefined)
            url_ += "su_search=" + encodeURIComponent("" + su_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<SupplierDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SupplierDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<SupplierDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSupplier(body: CreateSupplierInput | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/CreateSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateSupplier(_response);
        });
    }

    protected processCreateSupplier(response: AxiosResponse): Promise<SupplierDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SupplierDto.fromJS(resultData200.result);
            return Promise.resolve<SupplierDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListSupplier(body: CreateSupplierInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/CreateListSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListSupplier(_response);
        });
    }

    protected processCreateListSupplier(response: AxiosResponse): Promise<SupplierDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<SupplierDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSupplier(body: UpdateSupplierInput | undefined , cancelToken?: CancelToken | undefined): Promise<SupplierDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/UpdateSupplier";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSupplier(_response);
        });
    }

    protected processUpdateSupplier(response: AxiosResponse): Promise<SupplierDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = SupplierDto.fromJS(resultData200.result);
            return Promise.resolve<SupplierDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<SupplierDto>(null as any);
    }

    /**
     * @param su_id (optional) 
     * @return Success
     */
    delete(su_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/Delete?";
        if (su_id === null)
            throw new Error("The parameter 'su_id' cannot be null.");
        else if (su_id !== undefined)
            url_ += "su_id=" + encodeURIComponent("" + su_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Supplier/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class TenantService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantDto | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200.result);
            return Promise.resolve<TenantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200.result);
            return Promise.resolve<TenantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<TenantDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<TenantDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantDto | undefined , cancelToken?: CancelToken | undefined): Promise<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<TenantDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TenantDto.fromJS(resultData200.result);
            return Promise.resolve<TenantDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TenantDto>(null as any);
    }
}

export class TokenAuthService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined , cancelToken?: CancelToken | undefined): Promise<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: AxiosResponse): Promise<AuthenticateResultModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticateResultModel.fromJS(resultData200.result);
            return Promise.resolve<AuthenticateResultModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticateResultModel>(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(  cancelToken?: CancelToken | undefined): Promise<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetExternalAuthenticationProviders(_response);
        });
    }

    protected processGetExternalAuthenticationProviders(response: AxiosResponse): Promise<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<ExternalLoginProviderInfoModel[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalLoginProviderInfoModel[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined , cancelToken?: CancelToken | undefined): Promise<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processExternalAuthenticate(_response);
        });
    }

    protected processExternalAuthenticate(response: AxiosResponse): Promise<ExternalAuthenticateResultModel> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200.result);
            return Promise.resolve<ExternalAuthenticateResultModel>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExternalAuthenticateResultModel>(null as any);
    }
}

export class TopicService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param to_search (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(to_search: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<TopicDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Topic/GetAll?";
        if (to_search === null)
            throw new Error("The parameter 'to_search' cannot be null.");
        else if (to_search !== undefined)
            url_ += "to_search=" + encodeURIComponent("" + to_search) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<TopicDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TopicDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<TopicDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TopicDtoPagedResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTopic(body: CreateTopicInput | undefined , cancelToken?: CancelToken | undefined): Promise<TopicDto> {
        let url_ = this.baseUrl + "/api/services/app/Topic/CreateTopic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateTopic(_response);
        });
    }

    protected processCreateTopic(response: AxiosResponse): Promise<TopicDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TopicDto.fromJS(resultData200.result);
            return Promise.resolve<TopicDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TopicDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createListTopic(body: CreateTopicInput[] | undefined , cancelToken?: CancelToken | undefined): Promise<TopicDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Topic/CreateListTopic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreateListTopic(_response);
        });
    }

    protected processCreateListTopic(response: AxiosResponse): Promise<TopicDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TopicDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<TopicDto[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TopicDto[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTopic(body: UpdateTopicInput | undefined , cancelToken?: CancelToken | undefined): Promise<TopicDto> {
        let url_ = this.baseUrl + "/api/services/app/Topic/UpdateTopic";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateTopic(_response);
        });
    }

    protected processUpdateTopic(response: AxiosResponse): Promise<TopicDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TopicDto.fromJS(resultData200.result);
            return Promise.resolve<TopicDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TopicDto>(null as any);
    }

    /**
     * @param to_id (optional) 
     * @return Success
     */
    delete(to_id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/Topic/Delete?";
        if (to_id === null)
            throw new Error("The parameter 'to_id' cannot be null.");
        else if (to_id !== undefined)
            url_ += "to_id=" + encodeURIComponent("" + to_id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    deleteMulti(input: number[] | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Topic/DeleteMulti?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            input && input.forEach(item => { url_ += "input=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteMulti(_response);
        });
    }

    protected processDeleteMulti(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @return Success
     */
    deleteAll(  cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Topic/DeleteAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteAll(_response);
        });
    }

    protected processDeleteAll(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }
}

export class UserService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateUserDto | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(body: UpdateUserInput | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UserDto | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAvataUser(body: UpdateAvataInput | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateAvataUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateAvataUser(_response);
        });
    }

    protected processUpdateAvataUser(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword2(body: ChangePassword2Dto | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword2(_response);
        });
    }

    protected processChangePassword2(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkPassword2(body: UpdatePassword2Input | undefined , cancelToken?: CancelToken | undefined): Promise<CheckPassword2Output> {
        let url_ = this.baseUrl + "/api/services/app/User/CheckPassword2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCheckPassword2(_response);
        });
    }

    protected processCheckPassword2(response: AxiosResponse): Promise<CheckPassword2Output> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CheckPassword2Output.fromJS(resultData200.result);
            return Promise.resolve<CheckPassword2Output>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CheckPassword2Output>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activate(body: Int64EntityDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deActivate(body: Int64EntityDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeActivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeActivate(_response);
        });
    }

    protected processDeActivate(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return Success
     */
    getRoles(  cancelToken?: CancelToken | undefined): Promise<RoleDtoListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRoles(_response);
        });
    }

    protected processGetRoles(response: AxiosResponse): Promise<RoleDtoListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RoleDtoListResultDto.fromJS(resultData200.result);
            return Promise.resolve<RoleDtoListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDtoListResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangeLanguage(_response);
        });
    }

    protected processChangeLanguage(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordDto | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordDto | undefined , cancelToken?: CancelToken | undefined): Promise<BooleanResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: AxiosResponse): Promise<BooleanResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BooleanResultDto.fromJS(resultData200.result);
            return Promise.resolve<BooleanResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BooleanResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined , cancelToken?: CancelToken | undefined): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDto.fromJS(resultData200.result);
            return Promise.resolve<UserDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDto>(null as any);
    }

    /**
     * @param keyword (optional) 
     * @param isActive (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(keyword: string | undefined, isActive: boolean | undefined, skipCount: number | undefined, maxResultCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<UserDtoPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (keyword === null)
            throw new Error("The parameter 'keyword' cannot be null.");
        else if (keyword !== undefined)
            url_ += "Keyword=" + encodeURIComponent("" + keyword) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<UserDtoPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = UserDtoPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<UserDtoPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<UserDtoPagedResultDto>(null as any);
    }
}

export class WebhookEventService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<WebhookEvent> {
        let url_ = this.baseUrl + "/api/services/app/WebhookEvent/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<WebhookEvent> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WebhookEvent.fromJS(resultData200.result);
            return Promise.resolve<WebhookEvent>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WebhookEvent>(null as any);
    }
}

export class WebhookSendAttemptService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @param subscriptionId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSendAttempts(subscriptionId: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined , cancelToken?: CancelToken | undefined): Promise<GetAllSendAttemptsOutputPagedResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttempts?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "SubscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSendAttempts(_response);
        });
    }

    protected processGetAllSendAttempts(response: AxiosResponse): Promise<GetAllSendAttemptsOutputPagedResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllSendAttemptsOutputPagedResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllSendAttemptsOutputPagedResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllSendAttemptsOutputPagedResultDto>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllSendAttemptsOfWebhookEvent(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetAllSendAttemptsOfWebhookEventOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSendAttemptsOfWebhookEvent(_response);
        });
    }

    protected processGetAllSendAttemptsOfWebhookEvent(response: AxiosResponse): Promise<GetAllSendAttemptsOfWebhookEventOutputListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllSendAttemptsOfWebhookEventOutputListResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllSendAttemptsOfWebhookEventOutputListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllSendAttemptsOfWebhookEventOutputListResultDto>(null as any);
    }

    /**
     * @param sendAttemptId (optional) 
     * @return Success
     */
    resend(sendAttemptId: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/Resend?";
        if (sendAttemptId === null)
            throw new Error("The parameter 'sendAttemptId' cannot be null.");
        else if (sendAttemptId !== undefined)
            url_ += "sendAttemptId=" + encodeURIComponent("" + sendAttemptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processResend(_response);
        });
    }

    protected processResend(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }
}

export class WebhookSubscriptionService {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    publishTestWebhook(  cancelToken?: CancelToken | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/PublishTestWebhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPublishTestWebhook(_response);
        });
    }

    protected processPublishTestWebhook(response: AxiosResponse): Promise<string> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<string>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string>(null as any);
    }

    /**
     * @return Success
     */
    getAllSubscriptions(  cancelToken?: CancelToken | undefined): Promise<GetAllSubscriptionsOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSubscriptions(_response);
        });
    }

    protected processGetAllSubscriptions(response: AxiosResponse): Promise<GetAllSubscriptionsOutputListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllSubscriptionsOutputListResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllSubscriptionsOutputListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllSubscriptionsOutputListResultDto>(null as any);
    }

    /**
     * @param subscriptionId (optional) 
     * @return Success
     */
    getSubscription(subscriptionId: string | undefined , cancelToken?: CancelToken | undefined): Promise<WebhookSubscription> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetSubscription?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetSubscription(_response);
        });
    }

    protected processGetSubscription(response: AxiosResponse): Promise<WebhookSubscription> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = WebhookSubscription.fromJS(resultData200.result);
            return Promise.resolve<WebhookSubscription>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WebhookSubscription>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSubscription(body: WebhookSubscription | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/AddSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddSubscription(_response);
        });
    }

    protected processAddSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: WebhookSubscription | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateSubscription(_response);
        });
    }

    protected processUpdateSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteWebhookSubscription(id: string | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/DeleteWebhookSubscription?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteWebhookSubscription(_response);
        });
    }

    protected processDeleteWebhookSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/ActivateWebhookSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json-patch+json",
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processActivateWebhookSubscription(_response);
        });
    }

    protected processActivateWebhookSubscription(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    isSubscribed(webhookName: string | undefined , cancelToken?: CancelToken | undefined): Promise<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/IsSubscribed?";
        if (webhookName === null)
            throw new Error("The parameter 'webhookName' cannot be null.");
        else if (webhookName !== undefined)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processIsSubscribed(_response);
        });
    }

    protected processIsSubscribed(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return Promise.resolve<boolean>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    getAllSubscriptionsIfFeaturesGranted(webhookName: string | undefined , cancelToken?: CancelToken | undefined): Promise<GetAllSubscriptionsOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?";
        if (webhookName === null)
            throw new Error("The parameter 'webhookName' cannot be null.");
        else if (webhookName !== undefined)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllSubscriptionsIfFeaturesGranted(_response);
        });
    }

    protected processGetAllSubscriptionsIfFeaturesGranted(response: AxiosResponse): Promise<GetAllSubscriptionsOutputListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllSubscriptionsOutputListResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllSubscriptionsOutputListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllSubscriptionsOutputListResultDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllAvailableWebhooks(  cancelToken?: CancelToken | undefined): Promise<GetAllAvailableWebhooksOutputListResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllAvailableWebhooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAllAvailableWebhooks(_response);
        });
    }

    protected processGetAllAvailableWebhooks(response: AxiosResponse): Promise<GetAllAvailableWebhooksOutputListResultDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetAllAvailableWebhooksOutputListResultDto.fromJS(resultData200.result);
            return Promise.resolve<GetAllAvailableWebhooksOutputListResultDto>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetAllAvailableWebhooksOutputListResultDto>(null as any);
    }
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
    subscriptionId!: string;
    isActive!: boolean;

    constructor(data?: IActivateWebhookSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActivateWebhookSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateWebhookSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): ActivateWebhookSubscriptionInput {
        const json = this.toJSON();
        let result = new ActivateWebhookSubscriptionInput();
        result.init(json);
        return result;
    }
}

export interface IActivateWebhookSubscriptionInput {
    subscriptionId: string;
    isActive: boolean;
}

export class ApplicationExtDto implements IApplicationExtDto {
    ap_id!: number;
    ap_code!: string | undefined;
    ap_secret!: string | undefined;
    ap_callback_url!: string | undefined;
    ap_trust!: boolean;
    ap_confidential!: boolean;

    constructor(data?: IApplicationExtDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ap_id = _data["ap_id"];
            this.ap_code = _data["ap_code"];
            this.ap_secret = _data["ap_secret"];
            this.ap_callback_url = _data["ap_callback_url"];
            this.ap_trust = _data["ap_trust"];
            this.ap_confidential = _data["ap_confidential"];
        }
    }

    static fromJS(data: any): ApplicationExtDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationExtDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ap_id"] = this.ap_id;
        data["ap_code"] = this.ap_code;
        data["ap_secret"] = this.ap_secret;
        data["ap_callback_url"] = this.ap_callback_url;
        data["ap_trust"] = this.ap_trust;
        data["ap_confidential"] = this.ap_confidential;
        return data;
    }

    clone(): ApplicationExtDto {
        const json = this.toJSON();
        let result = new ApplicationExtDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationExtDto {
    ap_id: number;
    ap_code: string | undefined;
    ap_secret: string | undefined;
    ap_callback_url: string | undefined;
    ap_trust: boolean;
    ap_confidential: boolean;
}

export class ApplicationExtDtoListResultDto implements IApplicationExtDtoListResultDto {
    items!: ApplicationExtDto[] | undefined;

    constructor(data?: IApplicationExtDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationExtDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationExtDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationExtDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): ApplicationExtDtoListResultDto {
        const json = this.toJSON();
        let result = new ApplicationExtDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationExtDtoListResultDto {
    items: ApplicationExtDto[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: Date;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? new Date(_data["releaseDate"].toString()) : <any>undefined;
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: Date;
    features: { [key: string]: boolean; } | undefined;
}

export class ApproveMemberCardInput implements IApproveMemberCardInput {
    me_ca_id!: number;
    me_ca_use_from!: Date;
    me_ca_use_to!: Date;
    me_ca_level!: number;
    me_ca_type!: MCardType;
    me_ca_time_receive!: Date | undefined;

    constructor(data?: IApproveMemberCardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_ca_id = _data["me_ca_id"];
            this.me_ca_use_from = _data["me_ca_use_from"] ? new Date(_data["me_ca_use_from"].toString()) : <any>undefined;
            this.me_ca_use_to = _data["me_ca_use_to"] ? new Date(_data["me_ca_use_to"].toString()) : <any>undefined;
            this.me_ca_level = _data["me_ca_level"];
            this.me_ca_type = _data["me_ca_type"];
            this.me_ca_time_receive = _data["me_ca_time_receive"] ? new Date(_data["me_ca_time_receive"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ApproveMemberCardInput {
        data = typeof data === 'object' ? data : {};
        let result = new ApproveMemberCardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_ca_id"] = this.me_ca_id;
        data["me_ca_use_from"] = this.me_ca_use_from ? this.me_ca_use_from.toISOString() : <any>undefined;
        data["me_ca_use_to"] = this.me_ca_use_to ? this.me_ca_use_to.toISOString() : <any>undefined;
        data["me_ca_level"] = this.me_ca_level;
        data["me_ca_type"] = this.me_ca_type;
        data["me_ca_time_receive"] = this.me_ca_time_receive ? this.me_ca_time_receive.toISOString() : <any>undefined;
        return data;
    }

    clone(): ApproveMemberCardInput {
        const json = this.toJSON();
        let result = new ApproveMemberCardInput();
        result.init(json);
        return result;
    }
}

export interface IApproveMemberCardInput {
    me_ca_id: number;
    me_ca_use_from: Date;
    me_ca_use_to: Date;
    me_ca_level: number;
    me_ca_type: MCardType;
    me_ca_time_receive: Date | undefined;
}

export class AttachmentItem implements IAttachmentItem {
    id!: number;
    key!: string | undefined;
    ext!: string | undefined;
    path!: string | undefined;
    isdelete!: boolean;

    constructor(data?: IAttachmentItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.ext = _data["ext"];
            this.path = _data["path"];
            this.isdelete = _data["isdelete"];
        }
    }

    static fromJS(data: any): AttachmentItem {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["ext"] = this.ext;
        data["path"] = this.path;
        data["isdelete"] = this.isdelete;
        return data;
    }

    clone(): AttachmentItem {
        const json = this.toJSON();
        let result = new AttachmentItem();
        result.init(json);
        return result;
    }
}

export interface IAttachmentItem {
    id: number;
    key: string | undefined;
    ext: string | undefined;
    path: string | undefined;
    isdelete: boolean;
}

export class AuditLogDto implements IAuditLogDto {
    id!: number;
    impersonatorUserId!: number | undefined;
    exception!: string | undefined;
    browserInfo!: string | undefined;
    clientName!: string | undefined;
    clientIpAddress!: string | undefined;
    executionDuration!: number;
    executionTime!: Date;
    userId!: number | undefined;
    methodName!: string | undefined;
    serviceName!: string | undefined;
    parameters!: string | undefined;
    customData!: string | undefined;

    constructor(data?: IAuditLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.exception = _data["exception"];
            this.browserInfo = _data["browserInfo"];
            this.clientName = _data["clientName"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.executionDuration = _data["executionDuration"];
            this.executionTime = _data["executionTime"] ? new Date(_data["executionTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.methodName = _data["methodName"];
            this.serviceName = _data["serviceName"];
            this.parameters = _data["parameters"];
            this.customData = _data["customData"];
        }
    }

    static fromJS(data: any): AuditLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["exception"] = this.exception;
        data["browserInfo"] = this.browserInfo;
        data["clientName"] = this.clientName;
        data["clientIpAddress"] = this.clientIpAddress;
        data["executionDuration"] = this.executionDuration;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["methodName"] = this.methodName;
        data["serviceName"] = this.serviceName;
        data["parameters"] = this.parameters;
        data["customData"] = this.customData;
        return data;
    }

    clone(): AuditLogDto {
        const json = this.toJSON();
        let result = new AuditLogDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogDto {
    id: number;
    impersonatorUserId: number | undefined;
    exception: string | undefined;
    browserInfo: string | undefined;
    clientName: string | undefined;
    clientIpAddress: string | undefined;
    executionDuration: number;
    executionTime: Date;
    userId: number | undefined;
    methodName: string | undefined;
    serviceName: string | undefined;
    parameters: string | undefined;
    customData: string | undefined;
}

export class AuditLogDtoPagedResultDto implements IAuditLogDtoPagedResultDto {
    items!: AuditLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAuditLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AuditLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AuditLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuditLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogDtoPagedResultDto {
    items: AuditLogDto[] | undefined;
    totalCount: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    rememberClient!: boolean;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.rememberClient = _data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data;
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    userId!: number;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data;
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class AuthorAbtractDto implements IAuthorAbtractDto {
    au_id!: number;
    au_code!: string | undefined;
    au_name!: string | undefined;
    au_is_deleted!: boolean;

    constructor(data?: IAuthorAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.au_id = _data["au_id"];
            this.au_code = _data["au_code"];
            this.au_name = _data["au_name"];
            this.au_is_deleted = _data["au_is_deleted"];
        }
    }

    static fromJS(data: any): AuthorAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["au_id"] = this.au_id;
        data["au_code"] = this.au_code;
        data["au_name"] = this.au_name;
        data["au_is_deleted"] = this.au_is_deleted;
        return data;
    }

    clone(): AuthorAbtractDto {
        const json = this.toJSON();
        let result = new AuthorAbtractDto();
        result.init(json);
        return result;
    }
}

export interface IAuthorAbtractDto {
    au_id: number;
    au_code: string | undefined;
    au_name: string | undefined;
    au_is_deleted: boolean;
}

export class AuthorDto implements IAuthorDto {
    au_id!: number;
    au_code!: string | undefined;
    au_name!: string | undefined;
    au_dob!: string | undefined;
    au_address!: string | undefined;
    au_decs!: string | undefined;
    au_email!: string | undefined;
    au_academic_rank!: string | undefined;
    au_degree!: string | undefined;
    au_pen_name!: string | undefined;
    au_infor!: string | undefined;
    fi_id!: AttachmentItem;
    au_created_at!: Date;
    au_updated_at!: Date;

    constructor(data?: IAuthorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.au_id = _data["au_id"];
            this.au_code = _data["au_code"];
            this.au_name = _data["au_name"];
            this.au_dob = _data["au_dob"];
            this.au_address = _data["au_address"];
            this.au_decs = _data["au_decs"];
            this.au_email = _data["au_email"];
            this.au_academic_rank = _data["au_academic_rank"];
            this.au_degree = _data["au_degree"];
            this.au_pen_name = _data["au_pen_name"];
            this.au_infor = _data["au_infor"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.au_created_at = _data["au_created_at"] ? new Date(_data["au_created_at"].toString()) : <any>undefined;
            this.au_updated_at = _data["au_updated_at"] ? new Date(_data["au_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthorDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["au_id"] = this.au_id;
        data["au_code"] = this.au_code;
        data["au_name"] = this.au_name;
        data["au_dob"] = this.au_dob;
        data["au_address"] = this.au_address;
        data["au_decs"] = this.au_decs;
        data["au_email"] = this.au_email;
        data["au_academic_rank"] = this.au_academic_rank;
        data["au_degree"] = this.au_degree;
        data["au_pen_name"] = this.au_pen_name;
        data["au_infor"] = this.au_infor;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["au_created_at"] = this.au_created_at ? this.au_created_at.toISOString() : <any>undefined;
        data["au_updated_at"] = this.au_updated_at ? this.au_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): AuthorDto {
        const json = this.toJSON();
        let result = new AuthorDto();
        result.init(json);
        return result;
    }
}

export interface IAuthorDto {
    au_id: number;
    au_code: string | undefined;
    au_name: string | undefined;
    au_dob: string | undefined;
    au_address: string | undefined;
    au_decs: string | undefined;
    au_email: string | undefined;
    au_academic_rank: string | undefined;
    au_degree: string | undefined;
    au_pen_name: string | undefined;
    au_infor: string | undefined;
    fi_id: AttachmentItem;
    au_created_at: Date;
    au_updated_at: Date;
}

export class AuthorDtoPagedResultDto implements IAuthorDtoPagedResultDto {
    items!: AuthorDto[] | undefined;
    totalCount!: number;

    constructor(data?: IAuthorDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuthorDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): AuthorDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthorDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): AuthorDtoPagedResultDto {
        const json = this.toJSON();
        let result = new AuthorDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IAuthorDtoPagedResultDto {
    items: AuthorDto[] | undefined;
    totalCount: number;
}

export enum BillStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class BillingDto implements IBillingDto {
    bi_id!: number;
    bi_code!: string | undefined;
    bi_desc!: string | undefined;
    bi_note!: string | undefined;
    bi_export!: Date;
    bi_status!: BillStatus;
    bi_is_delete!: boolean;
    su_id!: ItemSupplier;
    co_id!: number;
    fi_id_arr!: AttachmentItem[] | undefined;
    pl_de_id_arr!: number[] | undefined;
    billingItems!: BillingItemDto[] | undefined;
    bi_total_cost!: number;
    bi_created_at!: Date;
    bi_updated_at!: Date;

    constructor(data?: IBillingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_id = _data["bi_id"];
            this.bi_code = _data["bi_code"];
            this.bi_desc = _data["bi_desc"];
            this.bi_note = _data["bi_note"];
            this.bi_export = _data["bi_export"] ? new Date(_data["bi_export"].toString()) : <any>undefined;
            this.bi_status = _data["bi_status"];
            this.bi_is_delete = _data["bi_is_delete"];
            this.su_id = _data["su_id"] ? ItemSupplier.fromJS(_data["su_id"]) : <any>undefined;
            this.co_id = _data["co_id"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["pl_de_id_arr"])) {
                this.pl_de_id_arr = [] as any;
                for (let item of _data["pl_de_id_arr"])
                    this.pl_de_id_arr!.push(item);
            }
            if (Array.isArray(_data["billingItems"])) {
                this.billingItems = [] as any;
                for (let item of _data["billingItems"])
                    this.billingItems!.push(BillingItemDto.fromJS(item));
            }
            this.bi_total_cost = _data["bi_total_cost"];
            this.bi_created_at = _data["bi_created_at"] ? new Date(_data["bi_created_at"].toString()) : <any>undefined;
            this.bi_updated_at = _data["bi_updated_at"] ? new Date(_data["bi_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BillingDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_id"] = this.bi_id;
        data["bi_code"] = this.bi_code;
        data["bi_desc"] = this.bi_desc;
        data["bi_note"] = this.bi_note;
        data["bi_export"] = this.bi_export ? this.bi_export.toISOString() : <any>undefined;
        data["bi_status"] = this.bi_status;
        data["bi_is_delete"] = this.bi_is_delete;
        data["su_id"] = this.su_id ? this.su_id.toJSON() : <any>undefined;
        data["co_id"] = this.co_id;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.pl_de_id_arr)) {
            data["pl_de_id_arr"] = [];
            for (let item of this.pl_de_id_arr)
                data["pl_de_id_arr"].push(item);
        }
        if (Array.isArray(this.billingItems)) {
            data["billingItems"] = [];
            for (let item of this.billingItems)
                data["billingItems"].push(item.toJSON());
        }
        data["bi_total_cost"] = this.bi_total_cost;
        data["bi_created_at"] = this.bi_created_at ? this.bi_created_at.toISOString() : <any>undefined;
        data["bi_updated_at"] = this.bi_updated_at ? this.bi_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): BillingDto {
        const json = this.toJSON();
        let result = new BillingDto();
        result.init(json);
        return result;
    }
}

export interface IBillingDto {
    bi_id: number;
    bi_code: string | undefined;
    bi_desc: string | undefined;
    bi_note: string | undefined;
    bi_export: Date;
    bi_status: BillStatus;
    bi_is_delete: boolean;
    su_id: ItemSupplier;
    co_id: number;
    fi_id_arr: AttachmentItem[] | undefined;
    pl_de_id_arr: number[] | undefined;
    billingItems: BillingItemDto[] | undefined;
    bi_total_cost: number;
    bi_created_at: Date;
    bi_updated_at: Date;
}

export class BillingDtoPagedResultDto implements IBillingDtoPagedResultDto {
    items!: BillingDto[] | undefined;
    totalCount!: number;

    constructor(data?: IBillingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BillingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BillingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BillingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BillingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBillingDtoPagedResultDto {
    items: BillingDto[] | undefined;
    totalCount: number;
}

export class BillingItemDto implements IBillingItemDto {
    bi_it_id!: number;
    bi_it_name!: string | undefined;
    bi_id!: number;
    bi_it_cost!: number;
    pl_de_id!: number;
    bi_it_amount!: number;
    bi_it_unit!: string | undefined;
    bi_it_status!: PlanDetailStatus;
    do_id!: ItemDocument;
    bi_it_created_at!: Date;

    constructor(data?: IBillingItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_it_id = _data["bi_it_id"];
            this.bi_it_name = _data["bi_it_name"];
            this.bi_id = _data["bi_id"];
            this.bi_it_cost = _data["bi_it_cost"];
            this.pl_de_id = _data["pl_de_id"];
            this.bi_it_amount = _data["bi_it_amount"];
            this.bi_it_unit = _data["bi_it_unit"];
            this.bi_it_status = _data["bi_it_status"];
            this.do_id = _data["do_id"] ? ItemDocument.fromJS(_data["do_id"]) : <any>undefined;
            this.bi_it_created_at = _data["bi_it_created_at"] ? new Date(_data["bi_it_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BillingItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_it_id"] = this.bi_it_id;
        data["bi_it_name"] = this.bi_it_name;
        data["bi_id"] = this.bi_id;
        data["bi_it_cost"] = this.bi_it_cost;
        data["pl_de_id"] = this.pl_de_id;
        data["bi_it_amount"] = this.bi_it_amount;
        data["bi_it_unit"] = this.bi_it_unit;
        data["bi_it_status"] = this.bi_it_status;
        data["do_id"] = this.do_id ? this.do_id.toJSON() : <any>undefined;
        data["bi_it_created_at"] = this.bi_it_created_at ? this.bi_it_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): BillingItemDto {
        const json = this.toJSON();
        let result = new BillingItemDto();
        result.init(json);
        return result;
    }
}

export interface IBillingItemDto {
    bi_it_id: number;
    bi_it_name: string | undefined;
    bi_id: number;
    bi_it_cost: number;
    pl_de_id: number;
    bi_it_amount: number;
    bi_it_unit: string | undefined;
    bi_it_status: PlanDetailStatus;
    do_id: ItemDocument;
    bi_it_created_at: Date;
}

export class BillingItemDtoListResultDto implements IBillingItemDtoListResultDto {
    items!: BillingItemDto[] | undefined;

    constructor(data?: IBillingItemDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BillingItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BillingItemDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingItemDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): BillingItemDtoListResultDto {
        const json = this.toJSON();
        let result = new BillingItemDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IBillingItemDtoListResultDto {
    items: BillingItemDto[] | undefined;
}

export class BillingItemDtoPagedResultDto implements IBillingItemDtoPagedResultDto {
    items!: BillingItemDto[] | undefined;
    totalCount!: number;

    constructor(data?: IBillingItemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BillingItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BillingItemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingItemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BillingItemDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BillingItemDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBillingItemDtoPagedResultDto {
    items: BillingItemDto[] | undefined;
    totalCount: number;
}

export class BooleanResultDto implements IBooleanResultDto {
    result!: boolean;

    constructor(data?: IBooleanResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.result = _data["result"];
        }
    }

    static fromJS(data: any): BooleanResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        return data;
    }

    clone(): BooleanResultDto {
        const json = this.toJSON();
        let result = new BooleanResultDto();
        result.init(json);
        return result;
    }
}

export interface IBooleanResultDto {
    result: boolean;
}

export enum BorrowMethod {
    _0 = 0,
    _1 = 1,
}

export enum BorrowReturnLogType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
    _11 = 11,
    _12 = 12,
}

export class BorrowReturning implements IBorrowReturning {
    id!: number;
    readonly br_re_id!: number;
    br_re_code!: string | undefined;
    br_re_desc!: string | undefined;
    br_re_nr_document!: number;
    br_re_money_borrow!: number;
    us_id_borrow!: number;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    br_re_status!: BorrowReturningProcess;
    br_re_method!: BorrowMethod;
    us_id_accept!: number;
    br_re_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    fi_id_arr!: string | undefined;
    punishes!: Punish[] | undefined;
    br_re_extend_note!: string | undefined;
    br_re_borrow_at!: Date | undefined;
    br_re_accept_at!: Date | undefined;
    br_re_return_at!: Date | undefined;
    br_re_delete_at!: Date | undefined;
    br_re_updated_at!: Date;
    br_re_created_at!: Date;
    borrowReturningDetails!: BorrowReturningDetail[] | undefined;

    constructor(data?: IBorrowReturning) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).br_re_id = _data["br_re_id"];
            this.br_re_code = _data["br_re_code"];
            this.br_re_desc = _data["br_re_desc"];
            this.br_re_nr_document = _data["br_re_nr_document"];
            this.br_re_money_borrow = _data["br_re_money_borrow"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            this.br_re_status = _data["br_re_status"];
            this.br_re_method = _data["br_re_method"];
            this.us_id_accept = _data["us_id_accept"];
            this.br_re_is_delete = _data["br_re_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            this.fi_id_arr = _data["fi_id_arr"];
            if (Array.isArray(_data["punishes"])) {
                this.punishes = [] as any;
                for (let item of _data["punishes"])
                    this.punishes!.push(Punish.fromJS(item));
            }
            this.br_re_extend_note = _data["br_re_extend_note"];
            this.br_re_borrow_at = _data["br_re_borrow_at"] ? new Date(_data["br_re_borrow_at"].toString()) : <any>undefined;
            this.br_re_accept_at = _data["br_re_accept_at"] ? new Date(_data["br_re_accept_at"].toString()) : <any>undefined;
            this.br_re_return_at = _data["br_re_return_at"] ? new Date(_data["br_re_return_at"].toString()) : <any>undefined;
            this.br_re_delete_at = _data["br_re_delete_at"] ? new Date(_data["br_re_delete_at"].toString()) : <any>undefined;
            this.br_re_updated_at = _data["br_re_updated_at"] ? new Date(_data["br_re_updated_at"].toString()) : <any>undefined;
            this.br_re_created_at = _data["br_re_created_at"] ? new Date(_data["br_re_created_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["borrowReturningDetails"])) {
                this.borrowReturningDetails = [] as any;
                for (let item of _data["borrowReturningDetails"])
                    this.borrowReturningDetails!.push(BorrowReturningDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BorrowReturning {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturning();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["br_re_id"] = this.br_re_id;
        data["br_re_code"] = this.br_re_code;
        data["br_re_desc"] = this.br_re_desc;
        data["br_re_nr_document"] = this.br_re_nr_document;
        data["br_re_money_borrow"] = this.br_re_money_borrow;
        data["us_id_borrow"] = this.us_id_borrow;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        data["br_re_status"] = this.br_re_status;
        data["br_re_method"] = this.br_re_method;
        data["us_id_accept"] = this.us_id_accept;
        data["br_re_is_delete"] = this.br_re_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        data["fi_id_arr"] = this.fi_id_arr;
        if (Array.isArray(this.punishes)) {
            data["punishes"] = [];
            for (let item of this.punishes)
                data["punishes"].push(item.toJSON());
        }
        data["br_re_extend_note"] = this.br_re_extend_note;
        data["br_re_borrow_at"] = this.br_re_borrow_at ? this.br_re_borrow_at.toISOString() : <any>undefined;
        data["br_re_accept_at"] = this.br_re_accept_at ? this.br_re_accept_at.toISOString() : <any>undefined;
        data["br_re_return_at"] = this.br_re_return_at ? this.br_re_return_at.toISOString() : <any>undefined;
        data["br_re_delete_at"] = this.br_re_delete_at ? this.br_re_delete_at.toISOString() : <any>undefined;
        data["br_re_updated_at"] = this.br_re_updated_at ? this.br_re_updated_at.toISOString() : <any>undefined;
        data["br_re_created_at"] = this.br_re_created_at ? this.br_re_created_at.toISOString() : <any>undefined;
        if (Array.isArray(this.borrowReturningDetails)) {
            data["borrowReturningDetails"] = [];
            for (let item of this.borrowReturningDetails)
                data["borrowReturningDetails"].push(item.toJSON());
        }
        return data;
    }

    clone(): BorrowReturning {
        const json = this.toJSON();
        let result = new BorrowReturning();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturning {
    id: number;
    br_re_id: number;
    br_re_code: string | undefined;
    br_re_desc: string | undefined;
    br_re_nr_document: number;
    br_re_money_borrow: number;
    us_id_borrow: number;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    br_re_status: BorrowReturningProcess;
    br_re_method: BorrowMethod;
    us_id_accept: number;
    br_re_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    fi_id_arr: string | undefined;
    punishes: Punish[] | undefined;
    br_re_extend_note: string | undefined;
    br_re_borrow_at: Date | undefined;
    br_re_accept_at: Date | undefined;
    br_re_return_at: Date | undefined;
    br_re_delete_at: Date | undefined;
    br_re_updated_at: Date;
    br_re_created_at: Date;
    borrowReturningDetails: BorrowReturningDetail[] | undefined;
}

export class BorrowReturningDetail implements IBorrowReturningDetail {
    id!: number;
    readonly br_re_de_id!: number;
    br_re_id!: number;
    do_id!: number;
    do_in_id!: number;
    br_re_de_money_document!: number;
    us_id_borrow!: number;
    us_id_created!: number;
    br_re_de_return_at!: Date | undefined;
    br_re_de_no_adjourn!: number;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    br_re_status!: BorrowReturningDetailStatus;
    punishes!: Punish[] | undefined;

    constructor(data?: IBorrowReturningDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).br_re_de_id = _data["br_re_de_id"];
            this.br_re_id = _data["br_re_id"];
            this.do_id = _data["do_id"];
            this.do_in_id = _data["do_in_id"];
            this.br_re_de_money_document = _data["br_re_de_money_document"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.us_id_created = _data["us_id_created"];
            this.br_re_de_return_at = _data["br_re_de_return_at"] ? new Date(_data["br_re_de_return_at"].toString()) : <any>undefined;
            this.br_re_de_no_adjourn = _data["br_re_de_no_adjourn"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            this.br_re_status = _data["br_re_status"];
            if (Array.isArray(_data["punishes"])) {
                this.punishes = [] as any;
                for (let item of _data["punishes"])
                    this.punishes!.push(Punish.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BorrowReturningDetail {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["br_re_de_id"] = this.br_re_de_id;
        data["br_re_id"] = this.br_re_id;
        data["do_id"] = this.do_id;
        data["do_in_id"] = this.do_in_id;
        data["br_re_de_money_document"] = this.br_re_de_money_document;
        data["us_id_borrow"] = this.us_id_borrow;
        data["us_id_created"] = this.us_id_created;
        data["br_re_de_return_at"] = this.br_re_de_return_at ? this.br_re_de_return_at.toISOString() : <any>undefined;
        data["br_re_de_no_adjourn"] = this.br_re_de_no_adjourn;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        data["br_re_status"] = this.br_re_status;
        if (Array.isArray(this.punishes)) {
            data["punishes"] = [];
            for (let item of this.punishes)
                data["punishes"].push(item.toJSON());
        }
        return data;
    }

    clone(): BorrowReturningDetail {
        const json = this.toJSON();
        let result = new BorrowReturningDetail();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningDetail {
    id: number;
    br_re_de_id: number;
    br_re_id: number;
    do_id: number;
    do_in_id: number;
    br_re_de_money_document: number;
    us_id_borrow: number;
    us_id_created: number;
    br_re_de_return_at: Date | undefined;
    br_re_de_no_adjourn: number;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    br_re_status: BorrowReturningDetailStatus;
    punishes: Punish[] | undefined;
}

export enum BorrowReturningDetailStatus {
    _10 = 10,
    _20 = 20,
    _30 = 30,
    _40 = 40,
    _50 = 50,
    _60 = 60,
    _120 = 120,
}

export class BorrowReturningDetailsWithListDocumentDto implements IBorrowReturningDetailsWithListDocumentDto {
    br_re_id!: number;
    br_re_code!: string | undefined;
    br_re_desc!: string | undefined;
    br_re_nr_document!: number;
    br_re_money_borrow!: number;
    us_id_borrow!: number;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    br_re_status!: BorrowReturningProcess;
    br_re_method!: BorrowMethod;
    us_id_accept!: number;
    br_re_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    fi_id_arr!: AttachmentItem[] | undefined;
    br_re_extend_note!: string | undefined;
    br_re_due_date!: Date | undefined;
    br_re_accept_at!: Date | undefined;
    br_re_return_at!: Date | undefined;
    br_re_delete_at!: Date | undefined;
    br_re_updated_at!: Date;
    br_re_created_at!: Date;
    list_borrow!: BorrowReturningIDetailDto[] | undefined;

    constructor(data?: IBorrowReturningDetailsWithListDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_id = _data["br_re_id"];
            this.br_re_code = _data["br_re_code"];
            this.br_re_desc = _data["br_re_desc"];
            this.br_re_nr_document = _data["br_re_nr_document"];
            this.br_re_money_borrow = _data["br_re_money_borrow"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            this.br_re_status = _data["br_re_status"];
            this.br_re_method = _data["br_re_method"];
            this.us_id_accept = _data["us_id_accept"];
            this.br_re_is_delete = _data["br_re_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.br_re_extend_note = _data["br_re_extend_note"];
            this.br_re_due_date = _data["br_re_due_date"] ? new Date(_data["br_re_due_date"].toString()) : <any>undefined;
            this.br_re_accept_at = _data["br_re_accept_at"] ? new Date(_data["br_re_accept_at"].toString()) : <any>undefined;
            this.br_re_return_at = _data["br_re_return_at"] ? new Date(_data["br_re_return_at"].toString()) : <any>undefined;
            this.br_re_delete_at = _data["br_re_delete_at"] ? new Date(_data["br_re_delete_at"].toString()) : <any>undefined;
            this.br_re_updated_at = _data["br_re_updated_at"] ? new Date(_data["br_re_updated_at"].toString()) : <any>undefined;
            this.br_re_created_at = _data["br_re_created_at"] ? new Date(_data["br_re_created_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["list_borrow"])) {
                this.list_borrow = [] as any;
                for (let item of _data["list_borrow"])
                    this.list_borrow!.push(BorrowReturningIDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BorrowReturningDetailsWithListDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningDetailsWithListDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_id"] = this.br_re_id;
        data["br_re_code"] = this.br_re_code;
        data["br_re_desc"] = this.br_re_desc;
        data["br_re_nr_document"] = this.br_re_nr_document;
        data["br_re_money_borrow"] = this.br_re_money_borrow;
        data["us_id_borrow"] = this.us_id_borrow;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        data["br_re_status"] = this.br_re_status;
        data["br_re_method"] = this.br_re_method;
        data["us_id_accept"] = this.us_id_accept;
        data["br_re_is_delete"] = this.br_re_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["br_re_extend_note"] = this.br_re_extend_note;
        data["br_re_due_date"] = this.br_re_due_date ? this.br_re_due_date.toISOString() : <any>undefined;
        data["br_re_accept_at"] = this.br_re_accept_at ? this.br_re_accept_at.toISOString() : <any>undefined;
        data["br_re_return_at"] = this.br_re_return_at ? this.br_re_return_at.toISOString() : <any>undefined;
        data["br_re_delete_at"] = this.br_re_delete_at ? this.br_re_delete_at.toISOString() : <any>undefined;
        data["br_re_updated_at"] = this.br_re_updated_at ? this.br_re_updated_at.toISOString() : <any>undefined;
        data["br_re_created_at"] = this.br_re_created_at ? this.br_re_created_at.toISOString() : <any>undefined;
        if (Array.isArray(this.list_borrow)) {
            data["list_borrow"] = [];
            for (let item of this.list_borrow)
                data["list_borrow"].push(item.toJSON());
        }
        return data;
    }

    clone(): BorrowReturningDetailsWithListDocumentDto {
        const json = this.toJSON();
        let result = new BorrowReturningDetailsWithListDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningDetailsWithListDocumentDto {
    br_re_id: number;
    br_re_code: string | undefined;
    br_re_desc: string | undefined;
    br_re_nr_document: number;
    br_re_money_borrow: number;
    us_id_borrow: number;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    br_re_status: BorrowReturningProcess;
    br_re_method: BorrowMethod;
    us_id_accept: number;
    br_re_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    fi_id_arr: AttachmentItem[] | undefined;
    br_re_extend_note: string | undefined;
    br_re_due_date: Date | undefined;
    br_re_accept_at: Date | undefined;
    br_re_return_at: Date | undefined;
    br_re_delete_at: Date | undefined;
    br_re_updated_at: Date;
    br_re_created_at: Date;
    list_borrow: BorrowReturningIDetailDto[] | undefined;
}

export class BorrowReturningDto implements IBorrowReturningDto {
    br_re_id!: number;
    br_re_code!: string | undefined;
    br_re_desc!: string | undefined;
    br_re_nr_document!: number;
    br_re_money_borrow!: number;
    us_id_borrow!: number;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    br_re_status!: BorrowReturningProcess;
    br_re_method!: BorrowMethod;
    us_id_accept!: number;
    br_re_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    fi_id_arr!: AttachmentItem[] | undefined;
    br_re_extend_note!: string | undefined;
    br_re_due_date!: Date | undefined;
    br_re_accept_at!: Date | undefined;
    br_re_return_at!: Date | undefined;
    br_re_delete_at!: Date | undefined;
    br_re_updated_at!: Date;
    br_re_created_at!: Date;

    constructor(data?: IBorrowReturningDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_id = _data["br_re_id"];
            this.br_re_code = _data["br_re_code"];
            this.br_re_desc = _data["br_re_desc"];
            this.br_re_nr_document = _data["br_re_nr_document"];
            this.br_re_money_borrow = _data["br_re_money_borrow"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            this.br_re_status = _data["br_re_status"];
            this.br_re_method = _data["br_re_method"];
            this.us_id_accept = _data["us_id_accept"];
            this.br_re_is_delete = _data["br_re_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.br_re_extend_note = _data["br_re_extend_note"];
            this.br_re_due_date = _data["br_re_due_date"] ? new Date(_data["br_re_due_date"].toString()) : <any>undefined;
            this.br_re_accept_at = _data["br_re_accept_at"] ? new Date(_data["br_re_accept_at"].toString()) : <any>undefined;
            this.br_re_return_at = _data["br_re_return_at"] ? new Date(_data["br_re_return_at"].toString()) : <any>undefined;
            this.br_re_delete_at = _data["br_re_delete_at"] ? new Date(_data["br_re_delete_at"].toString()) : <any>undefined;
            this.br_re_updated_at = _data["br_re_updated_at"] ? new Date(_data["br_re_updated_at"].toString()) : <any>undefined;
            this.br_re_created_at = _data["br_re_created_at"] ? new Date(_data["br_re_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BorrowReturningDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_id"] = this.br_re_id;
        data["br_re_code"] = this.br_re_code;
        data["br_re_desc"] = this.br_re_desc;
        data["br_re_nr_document"] = this.br_re_nr_document;
        data["br_re_money_borrow"] = this.br_re_money_borrow;
        data["us_id_borrow"] = this.us_id_borrow;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        data["br_re_status"] = this.br_re_status;
        data["br_re_method"] = this.br_re_method;
        data["us_id_accept"] = this.us_id_accept;
        data["br_re_is_delete"] = this.br_re_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["br_re_extend_note"] = this.br_re_extend_note;
        data["br_re_due_date"] = this.br_re_due_date ? this.br_re_due_date.toISOString() : <any>undefined;
        data["br_re_accept_at"] = this.br_re_accept_at ? this.br_re_accept_at.toISOString() : <any>undefined;
        data["br_re_return_at"] = this.br_re_return_at ? this.br_re_return_at.toISOString() : <any>undefined;
        data["br_re_delete_at"] = this.br_re_delete_at ? this.br_re_delete_at.toISOString() : <any>undefined;
        data["br_re_updated_at"] = this.br_re_updated_at ? this.br_re_updated_at.toISOString() : <any>undefined;
        data["br_re_created_at"] = this.br_re_created_at ? this.br_re_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): BorrowReturningDto {
        const json = this.toJSON();
        let result = new BorrowReturningDto();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningDto {
    br_re_id: number;
    br_re_code: string | undefined;
    br_re_desc: string | undefined;
    br_re_nr_document: number;
    br_re_money_borrow: number;
    us_id_borrow: number;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    br_re_status: BorrowReturningProcess;
    br_re_method: BorrowMethod;
    us_id_accept: number;
    br_re_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    fi_id_arr: AttachmentItem[] | undefined;
    br_re_extend_note: string | undefined;
    br_re_due_date: Date | undefined;
    br_re_accept_at: Date | undefined;
    br_re_return_at: Date | undefined;
    br_re_delete_at: Date | undefined;
    br_re_updated_at: Date;
    br_re_created_at: Date;
}

export class BorrowReturningDtoPagedResultDto implements IBorrowReturningDtoPagedResultDto {
    items!: BorrowReturningDto[] | undefined;
    totalCount!: number;

    constructor(data?: IBorrowReturningDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BorrowReturningDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BorrowReturningDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BorrowReturningDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BorrowReturningDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningDtoPagedResultDto {
    items: BorrowReturningDto[] | undefined;
    totalCount: number;
}

export class BorrowReturningIDetailDto implements IBorrowReturningIDetailDto {
    br_re_de_id!: number;
    br_re_id!: number;
    do_id!: number;
    br_re_de_money_document!: number;
    document!: DocumentDto;
    do_in_id!: number;
    documentInfor!: DocumentInforDto;
    us_id_borrow!: number;
    us_id_created!: number;
    br_re_de_return_at!: Date | undefined;
    br_re_de_no_adjourn!: number;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    br_re_status!: BorrowReturningDetailStatus;

    constructor(data?: IBorrowReturningIDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_de_id = _data["br_re_de_id"];
            this.br_re_id = _data["br_re_id"];
            this.do_id = _data["do_id"];
            this.br_re_de_money_document = _data["br_re_de_money_document"];
            this.document = _data["document"] ? DocumentDto.fromJS(_data["document"]) : <any>undefined;
            this.do_in_id = _data["do_in_id"];
            this.documentInfor = _data["documentInfor"] ? DocumentInforDto.fromJS(_data["documentInfor"]) : <any>undefined;
            this.us_id_borrow = _data["us_id_borrow"];
            this.us_id_created = _data["us_id_created"];
            this.br_re_de_return_at = _data["br_re_de_return_at"] ? new Date(_data["br_re_de_return_at"].toString()) : <any>undefined;
            this.br_re_de_no_adjourn = _data["br_re_de_no_adjourn"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            this.br_re_status = _data["br_re_status"];
        }
    }

    static fromJS(data: any): BorrowReturningIDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningIDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_de_id"] = this.br_re_de_id;
        data["br_re_id"] = this.br_re_id;
        data["do_id"] = this.do_id;
        data["br_re_de_money_document"] = this.br_re_de_money_document;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["do_in_id"] = this.do_in_id;
        data["documentInfor"] = this.documentInfor ? this.documentInfor.toJSON() : <any>undefined;
        data["us_id_borrow"] = this.us_id_borrow;
        data["us_id_created"] = this.us_id_created;
        data["br_re_de_return_at"] = this.br_re_de_return_at ? this.br_re_de_return_at.toISOString() : <any>undefined;
        data["br_re_de_no_adjourn"] = this.br_re_de_no_adjourn;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        data["br_re_status"] = this.br_re_status;
        return data;
    }

    clone(): BorrowReturningIDetailDto {
        const json = this.toJSON();
        let result = new BorrowReturningIDetailDto();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningIDetailDto {
    br_re_de_id: number;
    br_re_id: number;
    do_id: number;
    br_re_de_money_document: number;
    document: DocumentDto;
    do_in_id: number;
    documentInfor: DocumentInforDto;
    us_id_borrow: number;
    us_id_created: number;
    br_re_de_return_at: Date | undefined;
    br_re_de_no_adjourn: number;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    br_re_status: BorrowReturningDetailStatus;
}

export class BorrowReturningIDetailDtoPagedResultDto implements IBorrowReturningIDetailDtoPagedResultDto {
    items!: BorrowReturningIDetailDto[] | undefined;
    totalCount!: number;

    constructor(data?: IBorrowReturningIDetailDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BorrowReturningIDetailDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BorrowReturningIDetailDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningIDetailDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BorrowReturningIDetailDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BorrowReturningIDetailDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningIDetailDtoPagedResultDto {
    items: BorrowReturningIDetailDto[] | undefined;
    totalCount: number;
}

export class BorrowReturningLog implements IBorrowReturningLog {
    id!: number;
    readonly br_re_lo_id!: number;
    br_re_id!: number;
    us_id_borrow!: number;
    br_re_lo_desc!: string | undefined;
    br_re_lo_obj!: string | undefined;
    br_re_lo_obj_type!: string | undefined;
    br_re_lo_type!: BorrowReturnLogType;
    us_id_created!: number;
    br_re_lo_created_at!: Date;

    constructor(data?: IBorrowReturningLog) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).br_re_lo_id = _data["br_re_lo_id"];
            this.br_re_id = _data["br_re_id"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.br_re_lo_desc = _data["br_re_lo_desc"];
            this.br_re_lo_obj = _data["br_re_lo_obj"];
            this.br_re_lo_obj_type = _data["br_re_lo_obj_type"];
            this.br_re_lo_type = _data["br_re_lo_type"];
            this.us_id_created = _data["us_id_created"];
            this.br_re_lo_created_at = _data["br_re_lo_created_at"] ? new Date(_data["br_re_lo_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BorrowReturningLog {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningLog();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["br_re_lo_id"] = this.br_re_lo_id;
        data["br_re_id"] = this.br_re_id;
        data["us_id_borrow"] = this.us_id_borrow;
        data["br_re_lo_desc"] = this.br_re_lo_desc;
        data["br_re_lo_obj"] = this.br_re_lo_obj;
        data["br_re_lo_obj_type"] = this.br_re_lo_obj_type;
        data["br_re_lo_type"] = this.br_re_lo_type;
        data["us_id_created"] = this.us_id_created;
        data["br_re_lo_created_at"] = this.br_re_lo_created_at ? this.br_re_lo_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): BorrowReturningLog {
        const json = this.toJSON();
        let result = new BorrowReturningLog();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningLog {
    id: number;
    br_re_lo_id: number;
    br_re_id: number;
    us_id_borrow: number;
    br_re_lo_desc: string | undefined;
    br_re_lo_obj: string | undefined;
    br_re_lo_obj_type: string | undefined;
    br_re_lo_type: BorrowReturnLogType;
    us_id_created: number;
    br_re_lo_created_at: Date;
}

export class BorrowReturningLogDto implements IBorrowReturningLogDto {
    br_re_lo_id!: number;
    br_re_id!: number;
    us_id_borrow!: number;
    br_re_lo_desc!: string | undefined;
    br_re_lo_obj!: string | undefined;
    br_re_lo_type!: BorrowReturnLogType;
    us_id_created!: number;
    br_re_lo_created_at!: Date;

    constructor(data?: IBorrowReturningLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_lo_id = _data["br_re_lo_id"];
            this.br_re_id = _data["br_re_id"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.br_re_lo_desc = _data["br_re_lo_desc"];
            this.br_re_lo_obj = _data["br_re_lo_obj"];
            this.br_re_lo_type = _data["br_re_lo_type"];
            this.us_id_created = _data["us_id_created"];
            this.br_re_lo_created_at = _data["br_re_lo_created_at"] ? new Date(_data["br_re_lo_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BorrowReturningLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_lo_id"] = this.br_re_lo_id;
        data["br_re_id"] = this.br_re_id;
        data["us_id_borrow"] = this.us_id_borrow;
        data["br_re_lo_desc"] = this.br_re_lo_desc;
        data["br_re_lo_obj"] = this.br_re_lo_obj;
        data["br_re_lo_type"] = this.br_re_lo_type;
        data["us_id_created"] = this.us_id_created;
        data["br_re_lo_created_at"] = this.br_re_lo_created_at ? this.br_re_lo_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): BorrowReturningLogDto {
        const json = this.toJSON();
        let result = new BorrowReturningLogDto();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningLogDto {
    br_re_lo_id: number;
    br_re_id: number;
    us_id_borrow: number;
    br_re_lo_desc: string | undefined;
    br_re_lo_obj: string | undefined;
    br_re_lo_type: BorrowReturnLogType;
    us_id_created: number;
    br_re_lo_created_at: Date;
}

export class BorrowReturningLogDtoPagedResultDto implements IBorrowReturningLogDtoPagedResultDto {
    items!: BorrowReturningLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IBorrowReturningLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BorrowReturningLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): BorrowReturningLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new BorrowReturningLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): BorrowReturningLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new BorrowReturningLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IBorrowReturningLogDtoPagedResultDto {
    items: BorrowReturningLogDto[] | undefined;
    totalCount: number;
}

export enum BorrowReturningProcess {
    _0 = 0,
    _10 = 10,
    _20 = 20,
    _30 = 30,
    _40 = 40,
    _50 = 50,
    _60 = 60,
    _70 = 70,
    _80 = 80,
}

export class CancelBorrowReturningInput implements ICancelBorrowReturningInput {
    br_re_id!: number;
    br_re_desc!: string | undefined;

    constructor(data?: ICancelBorrowReturningInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_id = _data["br_re_id"];
            this.br_re_desc = _data["br_re_desc"];
        }
    }

    static fromJS(data: any): CancelBorrowReturningInput {
        data = typeof data === 'object' ? data : {};
        let result = new CancelBorrowReturningInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_id"] = this.br_re_id;
        data["br_re_desc"] = this.br_re_desc;
        return data;
    }

    clone(): CancelBorrowReturningInput {
        const json = this.toJSON();
        let result = new CancelBorrowReturningInput();
        result.init(json);
        return result;
    }
}

export interface ICancelBorrowReturningInput {
    br_re_id: number;
    br_re_desc: string | undefined;
}

export class CatalogingDto implements ICatalogingDto {
    cata_id!: number;
    do_in_id!: number;
    do_id!: number;
    document!: ItemDocument;
    dkcb_code!: string | undefined;
    cata_content!: string | undefined;
    cata_resultDDC!: string | undefined;
    cata_resultTitle!: string | undefined;
    cata_resultColor!: string | undefined;
    cata_is_delete!: boolean;
    cata_created_at!: Date;
    cata_updated_at!: Date;

    constructor(data?: ICatalogingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cata_id = _data["cata_id"];
            this.do_in_id = _data["do_in_id"];
            this.do_id = _data["do_id"];
            this.document = _data["document"] ? ItemDocument.fromJS(_data["document"]) : <any>undefined;
            this.dkcb_code = _data["dkcb_code"];
            this.cata_content = _data["cata_content"];
            this.cata_resultDDC = _data["cata_resultDDC"];
            this.cata_resultTitle = _data["cata_resultTitle"];
            this.cata_resultColor = _data["cata_resultColor"];
            this.cata_is_delete = _data["cata_is_delete"];
            this.cata_created_at = _data["cata_created_at"] ? new Date(_data["cata_created_at"].toString()) : <any>undefined;
            this.cata_updated_at = _data["cata_updated_at"] ? new Date(_data["cata_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CatalogingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cata_id"] = this.cata_id;
        data["do_in_id"] = this.do_in_id;
        data["do_id"] = this.do_id;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["dkcb_code"] = this.dkcb_code;
        data["cata_content"] = this.cata_content;
        data["cata_resultDDC"] = this.cata_resultDDC;
        data["cata_resultTitle"] = this.cata_resultTitle;
        data["cata_resultColor"] = this.cata_resultColor;
        data["cata_is_delete"] = this.cata_is_delete;
        data["cata_created_at"] = this.cata_created_at ? this.cata_created_at.toISOString() : <any>undefined;
        data["cata_updated_at"] = this.cata_updated_at ? this.cata_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): CatalogingDto {
        const json = this.toJSON();
        let result = new CatalogingDto();
        result.init(json);
        return result;
    }
}

export interface ICatalogingDto {
    cata_id: number;
    do_in_id: number;
    do_id: number;
    document: ItemDocument;
    dkcb_code: string | undefined;
    cata_content: string | undefined;
    cata_resultDDC: string | undefined;
    cata_resultTitle: string | undefined;
    cata_resultColor: string | undefined;
    cata_is_delete: boolean;
    cata_created_at: Date;
    cata_updated_at: Date;
}

export class CatalogingDtoPagedResultDto implements ICatalogingDtoPagedResultDto {
    items!: CatalogingDto[] | undefined;
    totalCount!: number;

    constructor(data?: ICatalogingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CatalogingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CatalogingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CatalogingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CatalogingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CatalogingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICatalogingDtoPagedResultDto {
    items: CatalogingDto[] | undefined;
    totalCount: number;
}

export class CategoryAbtractDto implements ICategoryAbtractDto {
    ca_id!: number;
    ca_title!: string | undefined;
    dkcb_code!: string | undefined;
    dkcb_current!: number;
    dkcb_start!: number;
    ca_abstract!: string | undefined;
    ca_id_parent!: number;
    ca_enable!: boolean;

    constructor(data?: ICategoryAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ca_id = _data["ca_id"];
            this.ca_title = _data["ca_title"];
            this.dkcb_code = _data["dkcb_code"];
            this.dkcb_current = _data["dkcb_current"];
            this.dkcb_start = _data["dkcb_start"];
            this.ca_abstract = _data["ca_abstract"];
            this.ca_id_parent = _data["ca_id_parent"];
            this.ca_enable = _data["ca_enable"];
        }
    }

    static fromJS(data: any): CategoryAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ca_id"] = this.ca_id;
        data["ca_title"] = this.ca_title;
        data["dkcb_code"] = this.dkcb_code;
        data["dkcb_current"] = this.dkcb_current;
        data["dkcb_start"] = this.dkcb_start;
        data["ca_abstract"] = this.ca_abstract;
        data["ca_id_parent"] = this.ca_id_parent;
        data["ca_enable"] = this.ca_enable;
        return data;
    }

    clone(): CategoryAbtractDto {
        const json = this.toJSON();
        let result = new CategoryAbtractDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryAbtractDto {
    ca_id: number;
    ca_title: string | undefined;
    dkcb_code: string | undefined;
    dkcb_current: number;
    dkcb_start: number;
    ca_abstract: string | undefined;
    ca_id_parent: number;
    ca_enable: boolean;
}

export class CategoryDto implements ICategoryDto {
    ca_id!: number;
    ca_title!: string | undefined;
    dkcb_code!: string | undefined;
    dkcb_current!: number;
    dkcb_start!: number;
    ca_abstract!: string | undefined;
    ca_id_parent!: number;
    ca_sort!: number;
    ca_enable!: boolean;
    do_id_arr!: number[] | undefined;
    us_id_created!: number;
    ca_updated_at!: Date;
    ca_created_at!: Date;

    constructor(data?: ICategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ca_id = _data["ca_id"];
            this.ca_title = _data["ca_title"];
            this.dkcb_code = _data["dkcb_code"];
            this.dkcb_current = _data["dkcb_current"];
            this.dkcb_start = _data["dkcb_start"];
            this.ca_abstract = _data["ca_abstract"];
            this.ca_id_parent = _data["ca_id_parent"];
            this.ca_sort = _data["ca_sort"];
            this.ca_enable = _data["ca_enable"];
            if (Array.isArray(_data["do_id_arr"])) {
                this.do_id_arr = [] as any;
                for (let item of _data["do_id_arr"])
                    this.do_id_arr!.push(item);
            }
            this.us_id_created = _data["us_id_created"];
            this.ca_updated_at = _data["ca_updated_at"] ? new Date(_data["ca_updated_at"].toString()) : <any>undefined;
            this.ca_created_at = _data["ca_created_at"] ? new Date(_data["ca_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ca_id"] = this.ca_id;
        data["ca_title"] = this.ca_title;
        data["dkcb_code"] = this.dkcb_code;
        data["dkcb_current"] = this.dkcb_current;
        data["dkcb_start"] = this.dkcb_start;
        data["ca_abstract"] = this.ca_abstract;
        data["ca_id_parent"] = this.ca_id_parent;
        data["ca_sort"] = this.ca_sort;
        data["ca_enable"] = this.ca_enable;
        if (Array.isArray(this.do_id_arr)) {
            data["do_id_arr"] = [];
            for (let item of this.do_id_arr)
                data["do_id_arr"].push(item);
        }
        data["us_id_created"] = this.us_id_created;
        data["ca_updated_at"] = this.ca_updated_at ? this.ca_updated_at.toISOString() : <any>undefined;
        data["ca_created_at"] = this.ca_created_at ? this.ca_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): CategoryDto {
        const json = this.toJSON();
        let result = new CategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDto {
    ca_id: number;
    ca_title: string | undefined;
    dkcb_code: string | undefined;
    dkcb_current: number;
    dkcb_start: number;
    ca_abstract: string | undefined;
    ca_id_parent: number;
    ca_sort: number;
    ca_enable: boolean;
    do_id_arr: number[] | undefined;
    us_id_created: number;
    ca_updated_at: Date;
    ca_created_at: Date;
}

export class CategoryDtoListResultDto implements ICategoryDtoListResultDto {
    items!: CategoryDto[] | undefined;

    constructor(data?: ICategoryDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CategoryDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): CategoryDtoListResultDto {
        const json = this.toJSON();
        let result = new CategoryDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface ICategoryDtoListResultDto {
    items: CategoryDto[] | undefined;
}

export class ChangeParentFileOfUserInput implements IChangeParentFileOfUserInput {
    fi_us_id!: number;
    fo_id!: number;

    constructor(data?: IChangeParentFileOfUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_us_id = _data["fi_us_id"];
            this.fo_id = _data["fo_id"];
        }
    }

    static fromJS(data: any): ChangeParentFileOfUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeParentFileOfUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_us_id"] = this.fi_us_id;
        data["fo_id"] = this.fo_id;
        return data;
    }

    clone(): ChangeParentFileOfUserInput {
        const json = this.toJSON();
        let result = new ChangeParentFileOfUserInput();
        result.init(json);
        return result;
    }
}

export interface IChangeParentFileOfUserInput {
    fi_us_id: number;
    fo_id: number;
}

export class ChangeParentFolderInput implements IChangeParentFolderInput {
    fo_id!: number;
    fo_id_parent!: number;

    constructor(data?: IChangeParentFolderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_id = _data["fo_id"];
            this.fo_id_parent = _data["fo_id_parent"];
        }
    }

    static fromJS(data: any): ChangeParentFolderInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeParentFolderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_id"] = this.fo_id;
        data["fo_id_parent"] = this.fo_id_parent;
        return data;
    }

    clone(): ChangeParentFolderInput {
        const json = this.toJSON();
        let result = new ChangeParentFolderInput();
        result.init(json);
        return result;
    }
}

export interface IChangeParentFolderInput {
    fo_id: number;
    fo_id_parent: number;
}

export class ChangePassWordMemberInput implements IChangePassWordMemberInput {
    me_id!: number;
    newPassword!: string;

    constructor(data?: IChangePassWordMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePassWordMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePassWordMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ChangePassWordMemberInput {
        const json = this.toJSON();
        let result = new ChangePassWordMemberInput();
        result.init(json);
        return result;
    }
}

export interface IChangePassWordMemberInput {
    me_id: number;
    newPassword: string;
}

export class ChangePassword2Dto implements IChangePassword2Dto {
    currentPassword!: string;
    newPassword!: string;
    user_id!: number;

    constructor(data?: IChangePassword2Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.user_id = _data["user_id"];
        }
    }

    static fromJS(data: any): ChangePassword2Dto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePassword2Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["user_id"] = this.user_id;
        return data;
    }

    clone(): ChangePassword2Dto {
        const json = this.toJSON();
        let result = new ChangePassword2Dto();
        result.init(json);
        return result;
    }
}

export interface IChangePassword2Dto {
    currentPassword: string;
    newPassword: string;
    user_id: number;
}

export class ChangePasswordDto implements IChangePasswordDto {
    currentPassword!: string;
    newPassword!: string;
    user_id!: number;

    constructor(data?: IChangePasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.user_id = _data["user_id"];
        }
    }

    static fromJS(data: any): ChangePasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["user_id"] = this.user_id;
        return data;
    }

    clone(): ChangePasswordDto {
        const json = this.toJSON();
        let result = new ChangePasswordDto();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordDto {
    currentPassword: string;
    newPassword: string;
    user_id: number;
}

export class ChangeProcessCheckInput implements IChangeProcessCheckInput {
    ck_id!: number;
    ck_process!: CheckProcess;

    constructor(data?: IChangeProcessCheckInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ck_id = _data["ck_id"];
            this.ck_process = _data["ck_process"];
        }
    }

    static fromJS(data: any): ChangeProcessCheckInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeProcessCheckInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ck_id"] = this.ck_id;
        data["ck_process"] = this.ck_process;
        return data;
    }

    clone(): ChangeProcessCheckInput {
        const json = this.toJSON();
        let result = new ChangeProcessCheckInput();
        result.init(json);
        return result;
    }
}

export interface IChangeProcessCheckInput {
    ck_id: number;
    ck_process: CheckProcess;
}

export class ChangeProcessPlanInput implements IChangeProcessPlanInput {
    pl_id!: number;
    pl_process!: PlanProcess;

    constructor(data?: IChangeProcessPlanInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_id = _data["pl_id"];
            this.pl_process = _data["pl_process"];
        }
    }

    static fromJS(data: any): ChangeProcessPlanInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeProcessPlanInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_id"] = this.pl_id;
        data["pl_process"] = this.pl_process;
        return data;
    }

    clone(): ChangeProcessPlanInput {
        const json = this.toJSON();
        let result = new ChangeProcessPlanInput();
        result.init(json);
        return result;
    }
}

export interface IChangeProcessPlanInput {
    pl_id: number;
    pl_process: PlanProcess;
}

export class ChangeStatusDocumentInforCheckInput implements IChangeStatusDocumentInforCheckInput {
    do_in_id!: number;
    ck_it_id!: number;
    do_in_status!: DocumentItemStatus;

    constructor(data?: IChangeStatusDocumentInforCheckInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_in_id = _data["do_in_id"];
            this.ck_it_id = _data["ck_it_id"];
            this.do_in_status = _data["do_in_status"];
        }
    }

    static fromJS(data: any): ChangeStatusDocumentInforCheckInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStatusDocumentInforCheckInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_in_id"] = this.do_in_id;
        data["ck_it_id"] = this.ck_it_id;
        data["do_in_status"] = this.do_in_status;
        return data;
    }

    clone(): ChangeStatusDocumentInforCheckInput {
        const json = this.toJSON();
        let result = new ChangeStatusDocumentInforCheckInput();
        result.init(json);
        return result;
    }
}

export interface IChangeStatusDocumentInforCheckInput {
    do_in_id: number;
    ck_it_id: number;
    do_in_status: DocumentItemStatus;
}

export class ChangeStatusMemberInput implements IChangeStatusMemberInput {
    me_id!: number;
    me_status!: MemberRegisterStatus;

    constructor(data?: IChangeStatusMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_status = _data["me_status"];
        }
    }

    static fromJS(data: any): ChangeStatusMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeStatusMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_status"] = this.me_status;
        return data;
    }

    clone(): ChangeStatusMemberInput {
        const json = this.toJSON();
        let result = new ChangeStatusMemberInput();
        result.init(json);
        return result;
    }
}

export interface IChangeStatusMemberInput {
    me_id: number;
    me_status: MemberRegisterStatus;
}

export class ChangeTypeFileOfUserInput implements IChangeTypeFileOfUserInput {
    fi_us_id!: number;
    fi_ro_type!: ResourceRoleType;

    constructor(data?: IChangeTypeFileOfUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_us_id = _data["fi_us_id"];
            this.fi_ro_type = _data["fi_ro_type"];
        }
    }

    static fromJS(data: any): ChangeTypeFileOfUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeTypeFileOfUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_us_id"] = this.fi_us_id;
        data["fi_ro_type"] = this.fi_ro_type;
        return data;
    }

    clone(): ChangeTypeFileOfUserInput {
        const json = this.toJSON();
        let result = new ChangeTypeFileOfUserInput();
        result.init(json);
        return result;
    }
}

export interface IChangeTypeFileOfUserInput {
    fi_us_id: number;
    fi_ro_type: ResourceRoleType;
}

export class ChangeTypeFolderInput implements IChangeTypeFolderInput {
    fo_id!: number;
    fo_ro_type!: ResourceRoleType;

    constructor(data?: IChangeTypeFolderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_id = _data["fo_id"];
            this.fo_ro_type = _data["fo_ro_type"];
        }
    }

    static fromJS(data: any): ChangeTypeFolderInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeTypeFolderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_id"] = this.fo_id;
        data["fo_ro_type"] = this.fo_ro_type;
        return data;
    }

    clone(): ChangeTypeFolderInput {
        const json = this.toJSON();
        let result = new ChangeTypeFolderInput();
        result.init(json);
        return result;
    }
}

export interface IChangeTypeFolderInput {
    fo_id: number;
    fo_ro_type: ResourceRoleType;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme!: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data;
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ChartDashboardDto implements IChartDashboardDto {
    key!: string | undefined;
    name!: string | undefined;
    borrows!: number;
    returnings!: number;
    newMembers!: number;
    newMemberCard!: number;

    constructor(data?: IChartDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.borrows = _data["borrows"];
            this.returnings = _data["returnings"];
            this.newMembers = _data["newMembers"];
            this.newMemberCard = _data["newMemberCard"];
        }
    }

    static fromJS(data: any): ChartDashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChartDashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["borrows"] = this.borrows;
        data["returnings"] = this.returnings;
        data["newMembers"] = this.newMembers;
        data["newMemberCard"] = this.newMemberCard;
        return data;
    }

    clone(): ChartDashboardDto {
        const json = this.toJSON();
        let result = new ChartDashboardDto();
        result.init(json);
        return result;
    }
}

export interface IChartDashboardDto {
    key: string | undefined;
    name: string | undefined;
    borrows: number;
    returnings: number;
    newMembers: number;
    newMemberCard: number;
}

export class CheckDto implements ICheckDto {
    ck_id!: number;
    ck_name!: string | undefined;
    ck_code!: string | undefined;
    ck_desc!: string | undefined;
    ck_start_at!: Date | undefined;
    us_id_created!: number;
    us_id_participant!: ItemUser[] | undefined;
    us_id_approved!: number;
    ck_process!: CheckProcess;
    ck_note!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;
    ck_is_delete!: boolean;
    us_id_updated!: number;
    us_id_delete!: number;
    checkItems!: CheckItemDto[] | undefined;
    ck_delete_at!: Date | undefined;
    ck_updated_at!: Date;
    ck_created_at!: Date;

    constructor(data?: ICheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ck_id = _data["ck_id"];
            this.ck_name = _data["ck_name"];
            this.ck_code = _data["ck_code"];
            this.ck_desc = _data["ck_desc"];
            this.ck_start_at = _data["ck_start_at"] ? new Date(_data["ck_start_at"].toString()) : <any>undefined;
            this.us_id_created = _data["us_id_created"];
            if (Array.isArray(_data["us_id_participant"])) {
                this.us_id_participant = [] as any;
                for (let item of _data["us_id_participant"])
                    this.us_id_participant!.push(ItemUser.fromJS(item));
            }
            this.us_id_approved = _data["us_id_approved"];
            this.ck_process = _data["ck_process"];
            this.ck_note = _data["ck_note"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.ck_is_delete = _data["ck_is_delete"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            if (Array.isArray(_data["checkItems"])) {
                this.checkItems = [] as any;
                for (let item of _data["checkItems"])
                    this.checkItems!.push(CheckItemDto.fromJS(item));
            }
            this.ck_delete_at = _data["ck_delete_at"] ? new Date(_data["ck_delete_at"].toString()) : <any>undefined;
            this.ck_updated_at = _data["ck_updated_at"] ? new Date(_data["ck_updated_at"].toString()) : <any>undefined;
            this.ck_created_at = _data["ck_created_at"] ? new Date(_data["ck_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ck_id"] = this.ck_id;
        data["ck_name"] = this.ck_name;
        data["ck_code"] = this.ck_code;
        data["ck_desc"] = this.ck_desc;
        data["ck_start_at"] = this.ck_start_at ? this.ck_start_at.toISOString() : <any>undefined;
        data["us_id_created"] = this.us_id_created;
        if (Array.isArray(this.us_id_participant)) {
            data["us_id_participant"] = [];
            for (let item of this.us_id_participant)
                data["us_id_participant"].push(item.toJSON());
        }
        data["us_id_approved"] = this.us_id_approved;
        data["ck_process"] = this.ck_process;
        data["ck_note"] = this.ck_note;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["ck_is_delete"] = this.ck_is_delete;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        if (Array.isArray(this.checkItems)) {
            data["checkItems"] = [];
            for (let item of this.checkItems)
                data["checkItems"].push(item.toJSON());
        }
        data["ck_delete_at"] = this.ck_delete_at ? this.ck_delete_at.toISOString() : <any>undefined;
        data["ck_updated_at"] = this.ck_updated_at ? this.ck_updated_at.toISOString() : <any>undefined;
        data["ck_created_at"] = this.ck_created_at ? this.ck_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): CheckDto {
        const json = this.toJSON();
        let result = new CheckDto();
        result.init(json);
        return result;
    }
}

export interface ICheckDto {
    ck_id: number;
    ck_name: string | undefined;
    ck_code: string | undefined;
    ck_desc: string | undefined;
    ck_start_at: Date | undefined;
    us_id_created: number;
    us_id_participant: ItemUser[] | undefined;
    us_id_approved: number;
    ck_process: CheckProcess;
    ck_note: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
    ck_is_delete: boolean;
    us_id_updated: number;
    us_id_delete: number;
    checkItems: CheckItemDto[] | undefined;
    ck_delete_at: Date | undefined;
    ck_updated_at: Date;
    ck_created_at: Date;
}

export class CheckDtoPagedResultDto implements ICheckDtoPagedResultDto {
    items!: CheckDto[] | undefined;
    totalCount!: number;

    constructor(data?: ICheckDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CheckDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CheckDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CheckDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CheckDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICheckDtoPagedResultDto {
    items: CheckDto[] | undefined;
    totalCount: number;
}

export class CheckItemDto implements ICheckItemDto {
    ck_it_id!: number;
    ck_id!: number;
    do_id!: ItemDocument;
    us_id_created!: number;
    us_id_check!: ItemUser;
    ck_it_status!: CheckItemStatus;
    ck_it_note!: string | undefined;
    do_in_id_borrow!: number[] | undefined;
    do_in_id_valid!: number[] | undefined;
    do_in_id_invalid!: number[] | undefined;
    do_in_id_lost!: number[] | undefined;
    ck_it_updated_at!: Date;
    ck_it_created_at!: Date;

    constructor(data?: ICheckItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ck_it_id = _data["ck_it_id"];
            this.ck_id = _data["ck_id"];
            this.do_id = _data["do_id"] ? ItemDocument.fromJS(_data["do_id"]) : <any>undefined;
            this.us_id_created = _data["us_id_created"];
            this.us_id_check = _data["us_id_check"] ? ItemUser.fromJS(_data["us_id_check"]) : <any>undefined;
            this.ck_it_status = _data["ck_it_status"];
            this.ck_it_note = _data["ck_it_note"];
            if (Array.isArray(_data["do_in_id_borrow"])) {
                this.do_in_id_borrow = [] as any;
                for (let item of _data["do_in_id_borrow"])
                    this.do_in_id_borrow!.push(item);
            }
            if (Array.isArray(_data["do_in_id_valid"])) {
                this.do_in_id_valid = [] as any;
                for (let item of _data["do_in_id_valid"])
                    this.do_in_id_valid!.push(item);
            }
            if (Array.isArray(_data["do_in_id_invalid"])) {
                this.do_in_id_invalid = [] as any;
                for (let item of _data["do_in_id_invalid"])
                    this.do_in_id_invalid!.push(item);
            }
            if (Array.isArray(_data["do_in_id_lost"])) {
                this.do_in_id_lost = [] as any;
                for (let item of _data["do_in_id_lost"])
                    this.do_in_id_lost!.push(item);
            }
            this.ck_it_updated_at = _data["ck_it_updated_at"] ? new Date(_data["ck_it_updated_at"].toString()) : <any>undefined;
            this.ck_it_created_at = _data["ck_it_created_at"] ? new Date(_data["ck_it_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CheckItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ck_it_id"] = this.ck_it_id;
        data["ck_id"] = this.ck_id;
        data["do_id"] = this.do_id ? this.do_id.toJSON() : <any>undefined;
        data["us_id_created"] = this.us_id_created;
        data["us_id_check"] = this.us_id_check ? this.us_id_check.toJSON() : <any>undefined;
        data["ck_it_status"] = this.ck_it_status;
        data["ck_it_note"] = this.ck_it_note;
        if (Array.isArray(this.do_in_id_borrow)) {
            data["do_in_id_borrow"] = [];
            for (let item of this.do_in_id_borrow)
                data["do_in_id_borrow"].push(item);
        }
        if (Array.isArray(this.do_in_id_valid)) {
            data["do_in_id_valid"] = [];
            for (let item of this.do_in_id_valid)
                data["do_in_id_valid"].push(item);
        }
        if (Array.isArray(this.do_in_id_invalid)) {
            data["do_in_id_invalid"] = [];
            for (let item of this.do_in_id_invalid)
                data["do_in_id_invalid"].push(item);
        }
        if (Array.isArray(this.do_in_id_lost)) {
            data["do_in_id_lost"] = [];
            for (let item of this.do_in_id_lost)
                data["do_in_id_lost"].push(item);
        }
        data["ck_it_updated_at"] = this.ck_it_updated_at ? this.ck_it_updated_at.toISOString() : <any>undefined;
        data["ck_it_created_at"] = this.ck_it_created_at ? this.ck_it_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): CheckItemDto {
        const json = this.toJSON();
        let result = new CheckItemDto();
        result.init(json);
        return result;
    }
}

export interface ICheckItemDto {
    ck_it_id: number;
    ck_id: number;
    do_id: ItemDocument;
    us_id_created: number;
    us_id_check: ItemUser;
    ck_it_status: CheckItemStatus;
    ck_it_note: string | undefined;
    do_in_id_borrow: number[] | undefined;
    do_in_id_valid: number[] | undefined;
    do_in_id_invalid: number[] | undefined;
    do_in_id_lost: number[] | undefined;
    ck_it_updated_at: Date;
    ck_it_created_at: Date;
}

export class CheckItemDtoPagedResultDto implements ICheckItemDtoPagedResultDto {
    items!: CheckItemDto[] | undefined;
    totalCount!: number;

    constructor(data?: ICheckItemDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CheckItemDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CheckItemDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckItemDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CheckItemDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CheckItemDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICheckItemDtoPagedResultDto {
    items: CheckItemDto[] | undefined;
    totalCount: number;
}

export enum CheckItemStatus {
    _0 = 0,
    _1 = 1,
}

export class CheckPassword2Output implements ICheckPassword2Output {
    id!: number;
    password!: string | undefined;
    isCorrect!: boolean;

    constructor(data?: ICheckPassword2Output) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.password = _data["password"];
            this.isCorrect = _data["isCorrect"];
        }
    }

    static fromJS(data: any): CheckPassword2Output {
        data = typeof data === 'object' ? data : {};
        let result = new CheckPassword2Output();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["password"] = this.password;
        data["isCorrect"] = this.isCorrect;
        return data;
    }

    clone(): CheckPassword2Output {
        const json = this.toJSON();
        let result = new CheckPassword2Output();
        result.init(json);
        return result;
    }
}

export interface ICheckPassword2Output {
    id: number;
    password: string | undefined;
    isCorrect: boolean;
}

export enum CheckProcess {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
}

export class Citation implements ICitation {
    id!: number;
    readonly ci_id!: number;
    au_id_arr!: string | undefined;
    itemDocument!: string | undefined;
    ci_year_publish!: string | undefined;
    itemPublisher!: string | undefined;
    ci_place_publish!: string | undefined;
    ci_url!: string | undefined;
    ci_date_access!: Date | undefined;
    ci_type!: CitationType;
    ci_citation!: string | undefined;
    ci_structure!: CitationStructure;
    ci_is_delete!: boolean;
    us_id_created!: number;
    ci_updated_at!: Date;
    ci_created_at!: Date;

    constructor(data?: ICitation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).ci_id = _data["ci_id"];
            this.au_id_arr = _data["au_id_arr"];
            this.itemDocument = _data["itemDocument"];
            this.ci_year_publish = _data["ci_year_publish"];
            this.itemPublisher = _data["itemPublisher"];
            this.ci_place_publish = _data["ci_place_publish"];
            this.ci_url = _data["ci_url"];
            this.ci_date_access = _data["ci_date_access"] ? new Date(_data["ci_date_access"].toString()) : <any>undefined;
            this.ci_type = _data["ci_type"];
            this.ci_citation = _data["ci_citation"];
            this.ci_structure = _data["ci_structure"];
            this.ci_is_delete = _data["ci_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.ci_updated_at = _data["ci_updated_at"] ? new Date(_data["ci_updated_at"].toString()) : <any>undefined;
            this.ci_created_at = _data["ci_created_at"] ? new Date(_data["ci_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Citation {
        data = typeof data === 'object' ? data : {};
        let result = new Citation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ci_id"] = this.ci_id;
        data["au_id_arr"] = this.au_id_arr;
        data["itemDocument"] = this.itemDocument;
        data["ci_year_publish"] = this.ci_year_publish;
        data["itemPublisher"] = this.itemPublisher;
        data["ci_place_publish"] = this.ci_place_publish;
        data["ci_url"] = this.ci_url;
        data["ci_date_access"] = this.ci_date_access ? this.ci_date_access.toISOString() : <any>undefined;
        data["ci_type"] = this.ci_type;
        data["ci_citation"] = this.ci_citation;
        data["ci_structure"] = this.ci_structure;
        data["ci_is_delete"] = this.ci_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["ci_updated_at"] = this.ci_updated_at ? this.ci_updated_at.toISOString() : <any>undefined;
        data["ci_created_at"] = this.ci_created_at ? this.ci_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): Citation {
        const json = this.toJSON();
        let result = new Citation();
        result.init(json);
        return result;
    }
}

export interface ICitation {
    id: number;
    ci_id: number;
    au_id_arr: string | undefined;
    itemDocument: string | undefined;
    ci_year_publish: string | undefined;
    itemPublisher: string | undefined;
    ci_place_publish: string | undefined;
    ci_url: string | undefined;
    ci_date_access: Date | undefined;
    ci_type: CitationType;
    ci_citation: string | undefined;
    ci_structure: CitationStructure;
    ci_is_delete: boolean;
    us_id_created: number;
    ci_updated_at: Date;
    ci_created_at: Date;
}

export class CitationDto implements ICitationDto {
    ci_id!: number;
    au_id_arr!: ItemAuthor[] | undefined;
    itemDocument!: ItemDocument;
    itemPublisher!: ItemPublisher;
    ci_year_publish!: string | undefined;
    ci_place_publish!: string | undefined;
    ci_url!: string | undefined;
    ci_date_access!: Date | undefined;
    ci_type!: CitationType;
    ci_citation!: string | undefined;
    ci_structure!: CitationStructure;
    ci_is_delete!: boolean;
    us_id_created!: number;
    ci_updated_at!: Date;
    ci_created_at!: Date;

    constructor(data?: ICitationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ci_id = _data["ci_id"];
            if (Array.isArray(_data["au_id_arr"])) {
                this.au_id_arr = [] as any;
                for (let item of _data["au_id_arr"])
                    this.au_id_arr!.push(ItemAuthor.fromJS(item));
            }
            this.itemDocument = _data["itemDocument"] ? ItemDocument.fromJS(_data["itemDocument"]) : <any>undefined;
            this.itemPublisher = _data["itemPublisher"] ? ItemPublisher.fromJS(_data["itemPublisher"]) : <any>undefined;
            this.ci_year_publish = _data["ci_year_publish"];
            this.ci_place_publish = _data["ci_place_publish"];
            this.ci_url = _data["ci_url"];
            this.ci_date_access = _data["ci_date_access"] ? new Date(_data["ci_date_access"].toString()) : <any>undefined;
            this.ci_type = _data["ci_type"];
            this.ci_citation = _data["ci_citation"];
            this.ci_structure = _data["ci_structure"];
            this.ci_is_delete = _data["ci_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.ci_updated_at = _data["ci_updated_at"] ? new Date(_data["ci_updated_at"].toString()) : <any>undefined;
            this.ci_created_at = _data["ci_created_at"] ? new Date(_data["ci_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CitationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CitationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ci_id"] = this.ci_id;
        if (Array.isArray(this.au_id_arr)) {
            data["au_id_arr"] = [];
            for (let item of this.au_id_arr)
                data["au_id_arr"].push(item.toJSON());
        }
        data["itemDocument"] = this.itemDocument ? this.itemDocument.toJSON() : <any>undefined;
        data["itemPublisher"] = this.itemPublisher ? this.itemPublisher.toJSON() : <any>undefined;
        data["ci_year_publish"] = this.ci_year_publish;
        data["ci_place_publish"] = this.ci_place_publish;
        data["ci_url"] = this.ci_url;
        data["ci_date_access"] = this.ci_date_access ? this.ci_date_access.toISOString() : <any>undefined;
        data["ci_type"] = this.ci_type;
        data["ci_citation"] = this.ci_citation;
        data["ci_structure"] = this.ci_structure;
        data["ci_is_delete"] = this.ci_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["ci_updated_at"] = this.ci_updated_at ? this.ci_updated_at.toISOString() : <any>undefined;
        data["ci_created_at"] = this.ci_created_at ? this.ci_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): CitationDto {
        const json = this.toJSON();
        let result = new CitationDto();
        result.init(json);
        return result;
    }
}

export interface ICitationDto {
    ci_id: number;
    au_id_arr: ItemAuthor[] | undefined;
    itemDocument: ItemDocument;
    itemPublisher: ItemPublisher;
    ci_year_publish: string | undefined;
    ci_place_publish: string | undefined;
    ci_url: string | undefined;
    ci_date_access: Date | undefined;
    ci_type: CitationType;
    ci_citation: string | undefined;
    ci_structure: CitationStructure;
    ci_is_delete: boolean;
    us_id_created: number;
    ci_updated_at: Date;
    ci_created_at: Date;
}

export class CitationDtoPagedResultDto implements ICitationDtoPagedResultDto {
    items!: CitationDto[] | undefined;
    totalCount!: number;

    constructor(data?: ICitationDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CitationDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): CitationDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new CitationDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): CitationDtoPagedResultDto {
        const json = this.toJSON();
        let result = new CitationDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ICitationDtoPagedResultDto {
    items: CitationDto[] | undefined;
    totalCount: number;
}

export enum CitationStructure {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum CitationType {
    _10 = 10,
    _20 = 20,
    _30 = 30,
}

export class ConfirmPlanDoneInput implements IConfirmPlanDoneInput {
    pl_id!: number;

    constructor(data?: IConfirmPlanDoneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_id = _data["pl_id"];
        }
    }

    static fromJS(data: any): ConfirmPlanDoneInput {
        data = typeof data === 'object' ? data : {};
        let result = new ConfirmPlanDoneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_id"] = this.pl_id;
        return data;
    }

    clone(): ConfirmPlanDoneInput {
        const json = this.toJSON();
        let result = new ConfirmPlanDoneInput();
        result.init(json);
        return result;
    }
}

export interface IConfirmPlanDoneInput {
    pl_id: number;
}

export class ContractDto implements IContractDto {
    co_id!: number;
    co_code!: string | undefined;
    co_name!: string | undefined;
    co_desc!: string | undefined;
    co_status!: ContractStatus;
    fi_id_arr!: AttachmentItem[] | undefined;
    pl_id!: number;
    us_id_accept!: number;
    co_signed_at!: Date;
    su_id!: number;
    us_id_created!: number;
    us_id_updated!: number;
    co_updated_at!: Date;
    co_created_at!: Date;

    constructor(data?: IContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.co_id = _data["co_id"];
            this.co_code = _data["co_code"];
            this.co_name = _data["co_name"];
            this.co_desc = _data["co_desc"];
            this.co_status = _data["co_status"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.pl_id = _data["pl_id"];
            this.us_id_accept = _data["us_id_accept"];
            this.co_signed_at = _data["co_signed_at"] ? new Date(_data["co_signed_at"].toString()) : <any>undefined;
            this.su_id = _data["su_id"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.co_updated_at = _data["co_updated_at"] ? new Date(_data["co_updated_at"].toString()) : <any>undefined;
            this.co_created_at = _data["co_created_at"] ? new Date(_data["co_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["co_id"] = this.co_id;
        data["co_code"] = this.co_code;
        data["co_name"] = this.co_name;
        data["co_desc"] = this.co_desc;
        data["co_status"] = this.co_status;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["pl_id"] = this.pl_id;
        data["us_id_accept"] = this.us_id_accept;
        data["co_signed_at"] = this.co_signed_at ? this.co_signed_at.toISOString() : <any>undefined;
        data["su_id"] = this.su_id;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["co_updated_at"] = this.co_updated_at ? this.co_updated_at.toISOString() : <any>undefined;
        data["co_created_at"] = this.co_created_at ? this.co_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): ContractDto {
        const json = this.toJSON();
        let result = new ContractDto();
        result.init(json);
        return result;
    }
}

export interface IContractDto {
    co_id: number;
    co_code: string | undefined;
    co_name: string | undefined;
    co_desc: string | undefined;
    co_status: ContractStatus;
    fi_id_arr: AttachmentItem[] | undefined;
    pl_id: number;
    us_id_accept: number;
    co_signed_at: Date;
    su_id: number;
    us_id_created: number;
    us_id_updated: number;
    co_updated_at: Date;
    co_created_at: Date;
}

export class ContractDtoPagedResultDto implements IContractDtoPagedResultDto {
    items!: ContractDto[] | undefined;
    totalCount!: number;

    constructor(data?: IContractDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ContractDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ContractDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContractDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ContractDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ContractDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IContractDtoPagedResultDto {
    items: ContractDto[] | undefined;
    totalCount: number;
}

export enum ContractStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class CreateApplicationExtInput implements ICreateApplicationExtInput {
    ap_code!: string | undefined;
    ap_secret!: string | undefined;
    ap_callback_url!: string | undefined;
    ap_trust!: boolean;
    ap_confidential!: boolean;

    constructor(data?: ICreateApplicationExtInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ap_code = _data["ap_code"];
            this.ap_secret = _data["ap_secret"];
            this.ap_callback_url = _data["ap_callback_url"];
            this.ap_trust = _data["ap_trust"];
            this.ap_confidential = _data["ap_confidential"];
        }
    }

    static fromJS(data: any): CreateApplicationExtInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationExtInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ap_code"] = this.ap_code;
        data["ap_secret"] = this.ap_secret;
        data["ap_callback_url"] = this.ap_callback_url;
        data["ap_trust"] = this.ap_trust;
        data["ap_confidential"] = this.ap_confidential;
        return data;
    }

    clone(): CreateApplicationExtInput {
        const json = this.toJSON();
        let result = new CreateApplicationExtInput();
        result.init(json);
        return result;
    }
}

export interface ICreateApplicationExtInput {
    ap_code: string | undefined;
    ap_secret: string | undefined;
    ap_callback_url: string | undefined;
    ap_trust: boolean;
    ap_confidential: boolean;
}

export class CreateAuthorInput implements ICreateAuthorInput {
    au_name!: string | undefined;
    au_dob!: string | undefined;
    au_address!: string | undefined;
    au_decs!: string | undefined;
    au_email!: string | undefined;
    au_academic_rank!: string | undefined;
    au_degree!: string | undefined;
    au_pen_name!: string | undefined;
    au_infor!: string | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: ICreateAuthorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.au_name = _data["au_name"];
            this.au_dob = _data["au_dob"];
            this.au_address = _data["au_address"];
            this.au_decs = _data["au_decs"];
            this.au_email = _data["au_email"];
            this.au_academic_rank = _data["au_academic_rank"];
            this.au_degree = _data["au_degree"];
            this.au_pen_name = _data["au_pen_name"];
            this.au_infor = _data["au_infor"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateAuthorInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAuthorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["au_name"] = this.au_name;
        data["au_dob"] = this.au_dob;
        data["au_address"] = this.au_address;
        data["au_decs"] = this.au_decs;
        data["au_email"] = this.au_email;
        data["au_academic_rank"] = this.au_academic_rank;
        data["au_degree"] = this.au_degree;
        data["au_pen_name"] = this.au_pen_name;
        data["au_infor"] = this.au_infor;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateAuthorInput {
        const json = this.toJSON();
        let result = new CreateAuthorInput();
        result.init(json);
        return result;
    }
}

export interface ICreateAuthorInput {
    au_name: string | undefined;
    au_dob: string | undefined;
    au_address: string | undefined;
    au_decs: string | undefined;
    au_email: string | undefined;
    au_academic_rank: string | undefined;
    au_degree: string | undefined;
    au_pen_name: string | undefined;
    au_infor: string | undefined;
    fi_id: AttachmentItem;
}

export class CreateBillingInput implements ICreateBillingInput {
    bi_code!: string | undefined;
    bi_desc!: string | undefined;
    bi_note!: string | undefined;
    bi_export!: Date;
    bi_status!: BillStatus;
    pl_de_id_arr!: number[] | undefined;
    su_id!: ItemSupplier;
    co_id!: number;
    fi_id_arr!: AttachmentItem[] | undefined;
    bi_total_cost!: number;

    constructor(data?: ICreateBillingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_code = _data["bi_code"];
            this.bi_desc = _data["bi_desc"];
            this.bi_note = _data["bi_note"];
            this.bi_export = _data["bi_export"] ? new Date(_data["bi_export"].toString()) : <any>undefined;
            this.bi_status = _data["bi_status"];
            if (Array.isArray(_data["pl_de_id_arr"])) {
                this.pl_de_id_arr = [] as any;
                for (let item of _data["pl_de_id_arr"])
                    this.pl_de_id_arr!.push(item);
            }
            this.su_id = _data["su_id"] ? ItemSupplier.fromJS(_data["su_id"]) : <any>undefined;
            this.co_id = _data["co_id"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.bi_total_cost = _data["bi_total_cost"];
        }
    }

    static fromJS(data: any): CreateBillingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBillingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_code"] = this.bi_code;
        data["bi_desc"] = this.bi_desc;
        data["bi_note"] = this.bi_note;
        data["bi_export"] = this.bi_export ? this.bi_export.toISOString() : <any>undefined;
        data["bi_status"] = this.bi_status;
        if (Array.isArray(this.pl_de_id_arr)) {
            data["pl_de_id_arr"] = [];
            for (let item of this.pl_de_id_arr)
                data["pl_de_id_arr"].push(item);
        }
        data["su_id"] = this.su_id ? this.su_id.toJSON() : <any>undefined;
        data["co_id"] = this.co_id;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["bi_total_cost"] = this.bi_total_cost;
        return data;
    }

    clone(): CreateBillingInput {
        const json = this.toJSON();
        let result = new CreateBillingInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBillingInput {
    bi_code: string | undefined;
    bi_desc: string | undefined;
    bi_note: string | undefined;
    bi_export: Date;
    bi_status: BillStatus;
    pl_de_id_arr: number[] | undefined;
    su_id: ItemSupplier;
    co_id: number;
    fi_id_arr: AttachmentItem[] | undefined;
    bi_total_cost: number;
}

export class CreateBillingItemInput implements ICreateBillingItemInput {
    bi_it_name!: string | undefined;
    bi_id!: number;
    bi_it_cost!: number;
    bi_it_amount!: number;
    pl_de_id!: number;
    bi_it_unit!: string | undefined;

    constructor(data?: ICreateBillingItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_it_name = _data["bi_it_name"];
            this.bi_id = _data["bi_id"];
            this.bi_it_cost = _data["bi_it_cost"];
            this.bi_it_amount = _data["bi_it_amount"];
            this.pl_de_id = _data["pl_de_id"];
            this.bi_it_unit = _data["bi_it_unit"];
        }
    }

    static fromJS(data: any): CreateBillingItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBillingItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_it_name"] = this.bi_it_name;
        data["bi_id"] = this.bi_id;
        data["bi_it_cost"] = this.bi_it_cost;
        data["bi_it_amount"] = this.bi_it_amount;
        data["pl_de_id"] = this.pl_de_id;
        data["bi_it_unit"] = this.bi_it_unit;
        return data;
    }

    clone(): CreateBillingItemInput {
        const json = this.toJSON();
        let result = new CreateBillingItemInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBillingItemInput {
    bi_it_name: string | undefined;
    bi_id: number;
    bi_it_cost: number;
    bi_it_amount: number;
    pl_de_id: number;
    bi_it_unit: string | undefined;
}

export class CreateBorrowReturningAtDeskInput implements ICreateBorrowReturningAtDeskInput {
    documents!: ItemBorrowReturning[] | undefined;
    br_re_desc!: string | undefined;
    us_id_borrow!: number;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: ICreateBorrowReturningAtDeskInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(ItemBorrowReturning.fromJS(item));
            }
            this.br_re_desc = _data["br_re_desc"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateBorrowReturningAtDeskInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBorrowReturningAtDeskInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["br_re_desc"] = this.br_re_desc;
        data["us_id_borrow"] = this.us_id_borrow;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateBorrowReturningAtDeskInput {
        const json = this.toJSON();
        let result = new CreateBorrowReturningAtDeskInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBorrowReturningAtDeskInput {
    documents: ItemBorrowReturning[] | undefined;
    br_re_desc: string | undefined;
    us_id_borrow: number;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class CreateBorrowReturningInput implements ICreateBorrowReturningInput {
    do_id!: number[] | undefined;
    br_re_desc!: string | undefined;
    us_id_borrow!: number;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    br_re_method!: BorrowMethod;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: ICreateBorrowReturningInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["do_id"])) {
                this.do_id = [] as any;
                for (let item of _data["do_id"])
                    this.do_id!.push(item);
            }
            this.br_re_desc = _data["br_re_desc"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            this.br_re_method = _data["br_re_method"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateBorrowReturningInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBorrowReturningInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.do_id)) {
            data["do_id"] = [];
            for (let item of this.do_id)
                data["do_id"].push(item);
        }
        data["br_re_desc"] = this.br_re_desc;
        data["us_id_borrow"] = this.us_id_borrow;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        data["br_re_method"] = this.br_re_method;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateBorrowReturningInput {
        const json = this.toJSON();
        let result = new CreateBorrowReturningInput();
        result.init(json);
        return result;
    }
}

export interface ICreateBorrowReturningInput {
    do_id: number[] | undefined;
    br_re_desc: string | undefined;
    us_id_borrow: number;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    br_re_method: BorrowMethod;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class CreateCatalogingInput implements ICreateCatalogingInput {
    do_in_id!: number;
    cata_content!: string | undefined;
    cata_resultDDC!: string | undefined;
    cata_resultTitle!: string | undefined;
    cata_resultColor!: string | undefined;

    constructor(data?: ICreateCatalogingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_in_id = _data["do_in_id"];
            this.cata_content = _data["cata_content"];
            this.cata_resultDDC = _data["cata_resultDDC"];
            this.cata_resultTitle = _data["cata_resultTitle"];
            this.cata_resultColor = _data["cata_resultColor"];
        }
    }

    static fromJS(data: any): CreateCatalogingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCatalogingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_in_id"] = this.do_in_id;
        data["cata_content"] = this.cata_content;
        data["cata_resultDDC"] = this.cata_resultDDC;
        data["cata_resultTitle"] = this.cata_resultTitle;
        data["cata_resultColor"] = this.cata_resultColor;
        return data;
    }

    clone(): CreateCatalogingInput {
        const json = this.toJSON();
        let result = new CreateCatalogingInput();
        result.init(json);
        return result;
    }
}

export interface ICreateCatalogingInput {
    do_in_id: number;
    cata_content: string | undefined;
    cata_resultDDC: string | undefined;
    cata_resultTitle: string | undefined;
    cata_resultColor: string | undefined;
}

export class CreateCategoryInput implements ICreateCategoryInput {
    ca_title!: string | undefined;
    dkcb_code!: string | undefined;
    dkcb_start!: number;
    ca_abstract!: string | undefined;
    ca_id_parent!: number;

    constructor(data?: ICreateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ca_title = _data["ca_title"];
            this.dkcb_code = _data["dkcb_code"];
            this.dkcb_start = _data["dkcb_start"];
            this.ca_abstract = _data["ca_abstract"];
            this.ca_id_parent = _data["ca_id_parent"];
        }
    }

    static fromJS(data: any): CreateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ca_title"] = this.ca_title;
        data["dkcb_code"] = this.dkcb_code;
        data["dkcb_start"] = this.dkcb_start;
        data["ca_abstract"] = this.ca_abstract;
        data["ca_id_parent"] = this.ca_id_parent;
        return data;
    }

    clone(): CreateCategoryInput {
        const json = this.toJSON();
        let result = new CreateCategoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateCategoryInput {
    ca_title: string | undefined;
    dkcb_code: string | undefined;
    dkcb_start: number;
    ca_abstract: string | undefined;
    ca_id_parent: number;
}

export class CreateCheckInput implements ICreateCheckInput {
    ck_name!: string | undefined;
    ck_desc!: string | undefined;
    ck_start_at!: Date;
    us_id_participant!: ItemUser[] | undefined;
    us_id_approved!: number;
    ck_note!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: ICreateCheckInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ck_name = _data["ck_name"];
            this.ck_desc = _data["ck_desc"];
            this.ck_start_at = _data["ck_start_at"] ? new Date(_data["ck_start_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["us_id_participant"])) {
                this.us_id_participant = [] as any;
                for (let item of _data["us_id_participant"])
                    this.us_id_participant!.push(ItemUser.fromJS(item));
            }
            this.us_id_approved = _data["us_id_approved"];
            this.ck_note = _data["ck_note"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateCheckInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCheckInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ck_name"] = this.ck_name;
        data["ck_desc"] = this.ck_desc;
        data["ck_start_at"] = this.ck_start_at ? this.ck_start_at.toISOString() : <any>undefined;
        if (Array.isArray(this.us_id_participant)) {
            data["us_id_participant"] = [];
            for (let item of this.us_id_participant)
                data["us_id_participant"].push(item.toJSON());
        }
        data["us_id_approved"] = this.us_id_approved;
        data["ck_note"] = this.ck_note;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateCheckInput {
        const json = this.toJSON();
        let result = new CreateCheckInput();
        result.init(json);
        return result;
    }
}

export interface ICreateCheckInput {
    ck_name: string | undefined;
    ck_desc: string | undefined;
    ck_start_at: Date;
    us_id_participant: ItemUser[] | undefined;
    us_id_approved: number;
    ck_note: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class CreateCheckItemInput implements ICreateCheckItemInput {
    ck_id!: number;
    do_id!: ItemDocument;
    ck_it_note!: string | undefined;

    constructor(data?: ICreateCheckItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ck_id = _data["ck_id"];
            this.do_id = _data["do_id"] ? ItemDocument.fromJS(_data["do_id"]) : <any>undefined;
            this.ck_it_note = _data["ck_it_note"];
        }
    }

    static fromJS(data: any): CreateCheckItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCheckItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ck_id"] = this.ck_id;
        data["do_id"] = this.do_id ? this.do_id.toJSON() : <any>undefined;
        data["ck_it_note"] = this.ck_it_note;
        return data;
    }

    clone(): CreateCheckItemInput {
        const json = this.toJSON();
        let result = new CreateCheckItemInput();
        result.init(json);
        return result;
    }
}

export interface ICreateCheckItemInput {
    ck_id: number;
    do_id: ItemDocument;
    ck_it_note: string | undefined;
}

export class CreateContractInput implements ICreateContractInput {
    co_name!: string | undefined;
    co_desc!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;
    pl_id!: number;
    us_id_accept!: number;
    co_signed_at!: Date;
    su_id!: number;

    constructor(data?: ICreateContractInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.co_name = _data["co_name"];
            this.co_desc = _data["co_desc"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.pl_id = _data["pl_id"];
            this.us_id_accept = _data["us_id_accept"];
            this.co_signed_at = _data["co_signed_at"] ? new Date(_data["co_signed_at"].toString()) : <any>undefined;
            this.su_id = _data["su_id"];
        }
    }

    static fromJS(data: any): CreateContractInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContractInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["co_name"] = this.co_name;
        data["co_desc"] = this.co_desc;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["pl_id"] = this.pl_id;
        data["us_id_accept"] = this.us_id_accept;
        data["co_signed_at"] = this.co_signed_at ? this.co_signed_at.toISOString() : <any>undefined;
        data["su_id"] = this.su_id;
        return data;
    }

    clone(): CreateContractInput {
        const json = this.toJSON();
        let result = new CreateContractInput();
        result.init(json);
        return result;
    }
}

export interface ICreateContractInput {
    co_name: string | undefined;
    co_desc: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
    pl_id: number;
    us_id_accept: number;
    co_signed_at: Date;
    su_id: number;
}

export class CreateDictionariesInput implements ICreateDictionariesInput {
    dic_ty_id!: number;
    dic_name!: string | undefined;
    dic_short_des!: string | undefined;
    dic_desc!: string | undefined;
    fi_id_symbol!: AttachmentItem;
    dic_ref!: string | undefined;

    constructor(data?: ICreateDictionariesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dic_ty_id = _data["dic_ty_id"];
            this.dic_name = _data["dic_name"];
            this.dic_short_des = _data["dic_short_des"];
            this.dic_desc = _data["dic_desc"];
            this.fi_id_symbol = _data["fi_id_symbol"] ? AttachmentItem.fromJS(_data["fi_id_symbol"]) : <any>undefined;
            this.dic_ref = _data["dic_ref"];
        }
    }

    static fromJS(data: any): CreateDictionariesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDictionariesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dic_ty_id"] = this.dic_ty_id;
        data["dic_name"] = this.dic_name;
        data["dic_short_des"] = this.dic_short_des;
        data["dic_desc"] = this.dic_desc;
        data["fi_id_symbol"] = this.fi_id_symbol ? this.fi_id_symbol.toJSON() : <any>undefined;
        data["dic_ref"] = this.dic_ref;
        return data;
    }

    clone(): CreateDictionariesInput {
        const json = this.toJSON();
        let result = new CreateDictionariesInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDictionariesInput {
    dic_ty_id: number;
    dic_name: string | undefined;
    dic_short_des: string | undefined;
    dic_desc: string | undefined;
    fi_id_symbol: AttachmentItem;
    dic_ref: string | undefined;
}

export class CreateDictionaryTypeInput implements ICreateDictionaryTypeInput {
    dic_ty_name!: string | undefined;
    dic_ty_desc!: string | undefined;

    constructor(data?: ICreateDictionaryTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dic_ty_name = _data["dic_ty_name"];
            this.dic_ty_desc = _data["dic_ty_desc"];
        }
    }

    static fromJS(data: any): CreateDictionaryTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDictionaryTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dic_ty_name"] = this.dic_ty_name;
        data["dic_ty_desc"] = this.dic_ty_desc;
        return data;
    }

    clone(): CreateDictionaryTypeInput {
        const json = this.toJSON();
        let result = new CreateDictionaryTypeInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDictionaryTypeInput {
    dic_ty_name: string | undefined;
    dic_ty_desc: string | undefined;
}

export class CreateDocumentInforInput implements ICreateDocumentInforInput {
    do_id!: number;
    do_in_note!: string | undefined;
    do_in_isbn!: string | undefined;
    dkcb_code!: string | undefined;

    constructor(data?: ICreateDocumentInforInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_id = _data["do_id"];
            this.do_in_note = _data["do_in_note"];
            this.do_in_isbn = _data["do_in_isbn"];
            this.dkcb_code = _data["dkcb_code"];
        }
    }

    static fromJS(data: any): CreateDocumentInforInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentInforInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_id"] = this.do_id;
        data["do_in_note"] = this.do_in_note;
        data["do_in_isbn"] = this.do_in_isbn;
        data["dkcb_code"] = this.dkcb_code;
        return data;
    }

    clone(): CreateDocumentInforInput {
        const json = this.toJSON();
        let result = new CreateDocumentInforInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDocumentInforInput {
    do_id: number;
    do_in_note: string | undefined;
    do_in_isbn: string | undefined;
    dkcb_code: string | undefined;
}

export class CreateDocumentInput implements ICreateDocumentInput {
    do_title!: string | undefined;
    do_date_publish!: string | undefined;
    do_republish!: number;
    do_identifier!: string | undefined;
    do_identifier_citation!: string | undefined;
    do_abstract!: string | undefined;
    do_period_check!: number;
    do_date_available!: Date | undefined;
    do_nr_pages!: number;
    do_translator!: string | undefined;
    do_language_iso!: ItemLanguages[] | undefined;
    fie_id_arr!: ItemField[] | undefined;
    fi_id_arr_cover!: AttachmentItem[] | undefined;
    au_id_arr!: ItemAuthor[] | undefined;
    pu_id!: ItemPublisher;
    to_id!: number;
    ca_id!: number;
    do_status!: DocumentStatus;
    do_borrow_status!: DocumentBorrowType;
    do_price!: number;

    constructor(data?: ICreateDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_title = _data["do_title"];
            this.do_date_publish = _data["do_date_publish"];
            this.do_republish = _data["do_republish"];
            this.do_identifier = _data["do_identifier"];
            this.do_identifier_citation = _data["do_identifier_citation"];
            this.do_abstract = _data["do_abstract"];
            this.do_period_check = _data["do_period_check"];
            this.do_date_available = _data["do_date_available"] ? new Date(_data["do_date_available"].toString()) : <any>undefined;
            this.do_nr_pages = _data["do_nr_pages"];
            this.do_translator = _data["do_translator"];
            if (Array.isArray(_data["do_language_iso"])) {
                this.do_language_iso = [] as any;
                for (let item of _data["do_language_iso"])
                    this.do_language_iso!.push(ItemLanguages.fromJS(item));
            }
            if (Array.isArray(_data["fie_id_arr"])) {
                this.fie_id_arr = [] as any;
                for (let item of _data["fie_id_arr"])
                    this.fie_id_arr!.push(ItemField.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_arr_cover"])) {
                this.fi_id_arr_cover = [] as any;
                for (let item of _data["fi_id_arr_cover"])
                    this.fi_id_arr_cover!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["au_id_arr"])) {
                this.au_id_arr = [] as any;
                for (let item of _data["au_id_arr"])
                    this.au_id_arr!.push(ItemAuthor.fromJS(item));
            }
            this.pu_id = _data["pu_id"] ? ItemPublisher.fromJS(_data["pu_id"]) : <any>undefined;
            this.to_id = _data["to_id"];
            this.ca_id = _data["ca_id"];
            this.do_status = _data["do_status"];
            this.do_borrow_status = _data["do_borrow_status"];
            this.do_price = _data["do_price"];
        }
    }

    static fromJS(data: any): CreateDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_title"] = this.do_title;
        data["do_date_publish"] = this.do_date_publish;
        data["do_republish"] = this.do_republish;
        data["do_identifier"] = this.do_identifier;
        data["do_identifier_citation"] = this.do_identifier_citation;
        data["do_abstract"] = this.do_abstract;
        data["do_period_check"] = this.do_period_check;
        data["do_date_available"] = this.do_date_available ? this.do_date_available.toISOString() : <any>undefined;
        data["do_nr_pages"] = this.do_nr_pages;
        data["do_translator"] = this.do_translator;
        if (Array.isArray(this.do_language_iso)) {
            data["do_language_iso"] = [];
            for (let item of this.do_language_iso)
                data["do_language_iso"].push(item.toJSON());
        }
        if (Array.isArray(this.fie_id_arr)) {
            data["fie_id_arr"] = [];
            for (let item of this.fie_id_arr)
                data["fie_id_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_arr_cover)) {
            data["fi_id_arr_cover"] = [];
            for (let item of this.fi_id_arr_cover)
                data["fi_id_arr_cover"].push(item.toJSON());
        }
        if (Array.isArray(this.au_id_arr)) {
            data["au_id_arr"] = [];
            for (let item of this.au_id_arr)
                data["au_id_arr"].push(item.toJSON());
        }
        data["pu_id"] = this.pu_id ? this.pu_id.toJSON() : <any>undefined;
        data["to_id"] = this.to_id;
        data["ca_id"] = this.ca_id;
        data["do_status"] = this.do_status;
        data["do_borrow_status"] = this.do_borrow_status;
        data["do_price"] = this.do_price;
        return data;
    }

    clone(): CreateDocumentInput {
        const json = this.toJSON();
        let result = new CreateDocumentInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDocumentInput {
    do_title: string | undefined;
    do_date_publish: string | undefined;
    do_republish: number;
    do_identifier: string | undefined;
    do_identifier_citation: string | undefined;
    do_abstract: string | undefined;
    do_period_check: number;
    do_date_available: Date | undefined;
    do_nr_pages: number;
    do_translator: string | undefined;
    do_language_iso: ItemLanguages[] | undefined;
    fie_id_arr: ItemField[] | undefined;
    fi_id_arr_cover: AttachmentItem[] | undefined;
    au_id_arr: ItemAuthor[] | undefined;
    pu_id: ItemPublisher;
    to_id: number;
    ca_id: number;
    do_status: DocumentStatus;
    do_borrow_status: DocumentBorrowType;
    do_price: number;
}

export class CreateDocumentLogInput implements ICreateDocumentLogInput {
    do_id!: number;
    us_id!: number;
    do_lo_action!: DocumentLogAction;
    do_lo_data!: string | undefined;

    constructor(data?: ICreateDocumentLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_id = _data["do_id"];
            this.us_id = _data["us_id"];
            this.do_lo_action = _data["do_lo_action"];
            this.do_lo_data = _data["do_lo_data"];
        }
    }

    static fromJS(data: any): CreateDocumentLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDocumentLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_id"] = this.do_id;
        data["us_id"] = this.us_id;
        data["do_lo_action"] = this.do_lo_action;
        data["do_lo_data"] = this.do_lo_data;
        return data;
    }

    clone(): CreateDocumentLogInput {
        const json = this.toJSON();
        let result = new CreateDocumentLogInput();
        result.init(json);
        return result;
    }
}

export interface ICreateDocumentLogInput {
    do_id: number;
    us_id: number;
    do_lo_action: DocumentLogAction;
    do_lo_data: string | undefined;
}

export class CreateFieldsInput implements ICreateFieldsInput {
    fie_name!: string | undefined;
    fie_desc!: string | undefined;

    constructor(data?: ICreateFieldsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fie_name = _data["fie_name"];
            this.fie_desc = _data["fie_desc"];
        }
    }

    static fromJS(data: any): CreateFieldsInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFieldsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fie_name"] = this.fie_name;
        data["fie_desc"] = this.fie_desc;
        return data;
    }

    clone(): CreateFieldsInput {
        const json = this.toJSON();
        let result = new CreateFieldsInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFieldsInput {
    fie_name: string | undefined;
    fie_desc: string | undefined;
}

export class CreateFilesOfUserRolesInput implements ICreateFilesOfUserRolesInput {
    fi_us_id!: number;
    us_id!: number[] | undefined;
    fi_ro_role!: ResourceRoleStatus;

    constructor(data?: ICreateFilesOfUserRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_us_id = _data["fi_us_id"];
            if (Array.isArray(_data["us_id"])) {
                this.us_id = [] as any;
                for (let item of _data["us_id"])
                    this.us_id!.push(item);
            }
            this.fi_ro_role = _data["fi_ro_role"];
        }
    }

    static fromJS(data: any): CreateFilesOfUserRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFilesOfUserRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_us_id"] = this.fi_us_id;
        if (Array.isArray(this.us_id)) {
            data["us_id"] = [];
            for (let item of this.us_id)
                data["us_id"].push(item);
        }
        data["fi_ro_role"] = this.fi_ro_role;
        return data;
    }

    clone(): CreateFilesOfUserRolesInput {
        const json = this.toJSON();
        let result = new CreateFilesOfUserRolesInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFilesOfUserRolesInput {
    fi_us_id: number;
    us_id: number[] | undefined;
    fi_ro_role: ResourceRoleStatus;
}

export class CreateFolderInput implements ICreateFolderInput {
    fo_name!: string | undefined;
    fo_decs!: string | undefined;
    fo_id_parent!: number;

    constructor(data?: ICreateFolderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_name = _data["fo_name"];
            this.fo_decs = _data["fo_decs"];
            this.fo_id_parent = _data["fo_id_parent"];
        }
    }

    static fromJS(data: any): CreateFolderInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFolderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_name"] = this.fo_name;
        data["fo_decs"] = this.fo_decs;
        data["fo_id_parent"] = this.fo_id_parent;
        return data;
    }

    clone(): CreateFolderInput {
        const json = this.toJSON();
        let result = new CreateFolderInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFolderInput {
    fo_name: string | undefined;
    fo_decs: string | undefined;
    fo_id_parent: number;
}

export class CreateFolderRolesInput implements ICreateFolderRolesInput {
    us_id!: number[] | undefined;
    fo_id!: number;
    fo_ro_role!: ResourceRoleStatus;

    constructor(data?: ICreateFolderRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["us_id"])) {
                this.us_id = [] as any;
                for (let item of _data["us_id"])
                    this.us_id!.push(item);
            }
            this.fo_id = _data["fo_id"];
            this.fo_ro_role = _data["fo_ro_role"];
        }
    }

    static fromJS(data: any): CreateFolderRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFolderRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.us_id)) {
            data["us_id"] = [];
            for (let item of this.us_id)
                data["us_id"].push(item);
        }
        data["fo_id"] = this.fo_id;
        data["fo_ro_role"] = this.fo_ro_role;
        return data;
    }

    clone(): CreateFolderRolesInput {
        const json = this.toJSON();
        let result = new CreateFolderRolesInput();
        result.init(json);
        return result;
    }
}

export interface ICreateFolderRolesInput {
    us_id: number[] | undefined;
    fo_id: number;
    fo_ro_role: ResourceRoleStatus;
}

export class CreateLanguagesInput implements ICreateLanguagesInput {
    la_title!: string | undefined;
    la_flag!: string | undefined;
    la_enable!: boolean;

    constructor(data?: ICreateLanguagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.la_title = _data["la_title"];
            this.la_flag = _data["la_flag"];
            this.la_enable = _data["la_enable"];
        }
    }

    static fromJS(data: any): CreateLanguagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateLanguagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["la_title"] = this.la_title;
        data["la_flag"] = this.la_flag;
        data["la_enable"] = this.la_enable;
        return data;
    }

    clone(): CreateLanguagesInput {
        const json = this.toJSON();
        let result = new CreateLanguagesInput();
        result.init(json);
        return result;
    }
}

export interface ICreateLanguagesInput {
    la_title: string | undefined;
    la_flag: string | undefined;
    la_enable: boolean;
}

export class CreateListCitationInput implements ICreateListCitationInput {
    itemDocument!: ItemDocument[] | undefined;
    ci_type!: CitationType;
    ci_structure!: CitationStructure;

    constructor(data?: ICreateListCitationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["itemDocument"])) {
                this.itemDocument = [] as any;
                for (let item of _data["itemDocument"])
                    this.itemDocument!.push(ItemDocument.fromJS(item));
            }
            this.ci_type = _data["ci_type"];
            this.ci_structure = _data["ci_structure"];
        }
    }

    static fromJS(data: any): CreateListCitationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateListCitationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.itemDocument)) {
            data["itemDocument"] = [];
            for (let item of this.itemDocument)
                data["itemDocument"].push(item.toJSON());
        }
        data["ci_type"] = this.ci_type;
        data["ci_structure"] = this.ci_structure;
        return data;
    }

    clone(): CreateListCitationInput {
        const json = this.toJSON();
        let result = new CreateListCitationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateListCitationInput {
    itemDocument: ItemDocument[] | undefined;
    ci_type: CitationType;
    ci_structure: CitationStructure;
}

export class CreateMarc21Input implements ICreateMarc21Input {
    mar_code!: string | undefined;
    mar_desc!: string | undefined;

    constructor(data?: ICreateMarc21Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mar_code = _data["mar_code"];
            this.mar_desc = _data["mar_desc"];
        }
    }

    static fromJS(data: any): CreateMarc21Input {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMarc21Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mar_code"] = this.mar_code;
        data["mar_desc"] = this.mar_desc;
        return data;
    }

    clone(): CreateMarc21Input {
        const json = this.toJSON();
        let result = new CreateMarc21Input();
        result.init(json);
        return result;
    }
}

export interface ICreateMarc21Input {
    mar_code: string | undefined;
    mar_desc: string | undefined;
}

export class CreateMemberCardInput implements ICreateMemberCardInput {
    me_id!: number;
    me_ca_use_from!: Date;
    me_ca_use_to!: Date;
    me_ca_money!: number;
    me_ca_level!: number;
    me_ca_type!: MCardType;
    me_ca_time_receive!: Date | undefined;

    constructor(data?: ICreateMemberCardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_ca_use_from = _data["me_ca_use_from"] ? new Date(_data["me_ca_use_from"].toString()) : <any>undefined;
            this.me_ca_use_to = _data["me_ca_use_to"] ? new Date(_data["me_ca_use_to"].toString()) : <any>undefined;
            this.me_ca_money = _data["me_ca_money"];
            this.me_ca_level = _data["me_ca_level"];
            this.me_ca_type = _data["me_ca_type"];
            this.me_ca_time_receive = _data["me_ca_time_receive"] ? new Date(_data["me_ca_time_receive"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateMemberCardInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberCardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_ca_use_from"] = this.me_ca_use_from ? this.me_ca_use_from.toISOString() : <any>undefined;
        data["me_ca_use_to"] = this.me_ca_use_to ? this.me_ca_use_to.toISOString() : <any>undefined;
        data["me_ca_money"] = this.me_ca_money;
        data["me_ca_level"] = this.me_ca_level;
        data["me_ca_type"] = this.me_ca_type;
        data["me_ca_time_receive"] = this.me_ca_time_receive ? this.me_ca_time_receive.toISOString() : <any>undefined;
        return data;
    }

    clone(): CreateMemberCardInput {
        const json = this.toJSON();
        let result = new CreateMemberCardInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMemberCardInput {
    me_id: number;
    me_ca_use_from: Date;
    me_ca_use_to: Date;
    me_ca_money: number;
    me_ca_level: number;
    me_ca_type: MCardType;
    me_ca_time_receive: Date | undefined;
}

export class CreateMemberInput implements ICreateMemberInput {
    me_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    emailAddress!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: ICreateMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_name = _data["me_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.emailAddress = _data["emailAddress"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_name"] = this.me_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["emailAddress"] = this.emailAddress;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): CreateMemberInput {
        const json = this.toJSON();
        let result = new CreateMemberInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMemberInput {
    me_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    emailAddress: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    fi_id: AttachmentItem;
}

export class CreateMemberLogInput implements ICreateMemberLogInput {
    me_id!: number;
    me_lo_action!: MemberAction;
    me_lo_data!: string | undefined;

    constructor(data?: ICreateMemberLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_lo_action = _data["me_lo_action"];
            this.me_lo_data = _data["me_lo_data"];
        }
    }

    static fromJS(data: any): CreateMemberLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMemberLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_lo_action"] = this.me_lo_action;
        data["me_lo_data"] = this.me_lo_data;
        return data;
    }

    clone(): CreateMemberLogInput {
        const json = this.toJSON();
        let result = new CreateMemberLogInput();
        result.init(json);
        return result;
    }
}

export interface ICreateMemberLogInput {
    me_id: number;
    me_lo_action: MemberAction;
    me_lo_data: string | undefined;
}

export class CreateOrUpdateCitationInput implements ICreateOrUpdateCitationInput {
    itemDocument!: ItemDocument;
    ci_type!: CitationType;
    ci_structure!: CitationStructure;

    constructor(data?: ICreateOrUpdateCitationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.itemDocument = _data["itemDocument"] ? ItemDocument.fromJS(_data["itemDocument"]) : <any>undefined;
            this.ci_type = _data["ci_type"];
            this.ci_structure = _data["ci_structure"];
        }
    }

    static fromJS(data: any): CreateOrUpdateCitationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCitationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemDocument"] = this.itemDocument ? this.itemDocument.toJSON() : <any>undefined;
        data["ci_type"] = this.ci_type;
        data["ci_structure"] = this.ci_structure;
        return data;
    }

    clone(): CreateOrUpdateCitationInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateCitationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateCitationInput {
    itemDocument: ItemDocument;
    ci_type: CitationType;
    ci_structure: CitationStructure;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class CreatePlanDetailArrInput implements ICreatePlanDetailArrInput {
    bi_id!: number;
    pl_de_id_arr!: number[] | undefined;

    constructor(data?: ICreatePlanDetailArrInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_id = _data["bi_id"];
            if (Array.isArray(_data["pl_de_id_arr"])) {
                this.pl_de_id_arr = [] as any;
                for (let item of _data["pl_de_id_arr"])
                    this.pl_de_id_arr!.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePlanDetailArrInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlanDetailArrInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_id"] = this.bi_id;
        if (Array.isArray(this.pl_de_id_arr)) {
            data["pl_de_id_arr"] = [];
            for (let item of this.pl_de_id_arr)
                data["pl_de_id_arr"].push(item);
        }
        return data;
    }

    clone(): CreatePlanDetailArrInput {
        const json = this.toJSON();
        let result = new CreatePlanDetailArrInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePlanDetailArrInput {
    bi_id: number;
    pl_de_id_arr: number[] | undefined;
}

export class CreatePlanDetailInput implements ICreatePlanDetailInput {
    pl_id!: number;
    do_id!: ItemDocument;
    pl_de_quantity!: number;
    pl_de_price!: number;
    pl_de_type!: PlanDetailType;
    pl_de_note!: string | undefined;
    pl_de_status_book!: PlanDetailStatusBook;

    constructor(data?: ICreatePlanDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_id = _data["pl_id"];
            this.do_id = _data["do_id"] ? ItemDocument.fromJS(_data["do_id"]) : <any>undefined;
            this.pl_de_quantity = _data["pl_de_quantity"];
            this.pl_de_price = _data["pl_de_price"];
            this.pl_de_type = _data["pl_de_type"];
            this.pl_de_note = _data["pl_de_note"];
            this.pl_de_status_book = _data["pl_de_status_book"];
        }
    }

    static fromJS(data: any): CreatePlanDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlanDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_id"] = this.pl_id;
        data["do_id"] = this.do_id ? this.do_id.toJSON() : <any>undefined;
        data["pl_de_quantity"] = this.pl_de_quantity;
        data["pl_de_price"] = this.pl_de_price;
        data["pl_de_type"] = this.pl_de_type;
        data["pl_de_note"] = this.pl_de_note;
        data["pl_de_status_book"] = this.pl_de_status_book;
        return data;
    }

    clone(): CreatePlanDetailInput {
        const json = this.toJSON();
        let result = new CreatePlanDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePlanDetailInput {
    pl_id: number;
    do_id: ItemDocument;
    pl_de_quantity: number;
    pl_de_price: number;
    pl_de_type: PlanDetailType;
    pl_de_note: string | undefined;
    pl_de_status_book: PlanDetailStatusBook;
}

export class CreatePlanInput implements ICreatePlanInput {
    pl_title!: string | undefined;

    constructor(data?: ICreatePlanInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_title = _data["pl_title"];
        }
    }

    static fromJS(data: any): CreatePlanInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlanInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_title"] = this.pl_title;
        return data;
    }

    clone(): CreatePlanInput {
        const json = this.toJSON();
        let result = new CreatePlanInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePlanInput {
    pl_title: string | undefined;
}

export class CreatePublishLogInput implements ICreatePublishLogInput {
    pu_re_id!: number;
    pu_lo_notes!: string | undefined;

    constructor(data?: ICreatePublishLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_re_id = _data["pu_re_id"];
            this.pu_lo_notes = _data["pu_lo_notes"];
        }
    }

    static fromJS(data: any): CreatePublishLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePublishLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_re_id"] = this.pu_re_id;
        data["pu_lo_notes"] = this.pu_lo_notes;
        return data;
    }

    clone(): CreatePublishLogInput {
        const json = this.toJSON();
        let result = new CreatePublishLogInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePublishLogInput {
    pu_re_id: number;
    pu_lo_notes: string | undefined;
}

export class CreatePublishRegisterInput implements ICreatePublishRegisterInput {
    pu_re_name!: string | undefined;
    ca_id!: number;
    pu_re_receive_type!: TypePublishRegister;
    me_id!: number;
    pu_re_note!: string | undefined;
    us_id_change_status!: number;
    pu_re_status!: StatusPublishRegister;

    constructor(data?: ICreatePublishRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_re_name = _data["pu_re_name"];
            this.ca_id = _data["ca_id"];
            this.pu_re_receive_type = _data["pu_re_receive_type"];
            this.me_id = _data["me_id"];
            this.pu_re_note = _data["pu_re_note"];
            this.us_id_change_status = _data["us_id_change_status"];
            this.pu_re_status = _data["pu_re_status"];
        }
    }

    static fromJS(data: any): CreatePublishRegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePublishRegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_re_name"] = this.pu_re_name;
        data["ca_id"] = this.ca_id;
        data["pu_re_receive_type"] = this.pu_re_receive_type;
        data["me_id"] = this.me_id;
        data["pu_re_note"] = this.pu_re_note;
        data["us_id_change_status"] = this.us_id_change_status;
        data["pu_re_status"] = this.pu_re_status;
        return data;
    }

    clone(): CreatePublishRegisterInput {
        const json = this.toJSON();
        let result = new CreatePublishRegisterInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePublishRegisterInput {
    pu_re_name: string | undefined;
    ca_id: number;
    pu_re_receive_type: TypePublishRegister;
    me_id: number;
    pu_re_note: string | undefined;
    us_id_change_status: number;
    pu_re_status: StatusPublishRegister;
}

export class CreatePublishSettingInput implements ICreatePublishSettingInput {
    ca_id!: number;
    pu_se_note!: string | undefined;
    pu_se_day!: number;
    pu_se_month!: number;
    pu_se_year!: number;
    pu_se_type!: PublishSettingType;
    pu_se_active!: boolean;
    pu_se_condition!: string | undefined;

    constructor(data?: ICreatePublishSettingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ca_id = _data["ca_id"];
            this.pu_se_note = _data["pu_se_note"];
            this.pu_se_day = _data["pu_se_day"];
            this.pu_se_month = _data["pu_se_month"];
            this.pu_se_year = _data["pu_se_year"];
            this.pu_se_type = _data["pu_se_type"];
            this.pu_se_active = _data["pu_se_active"];
            this.pu_se_condition = _data["pu_se_condition"];
        }
    }

    static fromJS(data: any): CreatePublishSettingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePublishSettingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ca_id"] = this.ca_id;
        data["pu_se_note"] = this.pu_se_note;
        data["pu_se_day"] = this.pu_se_day;
        data["pu_se_month"] = this.pu_se_month;
        data["pu_se_year"] = this.pu_se_year;
        data["pu_se_type"] = this.pu_se_type;
        data["pu_se_active"] = this.pu_se_active;
        data["pu_se_condition"] = this.pu_se_condition;
        return data;
    }

    clone(): CreatePublishSettingInput {
        const json = this.toJSON();
        let result = new CreatePublishSettingInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePublishSettingInput {
    ca_id: number;
    pu_se_note: string | undefined;
    pu_se_day: number;
    pu_se_month: number;
    pu_se_year: number;
    pu_se_type: PublishSettingType;
    pu_se_active: boolean;
    pu_se_condition: string | undefined;
}

export class CreatePublisherInput implements ICreatePublisherInput {
    pu_short_name!: string | undefined;
    pu_name!: string | undefined;
    pu_address!: string | undefined;
    pu_license!: string | undefined;
    pu_email!: string | undefined;
    pu_phone!: string | undefined;
    pu_website!: string | undefined;
    pu_infor!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: ICreatePublisherInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_short_name = _data["pu_short_name"];
            this.pu_name = _data["pu_name"];
            this.pu_address = _data["pu_address"];
            this.pu_license = _data["pu_license"];
            this.pu_email = _data["pu_email"];
            this.pu_phone = _data["pu_phone"];
            this.pu_website = _data["pu_website"];
            this.pu_infor = _data["pu_infor"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePublisherInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePublisherInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_short_name"] = this.pu_short_name;
        data["pu_name"] = this.pu_name;
        data["pu_address"] = this.pu_address;
        data["pu_license"] = this.pu_license;
        data["pu_email"] = this.pu_email;
        data["pu_phone"] = this.pu_phone;
        data["pu_website"] = this.pu_website;
        data["pu_infor"] = this.pu_infor;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreatePublisherInput {
        const json = this.toJSON();
        let result = new CreatePublisherInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePublisherInput {
    pu_short_name: string | undefined;
    pu_name: string | undefined;
    pu_address: string | undefined;
    pu_license: string | undefined;
    pu_email: string | undefined;
    pu_phone: string | undefined;
    pu_website: string | undefined;
    pu_infor: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class CreatePunishInput implements ICreatePunishInput {
    us_id_borrow!: number;
    br_re_de_id!: number;
    pun_reason!: string | undefined;
    pun_error!: PunishError;
    fi_id_arr!: AttachmentItem[] | undefined;
    pun_money!: number;

    constructor(data?: ICreatePunishInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.us_id_borrow = _data["us_id_borrow"];
            this.br_re_de_id = _data["br_re_de_id"];
            this.pun_reason = _data["pun_reason"];
            this.pun_error = _data["pun_error"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.pun_money = _data["pun_money"];
        }
    }

    static fromJS(data: any): CreatePunishInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePunishInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["us_id_borrow"] = this.us_id_borrow;
        data["br_re_de_id"] = this.br_re_de_id;
        data["pun_reason"] = this.pun_reason;
        data["pun_error"] = this.pun_error;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["pun_money"] = this.pun_money;
        return data;
    }

    clone(): CreatePunishInput {
        const json = this.toJSON();
        let result = new CreatePunishInput();
        result.init(json);
        return result;
    }
}

export interface ICreatePunishInput {
    us_id_borrow: number;
    br_re_de_id: number;
    pun_reason: string | undefined;
    pun_error: PunishError;
    fi_id_arr: AttachmentItem[] | undefined;
    pun_money: number;
}

export class CreateReceiptInput implements ICreateReceiptInput {
    rec_reason!: string | undefined;
    rec_import_date!: string | undefined;
    bi_it_id_arr!: number[] | undefined;
    co_id!: number;
    us_id_browser!: number;

    constructor(data?: ICreateReceiptInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rec_reason = _data["rec_reason"];
            this.rec_import_date = _data["rec_import_date"];
            if (Array.isArray(_data["bi_it_id_arr"])) {
                this.bi_it_id_arr = [] as any;
                for (let item of _data["bi_it_id_arr"])
                    this.bi_it_id_arr!.push(item);
            }
            this.co_id = _data["co_id"];
            this.us_id_browser = _data["us_id_browser"];
        }
    }

    static fromJS(data: any): CreateReceiptInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReceiptInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rec_reason"] = this.rec_reason;
        data["rec_import_date"] = this.rec_import_date;
        if (Array.isArray(this.bi_it_id_arr)) {
            data["bi_it_id_arr"] = [];
            for (let item of this.bi_it_id_arr)
                data["bi_it_id_arr"].push(item);
        }
        data["co_id"] = this.co_id;
        data["us_id_browser"] = this.us_id_browser;
        return data;
    }

    clone(): CreateReceiptInput {
        const json = this.toJSON();
        let result = new CreateReceiptInput();
        result.init(json);
        return result;
    }
}

export interface ICreateReceiptInput {
    rec_reason: string | undefined;
    rec_import_date: string | undefined;
    bi_it_id_arr: number[] | undefined;
    co_id: number;
    us_id_browser: number;
}

export class CreateReponsitoryInput implements ICreateReponsitoryInput {
    re_code!: string | undefined;
    re_name!: string | undefined;
    re_desc!: string | undefined;
    re_id_parent!: number;
    re_type!: ReponsitoryType;

    constructor(data?: ICreateReponsitoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_code = _data["re_code"];
            this.re_name = _data["re_name"];
            this.re_desc = _data["re_desc"];
            this.re_id_parent = _data["re_id_parent"];
            this.re_type = _data["re_type"];
        }
    }

    static fromJS(data: any): CreateReponsitoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateReponsitoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_code"] = this.re_code;
        data["re_name"] = this.re_name;
        data["re_desc"] = this.re_desc;
        data["re_id_parent"] = this.re_id_parent;
        data["re_type"] = this.re_type;
        return data;
    }

    clone(): CreateReponsitoryInput {
        const json = this.toJSON();
        let result = new CreateReponsitoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateReponsitoryInput {
    re_code: string | undefined;
    re_name: string | undefined;
    re_desc: string | undefined;
    re_id_parent: number;
    re_type: ReponsitoryType;
}

export class CreateRoleInput implements ICreateRoleInput {
    name!: string;
    displayName!: string;
    normalizedName!: string | undefined;
    description!: string | undefined;
    isDefault!: boolean;
    typeUserRole!: UserType;
    grantedPermissions!: string[] | undefined;

    constructor(data?: ICreateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            this.isDefault = _data["isDefault"];
            this.typeUserRole = _data["typeUserRole"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isDefault"] = this.isDefault;
        data["typeUserRole"] = this.typeUserRole;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): CreateRoleInput {
        const json = this.toJSON();
        let result = new CreateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleInput {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isDefault: boolean;
    typeUserRole: UserType;
    grantedPermissions: string[] | undefined;
}

export class CreateStatisticStorageInput implements ICreateStatisticStorageInput {
    sta_name!: string | undefined;
    sta_code!: string | undefined;
    sta_content!: string | undefined;
    sta_status!: StatisticStorageStatus;
    pr_id!: number;

    constructor(data?: ICreateStatisticStorageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sta_name = _data["sta_name"];
            this.sta_code = _data["sta_code"];
            this.sta_content = _data["sta_content"];
            this.sta_status = _data["sta_status"];
            this.pr_id = _data["pr_id"];
        }
    }

    static fromJS(data: any): CreateStatisticStorageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateStatisticStorageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sta_name"] = this.sta_name;
        data["sta_code"] = this.sta_code;
        data["sta_content"] = this.sta_content;
        data["sta_status"] = this.sta_status;
        data["pr_id"] = this.pr_id;
        return data;
    }

    clone(): CreateStatisticStorageInput {
        const json = this.toJSON();
        let result = new CreateStatisticStorageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateStatisticStorageInput {
    sta_name: string | undefined;
    sta_code: string | undefined;
    sta_content: string | undefined;
    sta_status: StatisticStorageStatus;
    pr_id: number;
}

export class CreateSubFieldMarc21Input implements ICreateSubFieldMarc21Input {
    mar_id!: number;
    sub_code!: string | undefined;
    sub_desc!: string | undefined;

    constructor(data?: ICreateSubFieldMarc21Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mar_id = _data["mar_id"];
            this.sub_code = _data["sub_code"];
            this.sub_desc = _data["sub_desc"];
        }
    }

    static fromJS(data: any): CreateSubFieldMarc21Input {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubFieldMarc21Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mar_id"] = this.mar_id;
        data["sub_code"] = this.sub_code;
        data["sub_desc"] = this.sub_desc;
        return data;
    }

    clone(): CreateSubFieldMarc21Input {
        const json = this.toJSON();
        let result = new CreateSubFieldMarc21Input();
        result.init(json);
        return result;
    }
}

export interface ICreateSubFieldMarc21Input {
    mar_id: number;
    sub_code: string | undefined;
    sub_desc: string | undefined;
}

export class CreateSubFieldWithCodeMarc21Input implements ICreateSubFieldWithCodeMarc21Input {
    mar_code!: string | undefined;
    sub_code!: string | undefined;
    sub_desc!: string | undefined;

    constructor(data?: ICreateSubFieldWithCodeMarc21Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mar_code = _data["mar_code"];
            this.sub_code = _data["sub_code"];
            this.sub_desc = _data["sub_desc"];
        }
    }

    static fromJS(data: any): CreateSubFieldWithCodeMarc21Input {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSubFieldWithCodeMarc21Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mar_code"] = this.mar_code;
        data["sub_code"] = this.sub_code;
        data["sub_desc"] = this.sub_desc;
        return data;
    }

    clone(): CreateSubFieldWithCodeMarc21Input {
        const json = this.toJSON();
        let result = new CreateSubFieldWithCodeMarc21Input();
        result.init(json);
        return result;
    }
}

export interface ICreateSubFieldWithCodeMarc21Input {
    mar_code: string | undefined;
    sub_code: string | undefined;
    sub_desc: string | undefined;
}

export class CreateSupplierInput implements ICreateSupplierInput {
    su_short_name!: string | undefined;
    su_name!: string | undefined;
    su_contact_name!: string | undefined;
    su_contact_possition!: string | undefined;
    su_contact_address!: string | undefined;
    su_contact_phone!: string | undefined;
    su_contact_fax!: string | undefined;
    su_contact_email!: string | undefined;
    su_contact_note!: string | undefined;
    su_tax_code!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: ICreateSupplierInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_short_name = _data["su_short_name"];
            this.su_name = _data["su_name"];
            this.su_contact_name = _data["su_contact_name"];
            this.su_contact_possition = _data["su_contact_possition"];
            this.su_contact_address = _data["su_contact_address"];
            this.su_contact_phone = _data["su_contact_phone"];
            this.su_contact_fax = _data["su_contact_fax"];
            this.su_contact_email = _data["su_contact_email"];
            this.su_contact_note = _data["su_contact_note"];
            this.su_tax_code = _data["su_tax_code"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateSupplierInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSupplierInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_short_name"] = this.su_short_name;
        data["su_name"] = this.su_name;
        data["su_contact_name"] = this.su_contact_name;
        data["su_contact_possition"] = this.su_contact_possition;
        data["su_contact_address"] = this.su_contact_address;
        data["su_contact_phone"] = this.su_contact_phone;
        data["su_contact_fax"] = this.su_contact_fax;
        data["su_contact_email"] = this.su_contact_email;
        data["su_contact_note"] = this.su_contact_note;
        data["su_tax_code"] = this.su_tax_code;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateSupplierInput {
        const json = this.toJSON();
        let result = new CreateSupplierInput();
        result.init(json);
        return result;
    }
}

export interface ICreateSupplierInput {
    su_short_name: string | undefined;
    su_name: string | undefined;
    su_contact_name: string | undefined;
    su_contact_possition: string | undefined;
    su_contact_address: string | undefined;
    su_contact_phone: string | undefined;
    su_contact_fax: string | undefined;
    su_contact_email: string | undefined;
    su_contact_note: string | undefined;
    su_tax_code: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    connectionString!: string | undefined;
    isActive!: boolean;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean;
}

export class CreateTopicInput implements ICreateTopicInput {
    to_name!: string | undefined;
    to_code!: string | undefined;
    to_desc!: string | undefined;

    constructor(data?: ICreateTopicInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.to_name = _data["to_name"];
            this.to_code = _data["to_code"];
            this.to_desc = _data["to_desc"];
        }
    }

    static fromJS(data: any): CreateTopicInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTopicInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["to_name"] = this.to_name;
        data["to_code"] = this.to_code;
        data["to_desc"] = this.to_desc;
        return data;
    }

    clone(): CreateTopicInput {
        const json = this.toJSON();
        let result = new CreateTopicInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTopicInput {
    to_name: string | undefined;
    to_code: string | undefined;
    to_desc: string | undefined;
}

export class CreateUpdateMemberCardSesionInput implements ICreateUpdateMemberCardSesionInput {
    me_ca_use_from!: Date;
    me_ca_use_to!: Date;
    me_ca_level!: number;
    me_ca_type!: MCardType;
    me_ca_time_receive!: Date | undefined;

    constructor(data?: ICreateUpdateMemberCardSesionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_ca_use_from = _data["me_ca_use_from"] ? new Date(_data["me_ca_use_from"].toString()) : <any>undefined;
            this.me_ca_use_to = _data["me_ca_use_to"] ? new Date(_data["me_ca_use_to"].toString()) : <any>undefined;
            this.me_ca_level = _data["me_ca_level"];
            this.me_ca_type = _data["me_ca_type"];
            this.me_ca_time_receive = _data["me_ca_time_receive"] ? new Date(_data["me_ca_time_receive"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUpdateMemberCardSesionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateMemberCardSesionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_ca_use_from"] = this.me_ca_use_from ? this.me_ca_use_from.toISOString() : <any>undefined;
        data["me_ca_use_to"] = this.me_ca_use_to ? this.me_ca_use_to.toISOString() : <any>undefined;
        data["me_ca_level"] = this.me_ca_level;
        data["me_ca_type"] = this.me_ca_type;
        data["me_ca_time_receive"] = this.me_ca_time_receive ? this.me_ca_time_receive.toISOString() : <any>undefined;
        return data;
    }

    clone(): CreateUpdateMemberCardSesionInput {
        const json = this.toJSON();
        let result = new CreateUpdateMemberCardSesionInput();
        result.init(json);
        return result;
    }
}

export interface ICreateUpdateMemberCardSesionInput {
    me_ca_use_from: Date;
    me_ca_use_to: Date;
    me_ca_level: number;
    me_ca_type: MCardType;
    me_ca_time_receive: Date | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName!: string;
    name!: string;
    surname!: string;
    emailAddress!: string;
    isActive!: boolean;
    roleNames!: string[] | undefined;
    password!: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    password: string;
}

export class DashboardDto implements IDashboardDto {
    documentValid!: number;
    documentBorrow!: number;
    documentLost!: number;
    documentBroken!: number;
    borrowsDocuments!: number;
    extendDocuments!: number;
    dueDateDocuments!: number;
    lostDocuments!: number;
    needRecoveredDocuments!: number;
    registerMembers!: number;
    acceptMembers!: number;
    rejectMembers!: number;
    lockMembers!: number;
    registerMemberCards!: number;
    creatingMemberCards!: number;
    debtDocumentMemberCards!: number;
    timeUpMemberCards!: number;
    lockMemberCards!: number;
    childMemberCards!: number;
    adultMemberCards!: number;
    contractCreate!: number;
    contractDoing!: number;
    contractDone!: number;
    planCreate!: number;
    planDoing!: number;
    planDone!: number;
    checkCreate!: number;
    checkDoing!: number;
    checkDone!: number;
    chartDashboardDto!: ChartDashboardDto[] | undefined;

    constructor(data?: IDashboardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentValid = _data["documentValid"];
            this.documentBorrow = _data["documentBorrow"];
            this.documentLost = _data["documentLost"];
            this.documentBroken = _data["documentBroken"];
            this.borrowsDocuments = _data["borrowsDocuments"];
            this.extendDocuments = _data["extendDocuments"];
            this.dueDateDocuments = _data["dueDateDocuments"];
            this.lostDocuments = _data["lostDocuments"];
            this.needRecoveredDocuments = _data["needRecoveredDocuments"];
            this.registerMembers = _data["registerMembers"];
            this.acceptMembers = _data["acceptMembers"];
            this.rejectMembers = _data["rejectMembers"];
            this.lockMembers = _data["lockMembers"];
            this.registerMemberCards = _data["registerMemberCards"];
            this.creatingMemberCards = _data["creatingMemberCards"];
            this.debtDocumentMemberCards = _data["debtDocumentMemberCards"];
            this.timeUpMemberCards = _data["timeUpMemberCards"];
            this.lockMemberCards = _data["lockMemberCards"];
            this.childMemberCards = _data["childMemberCards"];
            this.adultMemberCards = _data["adultMemberCards"];
            this.contractCreate = _data["contractCreate"];
            this.contractDoing = _data["contractDoing"];
            this.contractDone = _data["contractDone"];
            this.planCreate = _data["planCreate"];
            this.planDoing = _data["planDoing"];
            this.planDone = _data["planDone"];
            this.checkCreate = _data["checkCreate"];
            this.checkDoing = _data["checkDoing"];
            this.checkDone = _data["checkDone"];
            if (Array.isArray(_data["chartDashboardDto"])) {
                this.chartDashboardDto = [] as any;
                for (let item of _data["chartDashboardDto"])
                    this.chartDashboardDto!.push(ChartDashboardDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardDto {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentValid"] = this.documentValid;
        data["documentBorrow"] = this.documentBorrow;
        data["documentLost"] = this.documentLost;
        data["documentBroken"] = this.documentBroken;
        data["borrowsDocuments"] = this.borrowsDocuments;
        data["extendDocuments"] = this.extendDocuments;
        data["dueDateDocuments"] = this.dueDateDocuments;
        data["lostDocuments"] = this.lostDocuments;
        data["needRecoveredDocuments"] = this.needRecoveredDocuments;
        data["registerMembers"] = this.registerMembers;
        data["acceptMembers"] = this.acceptMembers;
        data["rejectMembers"] = this.rejectMembers;
        data["lockMembers"] = this.lockMembers;
        data["registerMemberCards"] = this.registerMemberCards;
        data["creatingMemberCards"] = this.creatingMemberCards;
        data["debtDocumentMemberCards"] = this.debtDocumentMemberCards;
        data["timeUpMemberCards"] = this.timeUpMemberCards;
        data["lockMemberCards"] = this.lockMemberCards;
        data["childMemberCards"] = this.childMemberCards;
        data["adultMemberCards"] = this.adultMemberCards;
        data["contractCreate"] = this.contractCreate;
        data["contractDoing"] = this.contractDoing;
        data["contractDone"] = this.contractDone;
        data["planCreate"] = this.planCreate;
        data["planDoing"] = this.planDoing;
        data["planDone"] = this.planDone;
        data["checkCreate"] = this.checkCreate;
        data["checkDoing"] = this.checkDoing;
        data["checkDone"] = this.checkDone;
        if (Array.isArray(this.chartDashboardDto)) {
            data["chartDashboardDto"] = [];
            for (let item of this.chartDashboardDto)
                data["chartDashboardDto"].push(item.toJSON());
        }
        return data;
    }

    clone(): DashboardDto {
        const json = this.toJSON();
        let result = new DashboardDto();
        result.init(json);
        return result;
    }
}

export interface IDashboardDto {
    documentValid: number;
    documentBorrow: number;
    documentLost: number;
    documentBroken: number;
    borrowsDocuments: number;
    extendDocuments: number;
    dueDateDocuments: number;
    lostDocuments: number;
    needRecoveredDocuments: number;
    registerMembers: number;
    acceptMembers: number;
    rejectMembers: number;
    lockMembers: number;
    registerMemberCards: number;
    creatingMemberCards: number;
    debtDocumentMemberCards: number;
    timeUpMemberCards: number;
    lockMemberCards: number;
    childMemberCards: number;
    adultMemberCards: number;
    contractCreate: number;
    contractDoing: number;
    contractDone: number;
    planCreate: number;
    planDoing: number;
    planDone: number;
    checkCreate: number;
    checkDoing: number;
    checkDone: number;
    chartDashboardDto: ChartDashboardDto[] | undefined;
}

export class DeliveryBorrowReturningDetailItem implements IDeliveryBorrowReturningDetailItem {
    br_re_de_id!: number;
    do_id!: number;
    do_in_id!: number;

    constructor(data?: IDeliveryBorrowReturningDetailItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_de_id = _data["br_re_de_id"];
            this.do_id = _data["do_id"];
            this.do_in_id = _data["do_in_id"];
        }
    }

    static fromJS(data: any): DeliveryBorrowReturningDetailItem {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryBorrowReturningDetailItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_de_id"] = this.br_re_de_id;
        data["do_id"] = this.do_id;
        data["do_in_id"] = this.do_in_id;
        return data;
    }

    clone(): DeliveryBorrowReturningDetailItem {
        const json = this.toJSON();
        let result = new DeliveryBorrowReturningDetailItem();
        result.init(json);
        return result;
    }
}

export interface IDeliveryBorrowReturningDetailItem {
    br_re_de_id: number;
    do_id: number;
    do_in_id: number;
}

export class DeliveryDocumentInput implements IDeliveryDocumentInput {
    br_re_id!: number;
    fi_id_arr!: AttachmentItem[] | undefined;
    list_document!: DeliveryBorrowReturningDetailItem[] | undefined;

    constructor(data?: IDeliveryDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_id = _data["br_re_id"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["list_document"])) {
                this.list_document = [] as any;
                for (let item of _data["list_document"])
                    this.list_document!.push(DeliveryBorrowReturningDetailItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DeliveryDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new DeliveryDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_id"] = this.br_re_id;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.list_document)) {
            data["list_document"] = [];
            for (let item of this.list_document)
                data["list_document"].push(item.toJSON());
        }
        return data;
    }

    clone(): DeliveryDocumentInput {
        const json = this.toJSON();
        let result = new DeliveryDocumentInput();
        result.init(json);
        return result;
    }
}

export interface IDeliveryDocumentInput {
    br_re_id: number;
    fi_id_arr: AttachmentItem[] | undefined;
    list_document: DeliveryBorrowReturningDetailItem[] | undefined;
}

export class DictionariesDto implements IDictionariesDto {
    dic_id!: number;
    dic_ty_id!: number;
    dic_name!: string | undefined;
    dic_short_des!: string | undefined;
    dic_desc!: string | undefined;
    fi_id_symbol!: AttachmentItem;
    dic_ref!: string | undefined;
    dic_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;

    constructor(data?: IDictionariesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dic_id = _data["dic_id"];
            this.dic_ty_id = _data["dic_ty_id"];
            this.dic_name = _data["dic_name"];
            this.dic_short_des = _data["dic_short_des"];
            this.dic_desc = _data["dic_desc"];
            this.fi_id_symbol = _data["fi_id_symbol"] ? AttachmentItem.fromJS(_data["fi_id_symbol"]) : <any>undefined;
            this.dic_ref = _data["dic_ref"];
            this.dic_is_delete = _data["dic_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
        }
    }

    static fromJS(data: any): DictionariesDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictionariesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dic_id"] = this.dic_id;
        data["dic_ty_id"] = this.dic_ty_id;
        data["dic_name"] = this.dic_name;
        data["dic_short_des"] = this.dic_short_des;
        data["dic_desc"] = this.dic_desc;
        data["fi_id_symbol"] = this.fi_id_symbol ? this.fi_id_symbol.toJSON() : <any>undefined;
        data["dic_ref"] = this.dic_ref;
        data["dic_is_delete"] = this.dic_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        return data;
    }

    clone(): DictionariesDto {
        const json = this.toJSON();
        let result = new DictionariesDto();
        result.init(json);
        return result;
    }
}

export interface IDictionariesDto {
    dic_id: number;
    dic_ty_id: number;
    dic_name: string | undefined;
    dic_short_des: string | undefined;
    dic_desc: string | undefined;
    fi_id_symbol: AttachmentItem;
    dic_ref: string | undefined;
    dic_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
}

export class DictionariesDtoPagedResultDto implements IDictionariesDtoPagedResultDto {
    items!: DictionariesDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDictionariesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DictionariesDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DictionariesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictionariesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DictionariesDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DictionariesDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDictionariesDtoPagedResultDto {
    items: DictionariesDto[] | undefined;
    totalCount: number;
}

export class DictionaryTypeAbtractDto implements IDictionaryTypeAbtractDto {
    dic_ty_id!: number;
    dic_ty_name!: string | undefined;
    dic_ty_desc!: string | undefined;
    dic_ty_is_active!: boolean;
    dic_ty_is_delete!: boolean;

    constructor(data?: IDictionaryTypeAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dic_ty_id = _data["dic_ty_id"];
            this.dic_ty_name = _data["dic_ty_name"];
            this.dic_ty_desc = _data["dic_ty_desc"];
            this.dic_ty_is_active = _data["dic_ty_is_active"];
            this.dic_ty_is_delete = _data["dic_ty_is_delete"];
        }
    }

    static fromJS(data: any): DictionaryTypeAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictionaryTypeAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dic_ty_id"] = this.dic_ty_id;
        data["dic_ty_name"] = this.dic_ty_name;
        data["dic_ty_desc"] = this.dic_ty_desc;
        data["dic_ty_is_active"] = this.dic_ty_is_active;
        data["dic_ty_is_delete"] = this.dic_ty_is_delete;
        return data;
    }

    clone(): DictionaryTypeAbtractDto {
        const json = this.toJSON();
        let result = new DictionaryTypeAbtractDto();
        result.init(json);
        return result;
    }
}

export interface IDictionaryTypeAbtractDto {
    dic_ty_id: number;
    dic_ty_name: string | undefined;
    dic_ty_desc: string | undefined;
    dic_ty_is_active: boolean;
    dic_ty_is_delete: boolean;
}

export class DictionaryTypeDto implements IDictionaryTypeDto {
    dic_ty_id!: number;
    dic_ty_name!: string | undefined;
    dic_ty_desc!: string | undefined;
    dic_ty_is_active!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    dic_ty_created_at!: Date;
    dic_ty_updated_at!: Date;

    constructor(data?: IDictionaryTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dic_ty_id = _data["dic_ty_id"];
            this.dic_ty_name = _data["dic_ty_name"];
            this.dic_ty_desc = _data["dic_ty_desc"];
            this.dic_ty_is_active = _data["dic_ty_is_active"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.dic_ty_created_at = _data["dic_ty_created_at"] ? new Date(_data["dic_ty_created_at"].toString()) : <any>undefined;
            this.dic_ty_updated_at = _data["dic_ty_updated_at"] ? new Date(_data["dic_ty_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DictionaryTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictionaryTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dic_ty_id"] = this.dic_ty_id;
        data["dic_ty_name"] = this.dic_ty_name;
        data["dic_ty_desc"] = this.dic_ty_desc;
        data["dic_ty_is_active"] = this.dic_ty_is_active;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["dic_ty_created_at"] = this.dic_ty_created_at ? this.dic_ty_created_at.toISOString() : <any>undefined;
        data["dic_ty_updated_at"] = this.dic_ty_updated_at ? this.dic_ty_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): DictionaryTypeDto {
        const json = this.toJSON();
        let result = new DictionaryTypeDto();
        result.init(json);
        return result;
    }
}

export interface IDictionaryTypeDto {
    dic_ty_id: number;
    dic_ty_name: string | undefined;
    dic_ty_desc: string | undefined;
    dic_ty_is_active: boolean;
    us_id_created: number;
    us_id_updated: number;
    dic_ty_created_at: Date;
    dic_ty_updated_at: Date;
}

export class DictionaryTypeDtoPagedResultDto implements IDictionaryTypeDtoPagedResultDto {
    items!: DictionaryTypeDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDictionaryTypeDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DictionaryTypeDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DictionaryTypeDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DictionaryTypeDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DictionaryTypeDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DictionaryTypeDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDictionaryTypeDtoPagedResultDto {
    items: DictionaryTypeDto[] | undefined;
    totalCount: number;
}

export class Document implements IDocument {
    id!: number;
    readonly do_id!: number;
    do_title!: string | undefined;
    do_date_publish!: string | undefined;
    do_republish!: number;
    do_identifier!: string | undefined;
    do_identifier_citation!: string | undefined;
    do_abstract!: string | undefined;
    do_language_iso!: string | undefined;
    do_translator!: string | undefined;
    do_period_check!: number;
    do_lastest_check!: Date;
    do_date_available!: Date;
    do_nr_pages!: number;
    do_type!: DocumentType;
    fie_id_arr!: string | undefined;
    fi_id_arr_cover!: string | undefined;
    au_id_arr!: string | undefined;
    pu_id!: string | undefined;
    to_id!: number;
    ca_id!: number;
    do_is_hot!: boolean;
    do_num_view!: number;
    do_num_dowload!: number;
    do_num_borrow!: number;
    do_status!: DocumentStatus;
    do_borrow_status!: DocumentBorrowType;
    do_price!: number;
    do_total_book!: number;
    do_total_book_valid!: number;
    do_total_user_register!: number;
    do_remaining_book!: number;
    do_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    do_created_at!: Date;
    do_updated_at!: Date;
    do_delete_at!: Date | undefined;
    borrowReturnings!: BorrowReturning[] | undefined;
    borrowReturningLogs!: BorrowReturningLog[] | undefined;
    fileDocuments!: FileDocument[] | undefined;

    constructor(data?: IDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).do_id = _data["do_id"];
            this.do_title = _data["do_title"];
            this.do_date_publish = _data["do_date_publish"];
            this.do_republish = _data["do_republish"];
            this.do_identifier = _data["do_identifier"];
            this.do_identifier_citation = _data["do_identifier_citation"];
            this.do_abstract = _data["do_abstract"];
            this.do_language_iso = _data["do_language_iso"];
            this.do_translator = _data["do_translator"];
            this.do_period_check = _data["do_period_check"];
            this.do_lastest_check = _data["do_lastest_check"] ? new Date(_data["do_lastest_check"].toString()) : <any>undefined;
            this.do_date_available = _data["do_date_available"] ? new Date(_data["do_date_available"].toString()) : <any>undefined;
            this.do_nr_pages = _data["do_nr_pages"];
            this.do_type = _data["do_type"];
            this.fie_id_arr = _data["fie_id_arr"];
            this.fi_id_arr_cover = _data["fi_id_arr_cover"];
            this.au_id_arr = _data["au_id_arr"];
            this.pu_id = _data["pu_id"];
            this.to_id = _data["to_id"];
            this.ca_id = _data["ca_id"];
            this.do_is_hot = _data["do_is_hot"];
            this.do_num_view = _data["do_num_view"];
            this.do_num_dowload = _data["do_num_dowload"];
            this.do_num_borrow = _data["do_num_borrow"];
            this.do_status = _data["do_status"];
            this.do_borrow_status = _data["do_borrow_status"];
            this.do_price = _data["do_price"];
            this.do_total_book = _data["do_total_book"];
            this.do_total_book_valid = _data["do_total_book_valid"];
            this.do_total_user_register = _data["do_total_user_register"];
            this.do_remaining_book = _data["do_remaining_book"];
            this.do_is_delete = _data["do_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            this.do_created_at = _data["do_created_at"] ? new Date(_data["do_created_at"].toString()) : <any>undefined;
            this.do_updated_at = _data["do_updated_at"] ? new Date(_data["do_updated_at"].toString()) : <any>undefined;
            this.do_delete_at = _data["do_delete_at"] ? new Date(_data["do_delete_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["borrowReturnings"])) {
                this.borrowReturnings = [] as any;
                for (let item of _data["borrowReturnings"])
                    this.borrowReturnings!.push(BorrowReturning.fromJS(item));
            }
            if (Array.isArray(_data["borrowReturningLogs"])) {
                this.borrowReturningLogs = [] as any;
                for (let item of _data["borrowReturningLogs"])
                    this.borrowReturningLogs!.push(BorrowReturningLog.fromJS(item));
            }
            if (Array.isArray(_data["fileDocuments"])) {
                this.fileDocuments = [] as any;
                for (let item of _data["fileDocuments"])
                    this.fileDocuments!.push(FileDocument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Document {
        data = typeof data === 'object' ? data : {};
        let result = new Document();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["do_id"] = this.do_id;
        data["do_title"] = this.do_title;
        data["do_date_publish"] = this.do_date_publish;
        data["do_republish"] = this.do_republish;
        data["do_identifier"] = this.do_identifier;
        data["do_identifier_citation"] = this.do_identifier_citation;
        data["do_abstract"] = this.do_abstract;
        data["do_language_iso"] = this.do_language_iso;
        data["do_translator"] = this.do_translator;
        data["do_period_check"] = this.do_period_check;
        data["do_lastest_check"] = this.do_lastest_check ? this.do_lastest_check.toISOString() : <any>undefined;
        data["do_date_available"] = this.do_date_available ? this.do_date_available.toISOString() : <any>undefined;
        data["do_nr_pages"] = this.do_nr_pages;
        data["do_type"] = this.do_type;
        data["fie_id_arr"] = this.fie_id_arr;
        data["fi_id_arr_cover"] = this.fi_id_arr_cover;
        data["au_id_arr"] = this.au_id_arr;
        data["pu_id"] = this.pu_id;
        data["to_id"] = this.to_id;
        data["ca_id"] = this.ca_id;
        data["do_is_hot"] = this.do_is_hot;
        data["do_num_view"] = this.do_num_view;
        data["do_num_dowload"] = this.do_num_dowload;
        data["do_num_borrow"] = this.do_num_borrow;
        data["do_status"] = this.do_status;
        data["do_borrow_status"] = this.do_borrow_status;
        data["do_price"] = this.do_price;
        data["do_total_book"] = this.do_total_book;
        data["do_total_book_valid"] = this.do_total_book_valid;
        data["do_total_user_register"] = this.do_total_user_register;
        data["do_remaining_book"] = this.do_remaining_book;
        data["do_is_delete"] = this.do_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        data["do_created_at"] = this.do_created_at ? this.do_created_at.toISOString() : <any>undefined;
        data["do_updated_at"] = this.do_updated_at ? this.do_updated_at.toISOString() : <any>undefined;
        data["do_delete_at"] = this.do_delete_at ? this.do_delete_at.toISOString() : <any>undefined;
        if (Array.isArray(this.borrowReturnings)) {
            data["borrowReturnings"] = [];
            for (let item of this.borrowReturnings)
                data["borrowReturnings"].push(item.toJSON());
        }
        if (Array.isArray(this.borrowReturningLogs)) {
            data["borrowReturningLogs"] = [];
            for (let item of this.borrowReturningLogs)
                data["borrowReturningLogs"].push(item.toJSON());
        }
        if (Array.isArray(this.fileDocuments)) {
            data["fileDocuments"] = [];
            for (let item of this.fileDocuments)
                data["fileDocuments"].push(item.toJSON());
        }
        return data;
    }

    clone(): Document {
        const json = this.toJSON();
        let result = new Document();
        result.init(json);
        return result;
    }
}

export interface IDocument {
    id: number;
    do_id: number;
    do_title: string | undefined;
    do_date_publish: string | undefined;
    do_republish: number;
    do_identifier: string | undefined;
    do_identifier_citation: string | undefined;
    do_abstract: string | undefined;
    do_language_iso: string | undefined;
    do_translator: string | undefined;
    do_period_check: number;
    do_lastest_check: Date;
    do_date_available: Date;
    do_nr_pages: number;
    do_type: DocumentType;
    fie_id_arr: string | undefined;
    fi_id_arr_cover: string | undefined;
    au_id_arr: string | undefined;
    pu_id: string | undefined;
    to_id: number;
    ca_id: number;
    do_is_hot: boolean;
    do_num_view: number;
    do_num_dowload: number;
    do_num_borrow: number;
    do_status: DocumentStatus;
    do_borrow_status: DocumentBorrowType;
    do_price: number;
    do_total_book: number;
    do_total_book_valid: number;
    do_total_user_register: number;
    do_remaining_book: number;
    do_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    do_created_at: Date;
    do_updated_at: Date;
    do_delete_at: Date | undefined;
    borrowReturnings: BorrowReturning[] | undefined;
    borrowReturningLogs: BorrowReturningLog[] | undefined;
    fileDocuments: FileDocument[] | undefined;
}

export class DocumentBorrowDto implements IDocumentBorrowDto {
    do_id!: number;
    do_title!: string | undefined;
    do_date_publish!: string | undefined;
    do_republish!: number;
    do_identifier!: string | undefined;
    do_date_available!: Date;
    do_identifier_citation!: string | undefined;
    do_abstract!: string | undefined;
    languages!: ItemLanguages[] | undefined;
    do_nr_pages!: number;
    fields_arr!: ItemField[] | undefined;
    fi_id_arr_cover!: AttachmentItem[] | undefined;
    authors_arr!: ItemAuthor[] | undefined;
    publisher!: ItemPublisher;
    to_id!: number;
    ca_id!: number;
    topic!: TopicDto;
    category!: CategoryDto;
    fileDocuments!: FileDocumentDto[] | undefined;
    do_num_view!: number;
    do_num_dowload!: number;
    do_num_borrow!: number;
    do_status!: DocumentStatus;
    do_price!: number;
    re_id!: number;
    do_total_book!: number;
    do_total_user_register!: number;
    do_total_book_valid!: number;
    do_remaining_book!: number;
    do_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    do_created_at!: Date;
    do_updated_at!: Date;
    do_delete_at!: Date;

    constructor(data?: IDocumentBorrowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_id = _data["do_id"];
            this.do_title = _data["do_title"];
            this.do_date_publish = _data["do_date_publish"];
            this.do_republish = _data["do_republish"];
            this.do_identifier = _data["do_identifier"];
            this.do_date_available = _data["do_date_available"] ? new Date(_data["do_date_available"].toString()) : <any>undefined;
            this.do_identifier_citation = _data["do_identifier_citation"];
            this.do_abstract = _data["do_abstract"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(ItemLanguages.fromJS(item));
            }
            this.do_nr_pages = _data["do_nr_pages"];
            if (Array.isArray(_data["fields_arr"])) {
                this.fields_arr = [] as any;
                for (let item of _data["fields_arr"])
                    this.fields_arr!.push(ItemField.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_arr_cover"])) {
                this.fi_id_arr_cover = [] as any;
                for (let item of _data["fi_id_arr_cover"])
                    this.fi_id_arr_cover!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["authors_arr"])) {
                this.authors_arr = [] as any;
                for (let item of _data["authors_arr"])
                    this.authors_arr!.push(ItemAuthor.fromJS(item));
            }
            this.publisher = _data["publisher"] ? ItemPublisher.fromJS(_data["publisher"]) : <any>undefined;
            this.to_id = _data["to_id"];
            this.ca_id = _data["ca_id"];
            this.topic = _data["topic"] ? TopicDto.fromJS(_data["topic"]) : <any>undefined;
            this.category = _data["category"] ? CategoryDto.fromJS(_data["category"]) : <any>undefined;
            if (Array.isArray(_data["fileDocuments"])) {
                this.fileDocuments = [] as any;
                for (let item of _data["fileDocuments"])
                    this.fileDocuments!.push(FileDocumentDto.fromJS(item));
            }
            this.do_num_view = _data["do_num_view"];
            this.do_num_dowload = _data["do_num_dowload"];
            this.do_num_borrow = _data["do_num_borrow"];
            this.do_status = _data["do_status"];
            this.do_price = _data["do_price"];
            this.re_id = _data["re_id"];
            this.do_total_book = _data["do_total_book"];
            this.do_total_user_register = _data["do_total_user_register"];
            this.do_total_book_valid = _data["do_total_book_valid"];
            this.do_remaining_book = _data["do_remaining_book"];
            this.do_is_delete = _data["do_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            this.do_created_at = _data["do_created_at"] ? new Date(_data["do_created_at"].toString()) : <any>undefined;
            this.do_updated_at = _data["do_updated_at"] ? new Date(_data["do_updated_at"].toString()) : <any>undefined;
            this.do_delete_at = _data["do_delete_at"] ? new Date(_data["do_delete_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentBorrowDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentBorrowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_id"] = this.do_id;
        data["do_title"] = this.do_title;
        data["do_date_publish"] = this.do_date_publish;
        data["do_republish"] = this.do_republish;
        data["do_identifier"] = this.do_identifier;
        data["do_date_available"] = this.do_date_available ? this.do_date_available.toISOString() : <any>undefined;
        data["do_identifier_citation"] = this.do_identifier_citation;
        data["do_abstract"] = this.do_abstract;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["do_nr_pages"] = this.do_nr_pages;
        if (Array.isArray(this.fields_arr)) {
            data["fields_arr"] = [];
            for (let item of this.fields_arr)
                data["fields_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_arr_cover)) {
            data["fi_id_arr_cover"] = [];
            for (let item of this.fi_id_arr_cover)
                data["fi_id_arr_cover"].push(item.toJSON());
        }
        if (Array.isArray(this.authors_arr)) {
            data["authors_arr"] = [];
            for (let item of this.authors_arr)
                data["authors_arr"].push(item.toJSON());
        }
        data["publisher"] = this.publisher ? this.publisher.toJSON() : <any>undefined;
        data["to_id"] = this.to_id;
        data["ca_id"] = this.ca_id;
        data["topic"] = this.topic ? this.topic.toJSON() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.fileDocuments)) {
            data["fileDocuments"] = [];
            for (let item of this.fileDocuments)
                data["fileDocuments"].push(item.toJSON());
        }
        data["do_num_view"] = this.do_num_view;
        data["do_num_dowload"] = this.do_num_dowload;
        data["do_num_borrow"] = this.do_num_borrow;
        data["do_status"] = this.do_status;
        data["do_price"] = this.do_price;
        data["re_id"] = this.re_id;
        data["do_total_book"] = this.do_total_book;
        data["do_total_user_register"] = this.do_total_user_register;
        data["do_total_book_valid"] = this.do_total_book_valid;
        data["do_remaining_book"] = this.do_remaining_book;
        data["do_is_delete"] = this.do_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        data["do_created_at"] = this.do_created_at ? this.do_created_at.toISOString() : <any>undefined;
        data["do_updated_at"] = this.do_updated_at ? this.do_updated_at.toISOString() : <any>undefined;
        data["do_delete_at"] = this.do_delete_at ? this.do_delete_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): DocumentBorrowDto {
        const json = this.toJSON();
        let result = new DocumentBorrowDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentBorrowDto {
    do_id: number;
    do_title: string | undefined;
    do_date_publish: string | undefined;
    do_republish: number;
    do_identifier: string | undefined;
    do_date_available: Date;
    do_identifier_citation: string | undefined;
    do_abstract: string | undefined;
    languages: ItemLanguages[] | undefined;
    do_nr_pages: number;
    fields_arr: ItemField[] | undefined;
    fi_id_arr_cover: AttachmentItem[] | undefined;
    authors_arr: ItemAuthor[] | undefined;
    publisher: ItemPublisher;
    to_id: number;
    ca_id: number;
    topic: TopicDto;
    category: CategoryDto;
    fileDocuments: FileDocumentDto[] | undefined;
    do_num_view: number;
    do_num_dowload: number;
    do_num_borrow: number;
    do_status: DocumentStatus;
    do_price: number;
    re_id: number;
    do_total_book: number;
    do_total_user_register: number;
    do_total_book_valid: number;
    do_remaining_book: number;
    do_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    do_created_at: Date;
    do_updated_at: Date;
    do_delete_at: Date;
}

export class DocumentBorrowDtoPagedResultDto implements IDocumentBorrowDtoPagedResultDto {
    items!: DocumentBorrowDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDocumentBorrowDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocumentBorrowDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DocumentBorrowDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentBorrowDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DocumentBorrowDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DocumentBorrowDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentBorrowDtoPagedResultDto {
    items: DocumentBorrowDto[] | undefined;
    totalCount: number;
}

export enum DocumentBorrowType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class DocumentDto implements IDocumentDto {
    do_id!: number;
    do_title!: string | undefined;
    do_date_publish!: string | undefined;
    do_republish!: number;
    do_identifier!: string | undefined;
    do_translator!: string | undefined;
    do_identifier_citation!: string | undefined;
    do_abstract!: string | undefined;
    do_language_iso!: ItemLanguages[] | undefined;
    do_period_check!: number;
    do_lastest_check!: Date;
    do_date_available!: Date | undefined;
    do_nr_pages!: number;
    fie_id_arr!: ItemField[] | undefined;
    fi_id_arr_cover!: AttachmentItem[] | undefined;
    au_id_arr!: ItemAuthor[] | undefined;
    pu_id!: ItemPublisher;
    to_id!: number;
    ca_id!: number;
    do_num_view!: number;
    do_num_dowload!: number;
    do_num_borrow!: number;
    do_status!: DocumentStatus;
    do_borrow_status!: DocumentBorrowType;
    do_price!: number;
    do_total_book!: number;
    do_total_user_register!: number;
    do_total_book_valid!: number;
    do_remaining_book!: number;
    do_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    fileDocuments!: FileDocumentDto[] | undefined;
    do_created_at!: Date;
    do_updated_at!: Date;
    do_delete_at!: Date;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_id = _data["do_id"];
            this.do_title = _data["do_title"];
            this.do_date_publish = _data["do_date_publish"];
            this.do_republish = _data["do_republish"];
            this.do_identifier = _data["do_identifier"];
            this.do_translator = _data["do_translator"];
            this.do_identifier_citation = _data["do_identifier_citation"];
            this.do_abstract = _data["do_abstract"];
            if (Array.isArray(_data["do_language_iso"])) {
                this.do_language_iso = [] as any;
                for (let item of _data["do_language_iso"])
                    this.do_language_iso!.push(ItemLanguages.fromJS(item));
            }
            this.do_period_check = _data["do_period_check"];
            this.do_lastest_check = _data["do_lastest_check"] ? new Date(_data["do_lastest_check"].toString()) : <any>undefined;
            this.do_date_available = _data["do_date_available"] ? new Date(_data["do_date_available"].toString()) : <any>undefined;
            this.do_nr_pages = _data["do_nr_pages"];
            if (Array.isArray(_data["fie_id_arr"])) {
                this.fie_id_arr = [] as any;
                for (let item of _data["fie_id_arr"])
                    this.fie_id_arr!.push(ItemField.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_arr_cover"])) {
                this.fi_id_arr_cover = [] as any;
                for (let item of _data["fi_id_arr_cover"])
                    this.fi_id_arr_cover!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["au_id_arr"])) {
                this.au_id_arr = [] as any;
                for (let item of _data["au_id_arr"])
                    this.au_id_arr!.push(ItemAuthor.fromJS(item));
            }
            this.pu_id = _data["pu_id"] ? ItemPublisher.fromJS(_data["pu_id"]) : <any>undefined;
            this.to_id = _data["to_id"];
            this.ca_id = _data["ca_id"];
            this.do_num_view = _data["do_num_view"];
            this.do_num_dowload = _data["do_num_dowload"];
            this.do_num_borrow = _data["do_num_borrow"];
            this.do_status = _data["do_status"];
            this.do_borrow_status = _data["do_borrow_status"];
            this.do_price = _data["do_price"];
            this.do_total_book = _data["do_total_book"];
            this.do_total_user_register = _data["do_total_user_register"];
            this.do_total_book_valid = _data["do_total_book_valid"];
            this.do_remaining_book = _data["do_remaining_book"];
            this.do_is_delete = _data["do_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            if (Array.isArray(_data["fileDocuments"])) {
                this.fileDocuments = [] as any;
                for (let item of _data["fileDocuments"])
                    this.fileDocuments!.push(FileDocumentDto.fromJS(item));
            }
            this.do_created_at = _data["do_created_at"] ? new Date(_data["do_created_at"].toString()) : <any>undefined;
            this.do_updated_at = _data["do_updated_at"] ? new Date(_data["do_updated_at"].toString()) : <any>undefined;
            this.do_delete_at = _data["do_delete_at"] ? new Date(_data["do_delete_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_id"] = this.do_id;
        data["do_title"] = this.do_title;
        data["do_date_publish"] = this.do_date_publish;
        data["do_republish"] = this.do_republish;
        data["do_identifier"] = this.do_identifier;
        data["do_translator"] = this.do_translator;
        data["do_identifier_citation"] = this.do_identifier_citation;
        data["do_abstract"] = this.do_abstract;
        if (Array.isArray(this.do_language_iso)) {
            data["do_language_iso"] = [];
            for (let item of this.do_language_iso)
                data["do_language_iso"].push(item.toJSON());
        }
        data["do_period_check"] = this.do_period_check;
        data["do_lastest_check"] = this.do_lastest_check ? this.do_lastest_check.toISOString() : <any>undefined;
        data["do_date_available"] = this.do_date_available ? this.do_date_available.toISOString() : <any>undefined;
        data["do_nr_pages"] = this.do_nr_pages;
        if (Array.isArray(this.fie_id_arr)) {
            data["fie_id_arr"] = [];
            for (let item of this.fie_id_arr)
                data["fie_id_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_arr_cover)) {
            data["fi_id_arr_cover"] = [];
            for (let item of this.fi_id_arr_cover)
                data["fi_id_arr_cover"].push(item.toJSON());
        }
        if (Array.isArray(this.au_id_arr)) {
            data["au_id_arr"] = [];
            for (let item of this.au_id_arr)
                data["au_id_arr"].push(item.toJSON());
        }
        data["pu_id"] = this.pu_id ? this.pu_id.toJSON() : <any>undefined;
        data["to_id"] = this.to_id;
        data["ca_id"] = this.ca_id;
        data["do_num_view"] = this.do_num_view;
        data["do_num_dowload"] = this.do_num_dowload;
        data["do_num_borrow"] = this.do_num_borrow;
        data["do_status"] = this.do_status;
        data["do_borrow_status"] = this.do_borrow_status;
        data["do_price"] = this.do_price;
        data["do_total_book"] = this.do_total_book;
        data["do_total_user_register"] = this.do_total_user_register;
        data["do_total_book_valid"] = this.do_total_book_valid;
        data["do_remaining_book"] = this.do_remaining_book;
        data["do_is_delete"] = this.do_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        if (Array.isArray(this.fileDocuments)) {
            data["fileDocuments"] = [];
            for (let item of this.fileDocuments)
                data["fileDocuments"].push(item.toJSON());
        }
        data["do_created_at"] = this.do_created_at ? this.do_created_at.toISOString() : <any>undefined;
        data["do_updated_at"] = this.do_updated_at ? this.do_updated_at.toISOString() : <any>undefined;
        data["do_delete_at"] = this.do_delete_at ? this.do_delete_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): DocumentDto {
        const json = this.toJSON();
        let result = new DocumentDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentDto {
    do_id: number;
    do_title: string | undefined;
    do_date_publish: string | undefined;
    do_republish: number;
    do_identifier: string | undefined;
    do_translator: string | undefined;
    do_identifier_citation: string | undefined;
    do_abstract: string | undefined;
    do_language_iso: ItemLanguages[] | undefined;
    do_period_check: number;
    do_lastest_check: Date;
    do_date_available: Date | undefined;
    do_nr_pages: number;
    fie_id_arr: ItemField[] | undefined;
    fi_id_arr_cover: AttachmentItem[] | undefined;
    au_id_arr: ItemAuthor[] | undefined;
    pu_id: ItemPublisher;
    to_id: number;
    ca_id: number;
    do_num_view: number;
    do_num_dowload: number;
    do_num_borrow: number;
    do_status: DocumentStatus;
    do_borrow_status: DocumentBorrowType;
    do_price: number;
    do_total_book: number;
    do_total_user_register: number;
    do_total_book_valid: number;
    do_remaining_book: number;
    do_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    fileDocuments: FileDocumentDto[] | undefined;
    do_created_at: Date;
    do_updated_at: Date;
    do_delete_at: Date;
}

export class DocumentDtoPagedResultDto implements IDocumentDtoPagedResultDto {
    items!: DocumentDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDocumentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocumentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DocumentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DocumentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DocumentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentDtoPagedResultDto {
    items: DocumentDto[] | undefined;
    totalCount: number;
}

export class DocumentInforDto implements IDocumentInforDto {
    do_in_id!: number;
    do_id!: number;
    do_in_status!: DocumentItemStatus;
    do_in_note!: string | undefined;
    do_in_isbn!: string | undefined;
    dkcb_code!: string | undefined;
    do_is_delete!: boolean;
    do_in_is_check!: boolean;
    us_id_delete!: number;
    us_id_created!: number;
    us_id_updated!: number;
    do_delete_at!: Date | undefined;
    do_updated_at!: Date;
    do_created_at!: Date;

    constructor(data?: IDocumentInforDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_in_id = _data["do_in_id"];
            this.do_id = _data["do_id"];
            this.do_in_status = _data["do_in_status"];
            this.do_in_note = _data["do_in_note"];
            this.do_in_isbn = _data["do_in_isbn"];
            this.dkcb_code = _data["dkcb_code"];
            this.do_is_delete = _data["do_is_delete"];
            this.do_in_is_check = _data["do_in_is_check"];
            this.us_id_delete = _data["us_id_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.do_delete_at = _data["do_delete_at"] ? new Date(_data["do_delete_at"].toString()) : <any>undefined;
            this.do_updated_at = _data["do_updated_at"] ? new Date(_data["do_updated_at"].toString()) : <any>undefined;
            this.do_created_at = _data["do_created_at"] ? new Date(_data["do_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentInforDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentInforDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_in_id"] = this.do_in_id;
        data["do_id"] = this.do_id;
        data["do_in_status"] = this.do_in_status;
        data["do_in_note"] = this.do_in_note;
        data["do_in_isbn"] = this.do_in_isbn;
        data["dkcb_code"] = this.dkcb_code;
        data["do_is_delete"] = this.do_is_delete;
        data["do_in_is_check"] = this.do_in_is_check;
        data["us_id_delete"] = this.us_id_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["do_delete_at"] = this.do_delete_at ? this.do_delete_at.toISOString() : <any>undefined;
        data["do_updated_at"] = this.do_updated_at ? this.do_updated_at.toISOString() : <any>undefined;
        data["do_created_at"] = this.do_created_at ? this.do_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): DocumentInforDto {
        const json = this.toJSON();
        let result = new DocumentInforDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentInforDto {
    do_in_id: number;
    do_id: number;
    do_in_status: DocumentItemStatus;
    do_in_note: string | undefined;
    do_in_isbn: string | undefined;
    dkcb_code: string | undefined;
    do_is_delete: boolean;
    do_in_is_check: boolean;
    us_id_delete: number;
    us_id_created: number;
    us_id_updated: number;
    do_delete_at: Date | undefined;
    do_updated_at: Date;
    do_created_at: Date;
}

export class DocumentInforDtoPagedResultDto implements IDocumentInforDtoPagedResultDto {
    items!: DocumentInforDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDocumentInforDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocumentInforDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DocumentInforDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentInforDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DocumentInforDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DocumentInforDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentInforDtoPagedResultDto {
    items: DocumentInforDto[] | undefined;
    totalCount: number;
}

export enum DocumentItemStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum DocumentLogAction {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class DocumentLogDto implements IDocumentLogDto {
    do_lo_id!: number;
    do_id!: number;
    us_id!: number;
    do_lo_action!: DocumentLogAction;
    do_lo_data!: string | undefined;
    do_lo_created_at!: Date;

    constructor(data?: IDocumentLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_lo_id = _data["do_lo_id"];
            this.do_id = _data["do_id"];
            this.us_id = _data["us_id"];
            this.do_lo_action = _data["do_lo_action"];
            this.do_lo_data = _data["do_lo_data"];
            this.do_lo_created_at = _data["do_lo_created_at"] ? new Date(_data["do_lo_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DocumentLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_lo_id"] = this.do_lo_id;
        data["do_id"] = this.do_id;
        data["us_id"] = this.us_id;
        data["do_lo_action"] = this.do_lo_action;
        data["do_lo_data"] = this.do_lo_data;
        data["do_lo_created_at"] = this.do_lo_created_at ? this.do_lo_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): DocumentLogDto {
        const json = this.toJSON();
        let result = new DocumentLogDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentLogDto {
    do_lo_id: number;
    do_id: number;
    us_id: number;
    do_lo_action: DocumentLogAction;
    do_lo_data: string | undefined;
    do_lo_created_at: Date;
}

export class DocumentLogDtoPagedResultDto implements IDocumentLogDtoPagedResultDto {
    items!: DocumentLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IDocumentLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DocumentLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): DocumentLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): DocumentLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new DocumentLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IDocumentLogDtoPagedResultDto {
    items: DocumentLogDto[] | undefined;
    totalCount: number;
}

export enum DocumentStatus {
    _0 = 0,
    _1 = 1,
}

export enum DocumentType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }

    clone(): EmailSettingsEditDto {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class ExtendTimeMemberCardInput implements IExtendTimeMemberCardInput {
    me_ca_id!: number;
    me_ca_use_to!: Date;

    constructor(data?: IExtendTimeMemberCardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_ca_id = _data["me_ca_id"];
            this.me_ca_use_to = _data["me_ca_use_to"] ? new Date(_data["me_ca_use_to"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ExtendTimeMemberCardInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendTimeMemberCardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_ca_id"] = this.me_ca_id;
        data["me_ca_use_to"] = this.me_ca_use_to ? this.me_ca_use_to.toISOString() : <any>undefined;
        return data;
    }

    clone(): ExtendTimeMemberCardInput {
        const json = this.toJSON();
        let result = new ExtendTimeMemberCardInput();
        result.init(json);
        return result;
    }
}

export interface IExtendTimeMemberCardInput {
    me_ca_id: number;
    me_ca_use_to: Date;
}

export class ExtendtBorrowReturningInput implements IExtendtBorrowReturningInput {
    br_re_id!: number;
    br_re_extend_note!: string | undefined;
    list!: ExtendtBorrowReturningItemInput[] | undefined;

    constructor(data?: IExtendtBorrowReturningInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_id = _data["br_re_id"];
            this.br_re_extend_note = _data["br_re_extend_note"];
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(ExtendtBorrowReturningItemInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExtendtBorrowReturningInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendtBorrowReturningInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_id"] = this.br_re_id;
        data["br_re_extend_note"] = this.br_re_extend_note;
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data;
    }

    clone(): ExtendtBorrowReturningInput {
        const json = this.toJSON();
        let result = new ExtendtBorrowReturningInput();
        result.init(json);
        return result;
    }
}

export interface IExtendtBorrowReturningInput {
    br_re_id: number;
    br_re_extend_note: string | undefined;
    list: ExtendtBorrowReturningItemInput[] | undefined;
}

export class ExtendtBorrowReturningItemInput implements IExtendtBorrowReturningItemInput {
    br_re_de_id!: number;
    br_re_de_due_date!: Date;
    isExtend!: boolean;

    constructor(data?: IExtendtBorrowReturningItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_de_id = _data["br_re_de_id"];
            this.br_re_de_due_date = _data["br_re_de_due_date"] ? new Date(_data["br_re_de_due_date"].toString()) : <any>undefined;
            this.isExtend = _data["isExtend"];
        }
    }

    static fromJS(data: any): ExtendtBorrowReturningItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new ExtendtBorrowReturningItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_de_id"] = this.br_re_de_id;
        data["br_re_de_due_date"] = this.br_re_de_due_date ? this.br_re_de_due_date.toISOString() : <any>undefined;
        data["isExtend"] = this.isExtend;
        return data;
    }

    clone(): ExtendtBorrowReturningItemInput {
        const json = this.toJSON();
        let result = new ExtendtBorrowReturningItemInput();
        result.init(json);
        return result;
    }
}

export interface IExtendtBorrowReturningItemInput {
    br_re_de_id: number;
    br_re_de_due_date: Date;
    isExtend: boolean;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data;
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data;
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data;
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
    enabledSocialLoginSettings!: string[] | undefined;

    constructor(data?: IExternalLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledSocialLoginSettings"])) {
                this.enabledSocialLoginSettings = [] as any;
                for (let item of _data["enabledSocialLoginSettings"])
                    this.enabledSocialLoginSettings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledSocialLoginSettings)) {
            data["enabledSocialLoginSettings"] = [];
            for (let item of this.enabledSocialLoginSettings)
                data["enabledSocialLoginSettings"].push(item);
        }
        return data;
    }

    clone(): ExternalLoginSettingsDto {
        const json = this.toJSON();
        let result = new ExternalLoginSettingsDto();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginSettingsDto {
    enabledSocialLoginSettings: string[] | undefined;
}

export class FieldsAbtractDto implements IFieldsAbtractDto {
    fie_id!: number;
    fie_name!: string | undefined;
    fie_code!: string | undefined;
    fie_is_delete!: boolean;

    constructor(data?: IFieldsAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fie_id = _data["fie_id"];
            this.fie_name = _data["fie_name"];
            this.fie_code = _data["fie_code"];
            this.fie_is_delete = _data["fie_is_delete"];
        }
    }

    static fromJS(data: any): FieldsAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldsAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fie_id"] = this.fie_id;
        data["fie_name"] = this.fie_name;
        data["fie_code"] = this.fie_code;
        data["fie_is_delete"] = this.fie_is_delete;
        return data;
    }

    clone(): FieldsAbtractDto {
        const json = this.toJSON();
        let result = new FieldsAbtractDto();
        result.init(json);
        return result;
    }
}

export interface IFieldsAbtractDto {
    fie_id: number;
    fie_name: string | undefined;
    fie_code: string | undefined;
    fie_is_delete: boolean;
}

export class FieldsDto implements IFieldsDto {
    fie_id!: number;
    fie_name!: string | undefined;
    fie_code!: string | undefined;
    fie_sort!: number;
    fie_desc!: string | undefined;
    fie_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    fie_delete_at!: Date | undefined;
    fie_updated_at!: Date;
    fie_created_at!: Date;

    constructor(data?: IFieldsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fie_id = _data["fie_id"];
            this.fie_name = _data["fie_name"];
            this.fie_code = _data["fie_code"];
            this.fie_sort = _data["fie_sort"];
            this.fie_desc = _data["fie_desc"];
            this.fie_is_delete = _data["fie_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            this.fie_delete_at = _data["fie_delete_at"] ? new Date(_data["fie_delete_at"].toString()) : <any>undefined;
            this.fie_updated_at = _data["fie_updated_at"] ? new Date(_data["fie_updated_at"].toString()) : <any>undefined;
            this.fie_created_at = _data["fie_created_at"] ? new Date(_data["fie_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FieldsDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fie_id"] = this.fie_id;
        data["fie_name"] = this.fie_name;
        data["fie_code"] = this.fie_code;
        data["fie_sort"] = this.fie_sort;
        data["fie_desc"] = this.fie_desc;
        data["fie_is_delete"] = this.fie_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        data["fie_delete_at"] = this.fie_delete_at ? this.fie_delete_at.toISOString() : <any>undefined;
        data["fie_updated_at"] = this.fie_updated_at ? this.fie_updated_at.toISOString() : <any>undefined;
        data["fie_created_at"] = this.fie_created_at ? this.fie_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FieldsDto {
        const json = this.toJSON();
        let result = new FieldsDto();
        result.init(json);
        return result;
    }
}

export interface IFieldsDto {
    fie_id: number;
    fie_name: string | undefined;
    fie_code: string | undefined;
    fie_sort: number;
    fie_desc: string | undefined;
    fie_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    fie_delete_at: Date | undefined;
    fie_updated_at: Date;
    fie_created_at: Date;
}

export class FieldsDtoPagedResultDto implements IFieldsDtoPagedResultDto {
    items!: FieldsDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFieldsDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FieldsDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FieldsDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FieldsDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FieldsDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FieldsDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFieldsDtoPagedResultDto {
    items: FieldsDto[] | undefined;
    totalCount: number;
}

export class FileDocument implements IFileDocument {
    id!: number;
    readonly fi_do_id!: number;
    us_id!: number;
    fi_do_name!: string;
    do_id!: number;
    isDownload!: boolean;
    fi_do_desc!: string | undefined;
    fi_do_md5!: string | undefined;
    fi_do_state!: FileState;
    fi_do_path!: string | undefined;
    fi_do_extension!: string | undefined;
    fi_do_upload_from!: string | undefined;
    fi_do_size!: number;
    fi_do_created_at!: Date;
    fi_do_updated_at!: Date;

    constructor(data?: IFileDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).fi_do_id = _data["fi_do_id"];
            this.us_id = _data["us_id"];
            this.fi_do_name = _data["fi_do_name"];
            this.do_id = _data["do_id"];
            this.isDownload = _data["isDownload"];
            this.fi_do_desc = _data["fi_do_desc"];
            this.fi_do_md5 = _data["fi_do_md5"];
            this.fi_do_state = _data["fi_do_state"];
            this.fi_do_path = _data["fi_do_path"];
            this.fi_do_extension = _data["fi_do_extension"];
            this.fi_do_upload_from = _data["fi_do_upload_from"];
            this.fi_do_size = _data["fi_do_size"];
            this.fi_do_created_at = _data["fi_do_created_at"] ? new Date(_data["fi_do_created_at"].toString()) : <any>undefined;
            this.fi_do_updated_at = _data["fi_do_updated_at"] ? new Date(_data["fi_do_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FileDocument {
        data = typeof data === 'object' ? data : {};
        let result = new FileDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fi_do_id"] = this.fi_do_id;
        data["us_id"] = this.us_id;
        data["fi_do_name"] = this.fi_do_name;
        data["do_id"] = this.do_id;
        data["isDownload"] = this.isDownload;
        data["fi_do_desc"] = this.fi_do_desc;
        data["fi_do_md5"] = this.fi_do_md5;
        data["fi_do_state"] = this.fi_do_state;
        data["fi_do_path"] = this.fi_do_path;
        data["fi_do_extension"] = this.fi_do_extension;
        data["fi_do_upload_from"] = this.fi_do_upload_from;
        data["fi_do_size"] = this.fi_do_size;
        data["fi_do_created_at"] = this.fi_do_created_at ? this.fi_do_created_at.toISOString() : <any>undefined;
        data["fi_do_updated_at"] = this.fi_do_updated_at ? this.fi_do_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FileDocument {
        const json = this.toJSON();
        let result = new FileDocument();
        result.init(json);
        return result;
    }
}

export interface IFileDocument {
    id: number;
    fi_do_id: number;
    us_id: number;
    fi_do_name: string;
    do_id: number;
    isDownload: boolean;
    fi_do_desc: string | undefined;
    fi_do_md5: string | undefined;
    fi_do_state: FileState;
    fi_do_path: string | undefined;
    fi_do_extension: string | undefined;
    fi_do_upload_from: string | undefined;
    fi_do_size: number;
    fi_do_created_at: Date;
    fi_do_updated_at: Date;
}

export class FileDocumentDto implements IFileDocumentDto {
    fi_do_id!: number;
    us_id!: number;
    fi_do_name!: string | undefined;
    do_id!: number;
    document!: ItemDocument;
    fi_do_desc!: string | undefined;
    isDownload!: boolean;
    fi_do_md5!: string | undefined;
    fi_do_state!: FileState;
    fi_do_path!: string | undefined;
    fi_do_extension!: string | undefined;
    fi_do_upload_from!: string | undefined;
    fi_do_size!: number;
    fi_do_created_at!: Date;
    fi_do_updated_at!: Date;

    constructor(data?: IFileDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_do_id = _data["fi_do_id"];
            this.us_id = _data["us_id"];
            this.fi_do_name = _data["fi_do_name"];
            this.do_id = _data["do_id"];
            this.document = _data["document"] ? ItemDocument.fromJS(_data["document"]) : <any>undefined;
            this.fi_do_desc = _data["fi_do_desc"];
            this.isDownload = _data["isDownload"];
            this.fi_do_md5 = _data["fi_do_md5"];
            this.fi_do_state = _data["fi_do_state"];
            this.fi_do_path = _data["fi_do_path"];
            this.fi_do_extension = _data["fi_do_extension"];
            this.fi_do_upload_from = _data["fi_do_upload_from"];
            this.fi_do_size = _data["fi_do_size"];
            this.fi_do_created_at = _data["fi_do_created_at"] ? new Date(_data["fi_do_created_at"].toString()) : <any>undefined;
            this.fi_do_updated_at = _data["fi_do_updated_at"] ? new Date(_data["fi_do_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FileDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_do_id"] = this.fi_do_id;
        data["us_id"] = this.us_id;
        data["fi_do_name"] = this.fi_do_name;
        data["do_id"] = this.do_id;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        data["fi_do_desc"] = this.fi_do_desc;
        data["isDownload"] = this.isDownload;
        data["fi_do_md5"] = this.fi_do_md5;
        data["fi_do_state"] = this.fi_do_state;
        data["fi_do_path"] = this.fi_do_path;
        data["fi_do_extension"] = this.fi_do_extension;
        data["fi_do_upload_from"] = this.fi_do_upload_from;
        data["fi_do_size"] = this.fi_do_size;
        data["fi_do_created_at"] = this.fi_do_created_at ? this.fi_do_created_at.toISOString() : <any>undefined;
        data["fi_do_updated_at"] = this.fi_do_updated_at ? this.fi_do_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FileDocumentDto {
        const json = this.toJSON();
        let result = new FileDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IFileDocumentDto {
    fi_do_id: number;
    us_id: number;
    fi_do_name: string | undefined;
    do_id: number;
    document: ItemDocument;
    fi_do_desc: string | undefined;
    isDownload: boolean;
    fi_do_md5: string | undefined;
    fi_do_state: FileState;
    fi_do_path: string | undefined;
    fi_do_extension: string | undefined;
    fi_do_upload_from: string | undefined;
    fi_do_size: number;
    fi_do_created_at: Date;
    fi_do_updated_at: Date;
}

export class FileDocumentDtoPagedResultDto implements IFileDocumentDtoPagedResultDto {
    items!: FileDocumentDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFileDocumentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FileDocumentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FileDocumentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDocumentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FileDocumentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FileDocumentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFileDocumentDtoPagedResultDto {
    items: FileDocumentDto[] | undefined;
    totalCount: number;
}

export enum FileOrFolderAction {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class FileOrFolderLogDto implements IFileOrFolderLogDto {
    fi_fo_lo_id!: number;
    fi_fo_id!: number;
    fi_fo_is_file!: boolean;
    fi_fo_lo_action!: FileOrFolderAction;
    fi_fo_lo_data!: string | undefined;
    us_id!: number;
    fi_fo_lo_created_at!: Date;

    constructor(data?: IFileOrFolderLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_fo_lo_id = _data["fi_fo_lo_id"];
            this.fi_fo_id = _data["fi_fo_id"];
            this.fi_fo_is_file = _data["fi_fo_is_file"];
            this.fi_fo_lo_action = _data["fi_fo_lo_action"];
            this.fi_fo_lo_data = _data["fi_fo_lo_data"];
            this.us_id = _data["us_id"];
            this.fi_fo_lo_created_at = _data["fi_fo_lo_created_at"] ? new Date(_data["fi_fo_lo_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FileOrFolderLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileOrFolderLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_fo_lo_id"] = this.fi_fo_lo_id;
        data["fi_fo_id"] = this.fi_fo_id;
        data["fi_fo_is_file"] = this.fi_fo_is_file;
        data["fi_fo_lo_action"] = this.fi_fo_lo_action;
        data["fi_fo_lo_data"] = this.fi_fo_lo_data;
        data["us_id"] = this.us_id;
        data["fi_fo_lo_created_at"] = this.fi_fo_lo_created_at ? this.fi_fo_lo_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FileOrFolderLogDto {
        const json = this.toJSON();
        let result = new FileOrFolderLogDto();
        result.init(json);
        return result;
    }
}

export interface IFileOrFolderLogDto {
    fi_fo_lo_id: number;
    fi_fo_id: number;
    fi_fo_is_file: boolean;
    fi_fo_lo_action: FileOrFolderAction;
    fi_fo_lo_data: string | undefined;
    us_id: number;
    fi_fo_lo_created_at: Date;
}

export class FileOrFolderLogDtoPagedResultDto implements IFileOrFolderLogDtoPagedResultDto {
    items!: FileOrFolderLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFileOrFolderLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FileOrFolderLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FileOrFolderLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileOrFolderLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FileOrFolderLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FileOrFolderLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFileOrFolderLogDtoPagedResultDto {
    items: FileOrFolderLogDto[] | undefined;
    totalCount: number;
}

export enum FileState {
    _0 = 0,
    _1 = 1,
}

export enum FileType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
}

export class FilesDto implements IFilesDto {
    fi_id!: number;
    us_id!: number;
    fi_name!: string | undefined;
    fi_decs!: string | undefined;
    fi_md5!: string | undefined;
    fi_state!: FileState;
    fi_path!: string | undefined;
    fi_extension!: string | undefined;
    fi_upload_from!: string | undefined;
    fi_size!: number;
    fi_type!: FileType;
    fi_created_at!: Date;
    fi_updated_at!: Date;

    constructor(data?: IFilesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_id = _data["fi_id"];
            this.us_id = _data["us_id"];
            this.fi_name = _data["fi_name"];
            this.fi_decs = _data["fi_decs"];
            this.fi_md5 = _data["fi_md5"];
            this.fi_state = _data["fi_state"];
            this.fi_path = _data["fi_path"];
            this.fi_extension = _data["fi_extension"];
            this.fi_upload_from = _data["fi_upload_from"];
            this.fi_size = _data["fi_size"];
            this.fi_type = _data["fi_type"];
            this.fi_created_at = _data["fi_created_at"] ? new Date(_data["fi_created_at"].toString()) : <any>undefined;
            this.fi_updated_at = _data["fi_updated_at"] ? new Date(_data["fi_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FilesDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_id"] = this.fi_id;
        data["us_id"] = this.us_id;
        data["fi_name"] = this.fi_name;
        data["fi_decs"] = this.fi_decs;
        data["fi_md5"] = this.fi_md5;
        data["fi_state"] = this.fi_state;
        data["fi_path"] = this.fi_path;
        data["fi_extension"] = this.fi_extension;
        data["fi_upload_from"] = this.fi_upload_from;
        data["fi_size"] = this.fi_size;
        data["fi_type"] = this.fi_type;
        data["fi_created_at"] = this.fi_created_at ? this.fi_created_at.toISOString() : <any>undefined;
        data["fi_updated_at"] = this.fi_updated_at ? this.fi_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FilesDto {
        const json = this.toJSON();
        let result = new FilesDto();
        result.init(json);
        return result;
    }
}

export interface IFilesDto {
    fi_id: number;
    us_id: number;
    fi_name: string | undefined;
    fi_decs: string | undefined;
    fi_md5: string | undefined;
    fi_state: FileState;
    fi_path: string | undefined;
    fi_extension: string | undefined;
    fi_upload_from: string | undefined;
    fi_size: number;
    fi_type: FileType;
    fi_created_at: Date;
    fi_updated_at: Date;
}

export class FilesDtoPagedResultDto implements IFilesDtoPagedResultDto {
    items!: FilesDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFilesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FilesDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FilesDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FilesDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFilesDtoPagedResultDto {
    items: FilesDto[] | undefined;
    totalCount: number;
}

export class FilesOfUser implements IFilesOfUser {
    id!: number;
    readonly fi_us_id!: number;
    us_id!: number;
    fi_us_marker!: boolean;
    fi_us_name!: string;
    fi_us_decs!: string | undefined;
    fi_us_md5!: string | undefined;
    fi_us_path!: string | undefined;
    fi_us_extension!: string | undefined;
    fi_us_type!: TypeFileFolder;
    fi_us_size!: number;
    fi_ro_type!: ResourceRoleType;
    fo_id!: number;
    fi_us_created_at!: Date;
    fi_us_updated_at!: Date;

    constructor(data?: IFilesOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).fi_us_id = _data["fi_us_id"];
            this.us_id = _data["us_id"];
            this.fi_us_marker = _data["fi_us_marker"];
            this.fi_us_name = _data["fi_us_name"];
            this.fi_us_decs = _data["fi_us_decs"];
            this.fi_us_md5 = _data["fi_us_md5"];
            this.fi_us_path = _data["fi_us_path"];
            this.fi_us_extension = _data["fi_us_extension"];
            this.fi_us_type = _data["fi_us_type"];
            this.fi_us_size = _data["fi_us_size"];
            this.fi_ro_type = _data["fi_ro_type"];
            this.fo_id = _data["fo_id"];
            this.fi_us_created_at = _data["fi_us_created_at"] ? new Date(_data["fi_us_created_at"].toString()) : <any>undefined;
            this.fi_us_updated_at = _data["fi_us_updated_at"] ? new Date(_data["fi_us_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FilesOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new FilesOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fi_us_id"] = this.fi_us_id;
        data["us_id"] = this.us_id;
        data["fi_us_marker"] = this.fi_us_marker;
        data["fi_us_name"] = this.fi_us_name;
        data["fi_us_decs"] = this.fi_us_decs;
        data["fi_us_md5"] = this.fi_us_md5;
        data["fi_us_path"] = this.fi_us_path;
        data["fi_us_extension"] = this.fi_us_extension;
        data["fi_us_type"] = this.fi_us_type;
        data["fi_us_size"] = this.fi_us_size;
        data["fi_ro_type"] = this.fi_ro_type;
        data["fo_id"] = this.fo_id;
        data["fi_us_created_at"] = this.fi_us_created_at ? this.fi_us_created_at.toISOString() : <any>undefined;
        data["fi_us_updated_at"] = this.fi_us_updated_at ? this.fi_us_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FilesOfUser {
        const json = this.toJSON();
        let result = new FilesOfUser();
        result.init(json);
        return result;
    }
}

export interface IFilesOfUser {
    id: number;
    fi_us_id: number;
    us_id: number;
    fi_us_marker: boolean;
    fi_us_name: string;
    fi_us_decs: string | undefined;
    fi_us_md5: string | undefined;
    fi_us_path: string | undefined;
    fi_us_extension: string | undefined;
    fi_us_type: TypeFileFolder;
    fi_us_size: number;
    fi_ro_type: ResourceRoleType;
    fo_id: number;
    fi_us_created_at: Date;
    fi_us_updated_at: Date;
}

export class FilesOfUserDto implements IFilesOfUserDto {
    fi_us_id!: number;
    us_id!: number;
    fi_us_marker!: boolean;
    fi_us_name!: string | undefined;
    fi_us_decs!: string | undefined;
    fi_us_md5!: string | undefined;
    fi_us_path!: string | undefined;
    fi_us_extension!: string | undefined;
    fi_us_type!: TypeFileFolder;
    fi_us_size!: number;
    fo_id!: number;
    fi_ro_type!: ResourceRoleType;
    fi_us_created_at!: Date;
    fi_us_updated_at!: Date;

    constructor(data?: IFilesOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_us_id = _data["fi_us_id"];
            this.us_id = _data["us_id"];
            this.fi_us_marker = _data["fi_us_marker"];
            this.fi_us_name = _data["fi_us_name"];
            this.fi_us_decs = _data["fi_us_decs"];
            this.fi_us_md5 = _data["fi_us_md5"];
            this.fi_us_path = _data["fi_us_path"];
            this.fi_us_extension = _data["fi_us_extension"];
            this.fi_us_type = _data["fi_us_type"];
            this.fi_us_size = _data["fi_us_size"];
            this.fo_id = _data["fo_id"];
            this.fi_ro_type = _data["fi_ro_type"];
            this.fi_us_created_at = _data["fi_us_created_at"] ? new Date(_data["fi_us_created_at"].toString()) : <any>undefined;
            this.fi_us_updated_at = _data["fi_us_updated_at"] ? new Date(_data["fi_us_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FilesOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilesOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_us_id"] = this.fi_us_id;
        data["us_id"] = this.us_id;
        data["fi_us_marker"] = this.fi_us_marker;
        data["fi_us_name"] = this.fi_us_name;
        data["fi_us_decs"] = this.fi_us_decs;
        data["fi_us_md5"] = this.fi_us_md5;
        data["fi_us_path"] = this.fi_us_path;
        data["fi_us_extension"] = this.fi_us_extension;
        data["fi_us_type"] = this.fi_us_type;
        data["fi_us_size"] = this.fi_us_size;
        data["fo_id"] = this.fo_id;
        data["fi_ro_type"] = this.fi_ro_type;
        data["fi_us_created_at"] = this.fi_us_created_at ? this.fi_us_created_at.toISOString() : <any>undefined;
        data["fi_us_updated_at"] = this.fi_us_updated_at ? this.fi_us_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FilesOfUserDto {
        const json = this.toJSON();
        let result = new FilesOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IFilesOfUserDto {
    fi_us_id: number;
    us_id: number;
    fi_us_marker: boolean;
    fi_us_name: string | undefined;
    fi_us_decs: string | undefined;
    fi_us_md5: string | undefined;
    fi_us_path: string | undefined;
    fi_us_extension: string | undefined;
    fi_us_type: TypeFileFolder;
    fi_us_size: number;
    fo_id: number;
    fi_ro_type: ResourceRoleType;
    fi_us_created_at: Date;
    fi_us_updated_at: Date;
}

export class FilesOfUserDtoPagedResultDto implements IFilesOfUserDtoPagedResultDto {
    items!: FilesOfUserDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFilesOfUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FilesOfUserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilesOfUserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilesOfUserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FilesOfUserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FilesOfUserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFilesOfUserDtoPagedResultDto {
    items: FilesOfUserDto[] | undefined;
    totalCount: number;
}

export class FilesOfUserRolesDto implements IFilesOfUserRolesDto {
    fi_ro_id!: number;
    us_id!: number;
    fi_us_id!: number;
    fo_id!: number;
    fi_ro_role!: ResourceRoleStatus;
    itemFileOfUser!: FilesOfUserDto;
    fi_ro_marker!: boolean;
    fi_ro_created_at!: Date;
    fi_ro_updated_at!: Date;

    constructor(data?: IFilesOfUserRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_ro_id = _data["fi_ro_id"];
            this.us_id = _data["us_id"];
            this.fi_us_id = _data["fi_us_id"];
            this.fo_id = _data["fo_id"];
            this.fi_ro_role = _data["fi_ro_role"];
            this.itemFileOfUser = _data["itemFileOfUser"] ? FilesOfUserDto.fromJS(_data["itemFileOfUser"]) : <any>undefined;
            this.fi_ro_marker = _data["fi_ro_marker"];
            this.fi_ro_created_at = _data["fi_ro_created_at"] ? new Date(_data["fi_ro_created_at"].toString()) : <any>undefined;
            this.fi_ro_updated_at = _data["fi_ro_updated_at"] ? new Date(_data["fi_ro_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FilesOfUserRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilesOfUserRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_ro_id"] = this.fi_ro_id;
        data["us_id"] = this.us_id;
        data["fi_us_id"] = this.fi_us_id;
        data["fo_id"] = this.fo_id;
        data["fi_ro_role"] = this.fi_ro_role;
        data["itemFileOfUser"] = this.itemFileOfUser ? this.itemFileOfUser.toJSON() : <any>undefined;
        data["fi_ro_marker"] = this.fi_ro_marker;
        data["fi_ro_created_at"] = this.fi_ro_created_at ? this.fi_ro_created_at.toISOString() : <any>undefined;
        data["fi_ro_updated_at"] = this.fi_ro_updated_at ? this.fi_ro_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FilesOfUserRolesDto {
        const json = this.toJSON();
        let result = new FilesOfUserRolesDto();
        result.init(json);
        return result;
    }
}

export interface IFilesOfUserRolesDto {
    fi_ro_id: number;
    us_id: number;
    fi_us_id: number;
    fo_id: number;
    fi_ro_role: ResourceRoleStatus;
    itemFileOfUser: FilesOfUserDto;
    fi_ro_marker: boolean;
    fi_ro_created_at: Date;
    fi_ro_updated_at: Date;
}

export class FilesOfUserRolesDtoPagedResultDto implements IFilesOfUserRolesDtoPagedResultDto {
    items!: FilesOfUserRolesDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFilesOfUserRolesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FilesOfUserRolesDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FilesOfUserRolesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FilesOfUserRolesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FilesOfUserRolesDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FilesOfUserRolesDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFilesOfUserRolesDtoPagedResultDto {
    items: FilesOfUserRolesDto[] | undefined;
    totalCount: number;
}

export class FindMemberBorrowDto implements IFindMemberBorrowDto {
    me_id!: number;
    me_code!: string | undefined;
    me_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    me_pass!: string | undefined;
    me_status!: MemberRegisterStatus;
    me_is_active!: boolean;
    me_is_locked!: boolean;
    me_has_card!: boolean;
    memberCard!: MemberCardDto;
    me_is_delete!: boolean;
    fi_id!: AttachmentItem;
    me_created_at!: Date;
    me_updated_at!: Date;

    constructor(data?: IFindMemberBorrowDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_code = _data["me_code"];
            this.me_name = _data["me_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.me_pass = _data["me_pass"];
            this.me_status = _data["me_status"];
            this.me_is_active = _data["me_is_active"];
            this.me_is_locked = _data["me_is_locked"];
            this.me_has_card = _data["me_has_card"];
            this.memberCard = _data["memberCard"] ? MemberCardDto.fromJS(_data["memberCard"]) : <any>undefined;
            this.me_is_delete = _data["me_is_delete"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.me_created_at = _data["me_created_at"] ? new Date(_data["me_created_at"].toString()) : <any>undefined;
            this.me_updated_at = _data["me_updated_at"] ? new Date(_data["me_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FindMemberBorrowDto {
        data = typeof data === 'object' ? data : {};
        let result = new FindMemberBorrowDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_code"] = this.me_code;
        data["me_name"] = this.me_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["me_pass"] = this.me_pass;
        data["me_status"] = this.me_status;
        data["me_is_active"] = this.me_is_active;
        data["me_is_locked"] = this.me_is_locked;
        data["me_has_card"] = this.me_has_card;
        data["memberCard"] = this.memberCard ? this.memberCard.toJSON() : <any>undefined;
        data["me_is_delete"] = this.me_is_delete;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["me_created_at"] = this.me_created_at ? this.me_created_at.toISOString() : <any>undefined;
        data["me_updated_at"] = this.me_updated_at ? this.me_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FindMemberBorrowDto {
        const json = this.toJSON();
        let result = new FindMemberBorrowDto();
        result.init(json);
        return result;
    }
}

export interface IFindMemberBorrowDto {
    me_id: number;
    me_code: string | undefined;
    me_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    me_pass: string | undefined;
    me_status: MemberRegisterStatus;
    me_is_active: boolean;
    me_is_locked: boolean;
    me_has_card: boolean;
    memberCard: MemberCardDto;
    me_is_delete: boolean;
    fi_id: AttachmentItem;
    me_created_at: Date;
    me_updated_at: Date;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;
    organizationUnitId!: number;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): FindOrganizationUnitRolesInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitRolesInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitRolesInput {
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
    organizationUnitId: number;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;
    organizationUnitId!: number;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): FindOrganizationUnitUsersInput {
        const json = this.toJSON();
        let result = new FindOrganizationUnitUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindOrganizationUnitUsersInput {
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
    organizationUnitId: number;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class Folder implements IFolder {
    id!: number;
    readonly fo_id!: number;
    fo_name!: string | undefined;
    us_id_owner!: number;
    us_id_last_update!: number;
    fo_decs!: string | undefined;
    fo_id_parent!: number;
    fo_link!: string | undefined;
    fo_ParentIdArr!: string | undefined;
    fo_ChildIdArr!: string | undefined;
    fo_is_deleted!: boolean;
    fo_is_marker!: boolean;
    fo_ro_type!: ResourceRoleType;
    fo_created_at!: Date;
    fo_last_updated_at!: Date;
    fo_last_open_at!: Date;

    constructor(data?: IFolder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).fo_id = _data["fo_id"];
            this.fo_name = _data["fo_name"];
            this.us_id_owner = _data["us_id_owner"];
            this.us_id_last_update = _data["us_id_last_update"];
            this.fo_decs = _data["fo_decs"];
            this.fo_id_parent = _data["fo_id_parent"];
            this.fo_link = _data["fo_link"];
            this.fo_ParentIdArr = _data["fo_ParentIdArr"];
            this.fo_ChildIdArr = _data["fo_ChildIdArr"];
            this.fo_is_deleted = _data["fo_is_deleted"];
            this.fo_is_marker = _data["fo_is_marker"];
            this.fo_ro_type = _data["fo_ro_type"];
            this.fo_created_at = _data["fo_created_at"] ? new Date(_data["fo_created_at"].toString()) : <any>undefined;
            this.fo_last_updated_at = _data["fo_last_updated_at"] ? new Date(_data["fo_last_updated_at"].toString()) : <any>undefined;
            this.fo_last_open_at = _data["fo_last_open_at"] ? new Date(_data["fo_last_open_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Folder {
        data = typeof data === 'object' ? data : {};
        let result = new Folder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fo_id"] = this.fo_id;
        data["fo_name"] = this.fo_name;
        data["us_id_owner"] = this.us_id_owner;
        data["us_id_last_update"] = this.us_id_last_update;
        data["fo_decs"] = this.fo_decs;
        data["fo_id_parent"] = this.fo_id_parent;
        data["fo_link"] = this.fo_link;
        data["fo_ParentIdArr"] = this.fo_ParentIdArr;
        data["fo_ChildIdArr"] = this.fo_ChildIdArr;
        data["fo_is_deleted"] = this.fo_is_deleted;
        data["fo_is_marker"] = this.fo_is_marker;
        data["fo_ro_type"] = this.fo_ro_type;
        data["fo_created_at"] = this.fo_created_at ? this.fo_created_at.toISOString() : <any>undefined;
        data["fo_last_updated_at"] = this.fo_last_updated_at ? this.fo_last_updated_at.toISOString() : <any>undefined;
        data["fo_last_open_at"] = this.fo_last_open_at ? this.fo_last_open_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): Folder {
        const json = this.toJSON();
        let result = new Folder();
        result.init(json);
        return result;
    }
}

export interface IFolder {
    id: number;
    fo_id: number;
    fo_name: string | undefined;
    us_id_owner: number;
    us_id_last_update: number;
    fo_decs: string | undefined;
    fo_id_parent: number;
    fo_link: string | undefined;
    fo_ParentIdArr: string | undefined;
    fo_ChildIdArr: string | undefined;
    fo_is_deleted: boolean;
    fo_is_marker: boolean;
    fo_ro_type: ResourceRoleType;
    fo_created_at: Date;
    fo_last_updated_at: Date;
    fo_last_open_at: Date;
}

export class FolderDto implements IFolderDto {
    fo_id!: number;
    fo_name!: string | undefined;
    us_id_owner!: number;
    us_id_last_update!: number;
    fo_is_marker!: boolean;
    fo_decs!: string | undefined;
    fo_id_parent!: number;
    fo_link!: string | undefined;
    fo_is_deleted!: boolean;
    fo_ro_type!: ResourceRoleType;
    fo_ParentIdArr!: number[] | undefined;
    fo_ChildIdArr!: number[] | undefined;
    fo_created_at!: Date;
    fo_last_updated_at!: Date;
    fo_last_open_at!: Date;

    constructor(data?: IFolderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_id = _data["fo_id"];
            this.fo_name = _data["fo_name"];
            this.us_id_owner = _data["us_id_owner"];
            this.us_id_last_update = _data["us_id_last_update"];
            this.fo_is_marker = _data["fo_is_marker"];
            this.fo_decs = _data["fo_decs"];
            this.fo_id_parent = _data["fo_id_parent"];
            this.fo_link = _data["fo_link"];
            this.fo_is_deleted = _data["fo_is_deleted"];
            this.fo_ro_type = _data["fo_ro_type"];
            if (Array.isArray(_data["fo_ParentIdArr"])) {
                this.fo_ParentIdArr = [] as any;
                for (let item of _data["fo_ParentIdArr"])
                    this.fo_ParentIdArr!.push(item);
            }
            if (Array.isArray(_data["fo_ChildIdArr"])) {
                this.fo_ChildIdArr = [] as any;
                for (let item of _data["fo_ChildIdArr"])
                    this.fo_ChildIdArr!.push(item);
            }
            this.fo_created_at = _data["fo_created_at"] ? new Date(_data["fo_created_at"].toString()) : <any>undefined;
            this.fo_last_updated_at = _data["fo_last_updated_at"] ? new Date(_data["fo_last_updated_at"].toString()) : <any>undefined;
            this.fo_last_open_at = _data["fo_last_open_at"] ? new Date(_data["fo_last_open_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FolderDto {
        data = typeof data === 'object' ? data : {};
        let result = new FolderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_id"] = this.fo_id;
        data["fo_name"] = this.fo_name;
        data["us_id_owner"] = this.us_id_owner;
        data["us_id_last_update"] = this.us_id_last_update;
        data["fo_is_marker"] = this.fo_is_marker;
        data["fo_decs"] = this.fo_decs;
        data["fo_id_parent"] = this.fo_id_parent;
        data["fo_link"] = this.fo_link;
        data["fo_is_deleted"] = this.fo_is_deleted;
        data["fo_ro_type"] = this.fo_ro_type;
        if (Array.isArray(this.fo_ParentIdArr)) {
            data["fo_ParentIdArr"] = [];
            for (let item of this.fo_ParentIdArr)
                data["fo_ParentIdArr"].push(item);
        }
        if (Array.isArray(this.fo_ChildIdArr)) {
            data["fo_ChildIdArr"] = [];
            for (let item of this.fo_ChildIdArr)
                data["fo_ChildIdArr"].push(item);
        }
        data["fo_created_at"] = this.fo_created_at ? this.fo_created_at.toISOString() : <any>undefined;
        data["fo_last_updated_at"] = this.fo_last_updated_at ? this.fo_last_updated_at.toISOString() : <any>undefined;
        data["fo_last_open_at"] = this.fo_last_open_at ? this.fo_last_open_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FolderDto {
        const json = this.toJSON();
        let result = new FolderDto();
        result.init(json);
        return result;
    }
}

export interface IFolderDto {
    fo_id: number;
    fo_name: string | undefined;
    us_id_owner: number;
    us_id_last_update: number;
    fo_is_marker: boolean;
    fo_decs: string | undefined;
    fo_id_parent: number;
    fo_link: string | undefined;
    fo_is_deleted: boolean;
    fo_ro_type: ResourceRoleType;
    fo_ParentIdArr: number[] | undefined;
    fo_ChildIdArr: number[] | undefined;
    fo_created_at: Date;
    fo_last_updated_at: Date;
    fo_last_open_at: Date;
}

export class FolderDtoPagedResultDto implements IFolderDtoPagedResultDto {
    items!: FolderDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFolderDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FolderDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FolderDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FolderDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FolderDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FolderDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFolderDtoPagedResultDto {
    items: FolderDto[] | undefined;
    totalCount: number;
}

export class FolderRoles implements IFolderRoles {
    id!: number;
    readonly fo_ro_id!: number;
    us_id!: number;
    fo_id!: number;
    fo_id_parent!: number;
    fo_ro_role!: ResourceRoleStatus;
    fo_ro_marker!: boolean;
    fo_ro_created_at!: Date;
    fo_ro_updated_at!: Date;
    itemFolder!: Folder;

    constructor(data?: IFolderRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).fo_ro_id = _data["fo_ro_id"];
            this.us_id = _data["us_id"];
            this.fo_id = _data["fo_id"];
            this.fo_id_parent = _data["fo_id_parent"];
            this.fo_ro_role = _data["fo_ro_role"];
            this.fo_ro_marker = _data["fo_ro_marker"];
            this.fo_ro_created_at = _data["fo_ro_created_at"] ? new Date(_data["fo_ro_created_at"].toString()) : <any>undefined;
            this.fo_ro_updated_at = _data["fo_ro_updated_at"] ? new Date(_data["fo_ro_updated_at"].toString()) : <any>undefined;
            this.itemFolder = _data["itemFolder"] ? Folder.fromJS(_data["itemFolder"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FolderRoles {
        data = typeof data === 'object' ? data : {};
        let result = new FolderRoles();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fo_ro_id"] = this.fo_ro_id;
        data["us_id"] = this.us_id;
        data["fo_id"] = this.fo_id;
        data["fo_id_parent"] = this.fo_id_parent;
        data["fo_ro_role"] = this.fo_ro_role;
        data["fo_ro_marker"] = this.fo_ro_marker;
        data["fo_ro_created_at"] = this.fo_ro_created_at ? this.fo_ro_created_at.toISOString() : <any>undefined;
        data["fo_ro_updated_at"] = this.fo_ro_updated_at ? this.fo_ro_updated_at.toISOString() : <any>undefined;
        data["itemFolder"] = this.itemFolder ? this.itemFolder.toJSON() : <any>undefined;
        return data;
    }

    clone(): FolderRoles {
        const json = this.toJSON();
        let result = new FolderRoles();
        result.init(json);
        return result;
    }
}

export interface IFolderRoles {
    id: number;
    fo_ro_id: number;
    us_id: number;
    fo_id: number;
    fo_id_parent: number;
    fo_ro_role: ResourceRoleStatus;
    fo_ro_marker: boolean;
    fo_ro_created_at: Date;
    fo_ro_updated_at: Date;
    itemFolder: Folder;
}

export class FolderRolesDto implements IFolderRolesDto {
    fo_ro_id!: number;
    us_id!: number;
    fo_id!: number;
    fo_id_parent!: number;
    itemFolder!: FolderDto;
    fo_ro_role!: ResourceRoleStatus;
    fo_ro_marker!: boolean;
    fo_ro_created_at!: Date;
    fo_ro_updated_at!: Date;

    constructor(data?: IFolderRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_ro_id = _data["fo_ro_id"];
            this.us_id = _data["us_id"];
            this.fo_id = _data["fo_id"];
            this.fo_id_parent = _data["fo_id_parent"];
            this.itemFolder = _data["itemFolder"] ? FolderDto.fromJS(_data["itemFolder"]) : <any>undefined;
            this.fo_ro_role = _data["fo_ro_role"];
            this.fo_ro_marker = _data["fo_ro_marker"];
            this.fo_ro_created_at = _data["fo_ro_created_at"] ? new Date(_data["fo_ro_created_at"].toString()) : <any>undefined;
            this.fo_ro_updated_at = _data["fo_ro_updated_at"] ? new Date(_data["fo_ro_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FolderRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new FolderRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_ro_id"] = this.fo_ro_id;
        data["us_id"] = this.us_id;
        data["fo_id"] = this.fo_id;
        data["fo_id_parent"] = this.fo_id_parent;
        data["itemFolder"] = this.itemFolder ? this.itemFolder.toJSON() : <any>undefined;
        data["fo_ro_role"] = this.fo_ro_role;
        data["fo_ro_marker"] = this.fo_ro_marker;
        data["fo_ro_created_at"] = this.fo_ro_created_at ? this.fo_ro_created_at.toISOString() : <any>undefined;
        data["fo_ro_updated_at"] = this.fo_ro_updated_at ? this.fo_ro_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): FolderRolesDto {
        const json = this.toJSON();
        let result = new FolderRolesDto();
        result.init(json);
        return result;
    }
}

export interface IFolderRolesDto {
    fo_ro_id: number;
    us_id: number;
    fo_id: number;
    fo_id_parent: number;
    itemFolder: FolderDto;
    fo_ro_role: ResourceRoleStatus;
    fo_ro_marker: boolean;
    fo_ro_created_at: Date;
    fo_ro_updated_at: Date;
}

export class FolderRolesDtoPagedResultDto implements IFolderRolesDtoPagedResultDto {
    items!: FolderRolesDto[] | undefined;
    totalCount!: number;

    constructor(data?: IFolderRolesDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FolderRolesDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): FolderRolesDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new FolderRolesDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): FolderRolesDtoPagedResultDto {
        const json = this.toJSON();
        let result = new FolderRolesDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IFolderRolesDtoPagedResultDto {
    items: FolderRolesDto[] | undefined;
    totalCount: number;
}

export class GDocumentDto implements IGDocumentDto {
    do_id!: number;
    do_title!: string | undefined;
    do_date_publish!: string | undefined;
    do_republish!: number;
    do_identifier!: string | undefined;
    do_identifier_citation!: string | undefined;
    do_abstract!: string | undefined;
    do_language_iso!: ItemLanguages[] | undefined;
    do_translator!: string | undefined;
    do_period_check!: number;
    do_lastest_check!: Date;
    do_date_available!: Date;
    do_nr_pages!: number;
    do_type!: DocumentType;
    fie_id_arr!: ItemField[] | undefined;
    fi_id_arr_cover!: AttachmentItem[] | undefined;
    au_id_arr!: ItemAuthor[] | undefined;
    pu_id!: ItemPublisher;
    to_id!: number;
    ca_id!: number;
    fileDocuments!: FileDocumentDto[] | undefined;
    do_is_hot!: boolean;
    do_num_view!: number;
    do_num_dowload!: number;
    do_num_borrow!: number;
    do_status!: DocumentStatus;
    do_borrow_status!: DocumentBorrowType;
    do_price!: number;
    re_id!: number;
    do_total_book!: number;
    do_total_book_valid!: number;
    do_total_user_register!: number;
    do_remaining_book!: number;
    do_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    do_created_at!: Date;
    do_updated_at!: Date;
    do_delete_at!: Date | undefined;

    constructor(data?: IGDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_id = _data["do_id"];
            this.do_title = _data["do_title"];
            this.do_date_publish = _data["do_date_publish"];
            this.do_republish = _data["do_republish"];
            this.do_identifier = _data["do_identifier"];
            this.do_identifier_citation = _data["do_identifier_citation"];
            this.do_abstract = _data["do_abstract"];
            if (Array.isArray(_data["do_language_iso"])) {
                this.do_language_iso = [] as any;
                for (let item of _data["do_language_iso"])
                    this.do_language_iso!.push(ItemLanguages.fromJS(item));
            }
            this.do_translator = _data["do_translator"];
            this.do_period_check = _data["do_period_check"];
            this.do_lastest_check = _data["do_lastest_check"] ? new Date(_data["do_lastest_check"].toString()) : <any>undefined;
            this.do_date_available = _data["do_date_available"] ? new Date(_data["do_date_available"].toString()) : <any>undefined;
            this.do_nr_pages = _data["do_nr_pages"];
            this.do_type = _data["do_type"];
            if (Array.isArray(_data["fie_id_arr"])) {
                this.fie_id_arr = [] as any;
                for (let item of _data["fie_id_arr"])
                    this.fie_id_arr!.push(ItemField.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_arr_cover"])) {
                this.fi_id_arr_cover = [] as any;
                for (let item of _data["fi_id_arr_cover"])
                    this.fi_id_arr_cover!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["au_id_arr"])) {
                this.au_id_arr = [] as any;
                for (let item of _data["au_id_arr"])
                    this.au_id_arr!.push(ItemAuthor.fromJS(item));
            }
            this.pu_id = _data["pu_id"] ? ItemPublisher.fromJS(_data["pu_id"]) : <any>undefined;
            this.to_id = _data["to_id"];
            this.ca_id = _data["ca_id"];
            if (Array.isArray(_data["fileDocuments"])) {
                this.fileDocuments = [] as any;
                for (let item of _data["fileDocuments"])
                    this.fileDocuments!.push(FileDocumentDto.fromJS(item));
            }
            this.do_is_hot = _data["do_is_hot"];
            this.do_num_view = _data["do_num_view"];
            this.do_num_dowload = _data["do_num_dowload"];
            this.do_num_borrow = _data["do_num_borrow"];
            this.do_status = _data["do_status"];
            this.do_borrow_status = _data["do_borrow_status"];
            this.do_price = _data["do_price"];
            this.re_id = _data["re_id"];
            this.do_total_book = _data["do_total_book"];
            this.do_total_book_valid = _data["do_total_book_valid"];
            this.do_total_user_register = _data["do_total_user_register"];
            this.do_remaining_book = _data["do_remaining_book"];
            this.do_is_delete = _data["do_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            this.do_created_at = _data["do_created_at"] ? new Date(_data["do_created_at"].toString()) : <any>undefined;
            this.do_updated_at = _data["do_updated_at"] ? new Date(_data["do_updated_at"].toString()) : <any>undefined;
            this.do_delete_at = _data["do_delete_at"] ? new Date(_data["do_delete_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new GDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_id"] = this.do_id;
        data["do_title"] = this.do_title;
        data["do_date_publish"] = this.do_date_publish;
        data["do_republish"] = this.do_republish;
        data["do_identifier"] = this.do_identifier;
        data["do_identifier_citation"] = this.do_identifier_citation;
        data["do_abstract"] = this.do_abstract;
        if (Array.isArray(this.do_language_iso)) {
            data["do_language_iso"] = [];
            for (let item of this.do_language_iso)
                data["do_language_iso"].push(item.toJSON());
        }
        data["do_translator"] = this.do_translator;
        data["do_period_check"] = this.do_period_check;
        data["do_lastest_check"] = this.do_lastest_check ? this.do_lastest_check.toISOString() : <any>undefined;
        data["do_date_available"] = this.do_date_available ? this.do_date_available.toISOString() : <any>undefined;
        data["do_nr_pages"] = this.do_nr_pages;
        data["do_type"] = this.do_type;
        if (Array.isArray(this.fie_id_arr)) {
            data["fie_id_arr"] = [];
            for (let item of this.fie_id_arr)
                data["fie_id_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_arr_cover)) {
            data["fi_id_arr_cover"] = [];
            for (let item of this.fi_id_arr_cover)
                data["fi_id_arr_cover"].push(item.toJSON());
        }
        if (Array.isArray(this.au_id_arr)) {
            data["au_id_arr"] = [];
            for (let item of this.au_id_arr)
                data["au_id_arr"].push(item.toJSON());
        }
        data["pu_id"] = this.pu_id ? this.pu_id.toJSON() : <any>undefined;
        data["to_id"] = this.to_id;
        data["ca_id"] = this.ca_id;
        if (Array.isArray(this.fileDocuments)) {
            data["fileDocuments"] = [];
            for (let item of this.fileDocuments)
                data["fileDocuments"].push(item.toJSON());
        }
        data["do_is_hot"] = this.do_is_hot;
        data["do_num_view"] = this.do_num_view;
        data["do_num_dowload"] = this.do_num_dowload;
        data["do_num_borrow"] = this.do_num_borrow;
        data["do_status"] = this.do_status;
        data["do_borrow_status"] = this.do_borrow_status;
        data["do_price"] = this.do_price;
        data["re_id"] = this.re_id;
        data["do_total_book"] = this.do_total_book;
        data["do_total_book_valid"] = this.do_total_book_valid;
        data["do_total_user_register"] = this.do_total_user_register;
        data["do_remaining_book"] = this.do_remaining_book;
        data["do_is_delete"] = this.do_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        data["do_created_at"] = this.do_created_at ? this.do_created_at.toISOString() : <any>undefined;
        data["do_updated_at"] = this.do_updated_at ? this.do_updated_at.toISOString() : <any>undefined;
        data["do_delete_at"] = this.do_delete_at ? this.do_delete_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): GDocumentDto {
        const json = this.toJSON();
        let result = new GDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IGDocumentDto {
    do_id: number;
    do_title: string | undefined;
    do_date_publish: string | undefined;
    do_republish: number;
    do_identifier: string | undefined;
    do_identifier_citation: string | undefined;
    do_abstract: string | undefined;
    do_language_iso: ItemLanguages[] | undefined;
    do_translator: string | undefined;
    do_period_check: number;
    do_lastest_check: Date;
    do_date_available: Date;
    do_nr_pages: number;
    do_type: DocumentType;
    fie_id_arr: ItemField[] | undefined;
    fi_id_arr_cover: AttachmentItem[] | undefined;
    au_id_arr: ItemAuthor[] | undefined;
    pu_id: ItemPublisher;
    to_id: number;
    ca_id: number;
    fileDocuments: FileDocumentDto[] | undefined;
    do_is_hot: boolean;
    do_num_view: number;
    do_num_dowload: number;
    do_num_borrow: number;
    do_status: DocumentStatus;
    do_borrow_status: DocumentBorrowType;
    do_price: number;
    re_id: number;
    do_total_book: number;
    do_total_book_valid: number;
    do_total_user_register: number;
    do_remaining_book: number;
    do_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    do_created_at: Date;
    do_updated_at: Date;
    do_delete_at: Date | undefined;
}

export class GDocumentDtoPagedResultDto implements IGDocumentDtoPagedResultDto {
    items!: GDocumentDto[] | undefined;
    totalCount!: number;

    constructor(data?: IGDocumentDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GDocumentDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GDocumentDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GDocumentDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GDocumentDtoPagedResultDto {
        const json = this.toJSON();
        let result = new GDocumentDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGDocumentDtoPagedResultDto {
    items: GDocumentDto[] | undefined;
    totalCount: number;
}

export enum GENDER {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;
    defaultCheckTime!: number;
    defaultBorrowMaxTime!: number;
    deleteRegisterBorrowMaxTime!: number;
    defaultMoneyOutOfDate!: number;
    timeChangeStatusRecoveredDocument!: number;
    dueDateMaxTimes!: number;
    maxUploadedData!: number;
    maxResourcesData!: number;
    isAutoBlockCardWithStatusCard!: boolean;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
            this.defaultCheckTime = _data["defaultCheckTime"];
            this.defaultBorrowMaxTime = _data["defaultBorrowMaxTime"];
            this.deleteRegisterBorrowMaxTime = _data["deleteRegisterBorrowMaxTime"];
            this.defaultMoneyOutOfDate = _data["defaultMoneyOutOfDate"];
            this.timeChangeStatusRecoveredDocument = _data["timeChangeStatusRecoveredDocument"];
            this.dueDateMaxTimes = _data["dueDateMaxTimes"];
            this.maxUploadedData = _data["maxUploadedData"];
            this.maxResourcesData = _data["maxResourcesData"];
            this.isAutoBlockCardWithStatusCard = _data["isAutoBlockCardWithStatusCard"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        data["defaultCheckTime"] = this.defaultCheckTime;
        data["defaultBorrowMaxTime"] = this.defaultBorrowMaxTime;
        data["deleteRegisterBorrowMaxTime"] = this.deleteRegisterBorrowMaxTime;
        data["defaultMoneyOutOfDate"] = this.defaultMoneyOutOfDate;
        data["timeChangeStatusRecoveredDocument"] = this.timeChangeStatusRecoveredDocument;
        data["dueDateMaxTimes"] = this.dueDateMaxTimes;
        data["maxUploadedData"] = this.maxUploadedData;
        data["maxResourcesData"] = this.maxResourcesData;
        data["isAutoBlockCardWithStatusCard"] = this.isAutoBlockCardWithStatusCard;
        return data;
    }

    clone(): GeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
    defaultCheckTime: number;
    defaultBorrowMaxTime: number;
    deleteRegisterBorrowMaxTime: number;
    defaultMoneyOutOfDate: number;
    timeChangeStatusRecoveredDocument: number;
    dueDateMaxTimes: number;
    maxUploadedData: number;
    maxResourcesData: number;
    isAutoBlockCardWithStatusCard: boolean;
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): GetAllAvailableWebhooksOutput {
        const json = this.toJSON();
        let result = new GetAllAvailableWebhooksOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllAvailableWebhooksOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetAllAvailableWebhooksOutputListResultDto implements IGetAllAvailableWebhooksOutputListResultDto {
    items!: GetAllAvailableWebhooksOutput[] | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutputListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutputListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutputListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllAvailableWebhooksOutputListResultDto {
        const json = this.toJSON();
        let result = new GetAllAvailableWebhooksOutputListResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllAvailableWebhooksOutputListResultDto {
    items: GetAllAvailableWebhooksOutput[] | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
    id!: string;
    webhookUri!: string | undefined;
    webhookSubscriptionId!: string;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: Date;
    lastModificationTime!: Date | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.webhookSubscriptionId = _data["webhookSubscriptionId"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["webhookSubscriptionId"] = this.webhookSubscriptionId;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): GetAllSendAttemptsOfWebhookEventOutput {
        const json = this.toJSON();
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
    id: string;
    webhookUri: string | undefined;
    webhookSubscriptionId: string;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: Date;
    lastModificationTime: Date | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutputListResultDto implements IGetAllSendAttemptsOfWebhookEventOutputListResultDto {
    items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutputListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutputListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutputListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllSendAttemptsOfWebhookEventOutputListResultDto {
        const json = this.toJSON();
        let result = new GetAllSendAttemptsOfWebhookEventOutputListResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutputListResultDto {
    items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
    id!: string;
    webhookEventId!: string;
    webhookName!: string | undefined;
    data!: string | undefined;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: Date;

    constructor(data?: IGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookEventId = _data["webhookEventId"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookEventId"] = this.webhookEventId;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): GetAllSendAttemptsOutput {
        const json = this.toJSON();
        let result = new GetAllSendAttemptsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSendAttemptsOutput {
    id: string;
    webhookEventId: string;
    webhookName: string | undefined;
    data: string | undefined;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: Date;
}

export class GetAllSendAttemptsOutputPagedResultDto implements IGetAllSendAttemptsOutputPagedResultDto {
    items!: GetAllSendAttemptsOutput[] | undefined;
    totalCount!: number;

    constructor(data?: IGetAllSendAttemptsOutputPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutputPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutputPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): GetAllSendAttemptsOutputPagedResultDto {
        const json = this.toJSON();
        let result = new GetAllSendAttemptsOutputPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllSendAttemptsOutputPagedResultDto {
    items: GetAllSendAttemptsOutput[] | undefined;
    totalCount: number;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
    id!: string;
    webhookUri!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;

    constructor(data?: IGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        return data;
    }

    clone(): GetAllSubscriptionsOutput {
        const json = this.toJSON();
        let result = new GetAllSubscriptionsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetAllSubscriptionsOutput {
    id: string;
    webhookUri: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
}

export class GetAllSubscriptionsOutputListResultDto implements IGetAllSubscriptionsOutputListResultDto {
    items!: GetAllSubscriptionsOutput[] | undefined;

    constructor(data?: IGetAllSubscriptionsOutputListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutputListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutputListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetAllSubscriptionsOutputListResultDto {
        const json = this.toJSON();
        let result = new GetAllSubscriptionsOutputListResultDto();
        result.init(json);
        return result;
    }
}

export interface IGetAllSubscriptionsOutputListResultDto {
    items: GetAllSubscriptionsOutput[] | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application!: ApplicationInfoDto;
    user!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    categories!: CategoryAbtractDto[] | undefined;
    fields!: FieldsAbtractDto[] | undefined;
    topics!: TopicAbtractDto[] | undefined;
    dictionaryType!: DictionaryTypeAbtractDto[] | undefined;
    users!: UserDto[] | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(CategoryAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["fields"])) {
                this.fields = [] as any;
                for (let item of _data["fields"])
                    this.fields!.push(FieldsAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(TopicAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["dictionaryType"])) {
                this.dictionaryType = [] as any;
                for (let item of _data["dictionaryType"])
                    this.dictionaryType!.push(DictionaryTypeAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.fields)) {
            data["fields"] = [];
            for (let item of this.fields)
                data["fields"].push(item.toJSON());
        }
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item.toJSON());
        }
        if (Array.isArray(this.dictionaryType)) {
            data["dictionaryType"] = [];
            for (let item of this.dictionaryType)
                data["dictionaryType"].push(item.toJSON());
        }
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto;
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    categories: CategoryAbtractDto[] | undefined;
    fields: FieldsAbtractDto[] | undefined;
    topics: TopicAbtractDto[] | undefined;
    dictionaryType: DictionaryTypeAbtractDto[] | undefined;
    users: UserDto[] | undefined;
}

export class GetDocumentInforByDKCBCheckDto implements IGetDocumentInforByDKCBCheckDto {
    documentInfo!: DocumentInforDto;
    checkItemInfo!: CheckItemDto;

    constructor(data?: IGetDocumentInforByDKCBCheckDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentInfo = _data["documentInfo"] ? DocumentInforDto.fromJS(_data["documentInfo"]) : <any>undefined;
            this.checkItemInfo = _data["checkItemInfo"] ? CheckItemDto.fromJS(_data["checkItemInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDocumentInforByDKCBCheckDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentInforByDKCBCheckDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentInfo"] = this.documentInfo ? this.documentInfo.toJSON() : <any>undefined;
        data["checkItemInfo"] = this.checkItemInfo ? this.checkItemInfo.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetDocumentInforByDKCBCheckDto {
        const json = this.toJSON();
        let result = new GetDocumentInforByDKCBCheckDto();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentInforByDKCBCheckDto {
    documentInfo: DocumentInforDto;
    checkItemInfo: CheckItemDto;
}

export class GetDocumentInforByDKCBDto implements IGetDocumentInforByDKCBDto {
    documentInfo!: DocumentInforDto;
    document!: DocumentBorrowDto;

    constructor(data?: IGetDocumentInforByDKCBDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentInfo = _data["documentInfo"] ? DocumentInforDto.fromJS(_data["documentInfo"]) : <any>undefined;
            this.document = _data["document"] ? DocumentBorrowDto.fromJS(_data["document"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDocumentInforByDKCBDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDocumentInforByDKCBDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentInfo"] = this.documentInfo ? this.documentInfo.toJSON() : <any>undefined;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        return data;
    }

    clone(): GetDocumentInforByDKCBDto {
        const json = this.toJSON();
        let result = new GetDocumentInforByDKCBDto();
        result.init(json);
        return result;
    }
}

export interface IGetDocumentInforByDKCBDto {
    documentInfo: DocumentInforDto;
    document: DocumentBorrowDto;
}

export class GetInforToManagerOutput implements IGetInforToManagerOutput {
    authors!: AuthorAbtractDto[] | undefined;
    responsitories!: ResponsitoryAbtractDto[] | undefined;
    publisher!: PublisherAbtractDto[] | undefined;
    suppliers!: SupplierAbtractDto[] | undefined;
    langs!: LangAbtractDto[] | undefined;

    constructor(data?: IGetInforToManagerOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["authors"])) {
                this.authors = [] as any;
                for (let item of _data["authors"])
                    this.authors!.push(AuthorAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["responsitories"])) {
                this.responsitories = [] as any;
                for (let item of _data["responsitories"])
                    this.responsitories!.push(ResponsitoryAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["publisher"])) {
                this.publisher = [] as any;
                for (let item of _data["publisher"])
                    this.publisher!.push(PublisherAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["suppliers"])) {
                this.suppliers = [] as any;
                for (let item of _data["suppliers"])
                    this.suppliers!.push(SupplierAbtractDto.fromJS(item));
            }
            if (Array.isArray(_data["langs"])) {
                this.langs = [] as any;
                for (let item of _data["langs"])
                    this.langs!.push(LangAbtractDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetInforToManagerOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInforToManagerOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.authors)) {
            data["authors"] = [];
            for (let item of this.authors)
                data["authors"].push(item.toJSON());
        }
        if (Array.isArray(this.responsitories)) {
            data["responsitories"] = [];
            for (let item of this.responsitories)
                data["responsitories"].push(item.toJSON());
        }
        if (Array.isArray(this.publisher)) {
            data["publisher"] = [];
            for (let item of this.publisher)
                data["publisher"].push(item.toJSON());
        }
        if (Array.isArray(this.suppliers)) {
            data["suppliers"] = [];
            for (let item of this.suppliers)
                data["suppliers"].push(item.toJSON());
        }
        if (Array.isArray(this.langs)) {
            data["langs"] = [];
            for (let item of this.langs)
                data["langs"].push(item.toJSON());
        }
        return data;
    }

    clone(): GetInforToManagerOutput {
        const json = this.toJSON();
        let result = new GetInforToManagerOutput();
        result.init(json);
        return result;
    }
}

export interface IGetInforToManagerOutput {
    authors: AuthorAbtractDto[] | undefined;
    responsitories: ResponsitoryAbtractDto[] | undefined;
    publisher: PublisherAbtractDto[] | undefined;
    suppliers: SupplierAbtractDto[] | undefined;
    langs: LangAbtractDto[] | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    email!: EmailSettingsEditDto;
    sendGmail!: SendGmailSettingsEditDto;
    security!: SecuritySettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.sendGmail = new SendGmailSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.sendGmail = _data["sendGmail"] ? SendGmailSettingsEditDto.fromJS(_data["sendGmail"]) : new SendGmailSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["sendGmail"] = this.sendGmail ? this.sendGmail.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        return data;
    }

    clone(): HostSettingsEditDto {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    email: EmailSettingsEditDto;
    sendGmail: SendGmailSettingsEditDto;
    security: SecuritySettingsEditDto;
}

export enum HttpStatusCode {
    _100 = 100,
    _101 = 101,
    _102 = 102,
    _103 = 103,
    _200 = 200,
    _201 = 201,
    _202 = 202,
    _203 = 203,
    _204 = 204,
    _205 = 205,
    _206 = 206,
    _207 = 207,
    _208 = 208,
    _226 = 226,
    _300 = 300,
    _301 = 301,
    _302 = 302,
    _303 = 303,
    _304 = 304,
    _305 = 305,
    _306 = 306,
    _307 = 307,
    _308 = 308,
    _400 = 400,
    _401 = 401,
    _402 = 402,
    _403 = 403,
    _404 = 404,
    _405 = 405,
    _406 = 406,
    _407 = 407,
    _408 = 408,
    _409 = 409,
    _410 = 410,
    _411 = 411,
    _412 = 412,
    _413 = 413,
    _414 = 414,
    _415 = 415,
    _416 = 416,
    _417 = 417,
    _421 = 421,
    _422 = 422,
    _423 = 423,
    _424 = 424,
    _426 = 426,
    _428 = 428,
    _429 = 429,
    _431 = 431,
    _451 = 451,
    _500 = 500,
    _501 = 501,
    _502 = 502,
    _503 = 503,
    _504 = 504,
    _505 = 505,
    _506 = 506,
    _507 = 507,
    _508 = 508,
    _510 = 510,
    _511 = 511,
}

export class ImportDocumentInput implements IImportDocumentInput {
    do_title!: string | undefined;
    do_date_publish!: string | undefined;
    do_republish!: number;
    do_identifier!: string | undefined;
    do_abstract!: string | undefined;
    do_period_check!: number;
    do_date_available!: Date | undefined;
    do_nr_pages!: number;
    do_translator!: string | undefined;
    do_price!: number;
    lang_name_arr!: string[] | undefined;
    fie_name_arr!: string[] | undefined;
    au_name_arr!: string[] | undefined;
    pu_name!: string | undefined;
    to_name!: string | undefined;
    ca_name!: string | undefined;

    constructor(data?: IImportDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_title = _data["do_title"];
            this.do_date_publish = _data["do_date_publish"];
            this.do_republish = _data["do_republish"];
            this.do_identifier = _data["do_identifier"];
            this.do_abstract = _data["do_abstract"];
            this.do_period_check = _data["do_period_check"];
            this.do_date_available = _data["do_date_available"] ? new Date(_data["do_date_available"].toString()) : <any>undefined;
            this.do_nr_pages = _data["do_nr_pages"];
            this.do_translator = _data["do_translator"];
            this.do_price = _data["do_price"];
            if (Array.isArray(_data["lang_name_arr"])) {
                this.lang_name_arr = [] as any;
                for (let item of _data["lang_name_arr"])
                    this.lang_name_arr!.push(item);
            }
            if (Array.isArray(_data["fie_name_arr"])) {
                this.fie_name_arr = [] as any;
                for (let item of _data["fie_name_arr"])
                    this.fie_name_arr!.push(item);
            }
            if (Array.isArray(_data["au_name_arr"])) {
                this.au_name_arr = [] as any;
                for (let item of _data["au_name_arr"])
                    this.au_name_arr!.push(item);
            }
            this.pu_name = _data["pu_name"];
            this.to_name = _data["to_name"];
            this.ca_name = _data["ca_name"];
        }
    }

    static fromJS(data: any): ImportDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImportDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_title"] = this.do_title;
        data["do_date_publish"] = this.do_date_publish;
        data["do_republish"] = this.do_republish;
        data["do_identifier"] = this.do_identifier;
        data["do_abstract"] = this.do_abstract;
        data["do_period_check"] = this.do_period_check;
        data["do_date_available"] = this.do_date_available ? this.do_date_available.toISOString() : <any>undefined;
        data["do_nr_pages"] = this.do_nr_pages;
        data["do_translator"] = this.do_translator;
        data["do_price"] = this.do_price;
        if (Array.isArray(this.lang_name_arr)) {
            data["lang_name_arr"] = [];
            for (let item of this.lang_name_arr)
                data["lang_name_arr"].push(item);
        }
        if (Array.isArray(this.fie_name_arr)) {
            data["fie_name_arr"] = [];
            for (let item of this.fie_name_arr)
                data["fie_name_arr"].push(item);
        }
        if (Array.isArray(this.au_name_arr)) {
            data["au_name_arr"] = [];
            for (let item of this.au_name_arr)
                data["au_name_arr"].push(item);
        }
        data["pu_name"] = this.pu_name;
        data["to_name"] = this.to_name;
        data["ca_name"] = this.ca_name;
        return data;
    }

    clone(): ImportDocumentInput {
        const json = this.toJSON();
        let result = new ImportDocumentInput();
        result.init(json);
        return result;
    }
}

export interface IImportDocumentInput {
    do_title: string | undefined;
    do_date_publish: string | undefined;
    do_republish: number;
    do_identifier: string | undefined;
    do_abstract: string | undefined;
    do_period_check: number;
    do_date_available: Date | undefined;
    do_nr_pages: number;
    do_translator: string | undefined;
    do_price: number;
    lang_name_arr: string[] | undefined;
    fie_name_arr: string[] | undefined;
    au_name_arr: string[] | undefined;
    pu_name: string | undefined;
    to_name: string | undefined;
    ca_name: string | undefined;
}

export class InitDataInput implements IInitDataInput {
    name!: string | undefined;
    date!: string | undefined;
    list!: string | undefined;

    constructor(data?: IInitDataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.date = _data["date"];
            this.list = _data["list"];
        }
    }

    static fromJS(data: any): InitDataInput {
        data = typeof data === 'object' ? data : {};
        let result = new InitDataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["date"] = this.date;
        data["list"] = this.list;
        return data;
    }

    clone(): InitDataInput {
        const json = this.toJSON();
        let result = new InitDataInput();
        result.init(json);
        return result;
    }
}

export interface IInitDataInput {
    name: string | undefined;
    date: string | undefined;
    list: string | undefined;
}

export class Int64EntityDto implements IInt64EntityDto {
    id!: number;

    constructor(data?: IInt64EntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): Int64EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new Int64EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }

    clone(): Int64EntityDto {
        const json = this.toJSON();
        let result = new Int64EntityDto();
        result.init(json);
        return result;
    }
}

export interface IInt64EntityDto {
    id: number;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data;
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class ItemAuthor implements IItemAuthor {
    id!: number;
    name!: string | undefined;

    constructor(data?: IItemAuthor) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ItemAuthor {
        data = typeof data === 'object' ? data : {};
        let result = new ItemAuthor();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ItemAuthor {
        const json = this.toJSON();
        let result = new ItemAuthor();
        result.init(json);
        return result;
    }
}

export interface IItemAuthor {
    id: number;
    name: string | undefined;
}

export class ItemBorrowReturning implements IItemBorrowReturning {
    do_id!: number;
    do_in_id!: number;

    constructor(data?: IItemBorrowReturning) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_id = _data["do_id"];
            this.do_in_id = _data["do_in_id"];
        }
    }

    static fromJS(data: any): ItemBorrowReturning {
        data = typeof data === 'object' ? data : {};
        let result = new ItemBorrowReturning();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_id"] = this.do_id;
        data["do_in_id"] = this.do_in_id;
        return data;
    }

    clone(): ItemBorrowReturning {
        const json = this.toJSON();
        let result = new ItemBorrowReturning();
        result.init(json);
        return result;
    }
}

export interface IItemBorrowReturning {
    do_id: number;
    do_in_id: number;
}

export class ItemDocument implements IItemDocument {
    id!: number;
    name!: string | undefined;

    constructor(data?: IItemDocument) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ItemDocument {
        data = typeof data === 'object' ? data : {};
        let result = new ItemDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ItemDocument {
        const json = this.toJSON();
        let result = new ItemDocument();
        result.init(json);
        return result;
    }
}

export interface IItemDocument {
    id: number;
    name: string | undefined;
}

export class ItemField implements IItemField {
    id!: number;
    name!: string | undefined;

    constructor(data?: IItemField) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ItemField {
        data = typeof data === 'object' ? data : {};
        let result = new ItemField();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ItemField {
        const json = this.toJSON();
        let result = new ItemField();
        result.init(json);
        return result;
    }
}

export interface IItemField {
    id: number;
    name: string | undefined;
}

export class ItemLanguages implements IItemLanguages {
    id!: number;
    name!: string | undefined;

    constructor(data?: IItemLanguages) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ItemLanguages {
        data = typeof data === 'object' ? data : {};
        let result = new ItemLanguages();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ItemLanguages {
        const json = this.toJSON();
        let result = new ItemLanguages();
        result.init(json);
        return result;
    }
}

export interface IItemLanguages {
    id: number;
    name: string | undefined;
}

export class ItemPublisher implements IItemPublisher {
    id!: number;
    name!: string | undefined;
    address!: string | undefined;

    constructor(data?: IItemPublisher) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): ItemPublisher {
        data = typeof data === 'object' ? data : {};
        let result = new ItemPublisher();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["address"] = this.address;
        return data;
    }

    clone(): ItemPublisher {
        const json = this.toJSON();
        let result = new ItemPublisher();
        result.init(json);
        return result;
    }
}

export interface IItemPublisher {
    id: number;
    name: string | undefined;
    address: string | undefined;
}

export class ItemSendGmail implements IItemSendGmail {
    title!: string | undefined;
    context!: string | undefined;

    constructor(data?: IItemSendGmail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.context = _data["context"];
        }
    }

    static fromJS(data: any): ItemSendGmail {
        data = typeof data === 'object' ? data : {};
        let result = new ItemSendGmail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["context"] = this.context;
        return data;
    }

    clone(): ItemSendGmail {
        const json = this.toJSON();
        let result = new ItemSendGmail();
        result.init(json);
        return result;
    }
}

export interface IItemSendGmail {
    title: string | undefined;
    context: string | undefined;
}

export class ItemSupplier implements IItemSupplier {
    id!: number;
    name!: string | undefined;

    constructor(data?: IItemSupplier) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): ItemSupplier {
        data = typeof data === 'object' ? data : {};
        let result = new ItemSupplier();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }

    clone(): ItemSupplier {
        const json = this.toJSON();
        let result = new ItemSupplier();
        result.init(json);
        return result;
    }
}

export interface IItemSupplier {
    id: number;
    name: string | undefined;
}

export class ItemUser implements IItemUser {
    id!: number;
    name!: string | undefined;
    me_id!: number;

    constructor(data?: IItemUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.me_id = _data["me_id"];
        }
    }

    static fromJS(data: any): ItemUser {
        data = typeof data === 'object' ? data : {};
        let result = new ItemUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["me_id"] = this.me_id;
        return data;
    }

    clone(): ItemUser {
        const json = this.toJSON();
        let result = new ItemUser();
        result.init(json);
        return result;
    }
}

export interface IItemUser {
    id: number;
    name: string | undefined;
    me_id: number;
}

export class LangAbtractDto implements ILangAbtractDto {
    la_id!: number;
    la_title!: string | undefined;

    constructor(data?: ILangAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.la_id = _data["la_id"];
            this.la_title = _data["la_title"];
        }
    }

    static fromJS(data: any): LangAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new LangAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["la_id"] = this.la_id;
        data["la_title"] = this.la_title;
        return data;
    }

    clone(): LangAbtractDto {
        const json = this.toJSON();
        let result = new LangAbtractDto();
        result.init(json);
        return result;
    }
}

export interface ILangAbtractDto {
    la_id: number;
    la_title: string | undefined;
}

export class LanguagesDto implements ILanguagesDto {
    la_id!: number;
    la_title!: string | undefined;
    la_flag!: string | undefined;
    la_enable!: boolean;

    constructor(data?: ILanguagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.la_id = _data["la_id"];
            this.la_title = _data["la_title"];
            this.la_flag = _data["la_flag"];
            this.la_enable = _data["la_enable"];
        }
    }

    static fromJS(data: any): LanguagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["la_id"] = this.la_id;
        data["la_title"] = this.la_title;
        data["la_flag"] = this.la_flag;
        data["la_enable"] = this.la_enable;
        return data;
    }

    clone(): LanguagesDto {
        const json = this.toJSON();
        let result = new LanguagesDto();
        result.init(json);
        return result;
    }
}

export interface ILanguagesDto {
    la_id: number;
    la_title: string | undefined;
    la_flag: string | undefined;
    la_enable: boolean;
}

export class LanguagesDtoListResultDto implements ILanguagesDtoListResultDto {
    items!: LanguagesDto[] | undefined;

    constructor(data?: ILanguagesDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguagesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LanguagesDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguagesDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): LanguagesDtoListResultDto {
        const json = this.toJSON();
        let result = new LanguagesDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface ILanguagesDtoListResultDto {
    items: LanguagesDto[] | undefined;
}

export enum MCardStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export enum MCardType {
    _1 = 1,
    _2 = 2,
}

export class Marc21Dto implements IMarc21Dto {
    mar_id!: number;
    mar_code!: string | undefined;
    mar_desc!: string | undefined;
    mar_sort!: number;
    mar_is_delete!: boolean;
    subFields!: SubFieldMarc21Dto[] | undefined;
    mar_created_at!: Date;
    mar_updated_at!: Date;

    constructor(data?: IMarc21Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mar_id = _data["mar_id"];
            this.mar_code = _data["mar_code"];
            this.mar_desc = _data["mar_desc"];
            this.mar_sort = _data["mar_sort"];
            this.mar_is_delete = _data["mar_is_delete"];
            if (Array.isArray(_data["subFields"])) {
                this.subFields = [] as any;
                for (let item of _data["subFields"])
                    this.subFields!.push(SubFieldMarc21Dto.fromJS(item));
            }
            this.mar_created_at = _data["mar_created_at"] ? new Date(_data["mar_created_at"].toString()) : <any>undefined;
            this.mar_updated_at = _data["mar_updated_at"] ? new Date(_data["mar_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Marc21Dto {
        data = typeof data === 'object' ? data : {};
        let result = new Marc21Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mar_id"] = this.mar_id;
        data["mar_code"] = this.mar_code;
        data["mar_desc"] = this.mar_desc;
        data["mar_sort"] = this.mar_sort;
        data["mar_is_delete"] = this.mar_is_delete;
        if (Array.isArray(this.subFields)) {
            data["subFields"] = [];
            for (let item of this.subFields)
                data["subFields"].push(item.toJSON());
        }
        data["mar_created_at"] = this.mar_created_at ? this.mar_created_at.toISOString() : <any>undefined;
        data["mar_updated_at"] = this.mar_updated_at ? this.mar_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): Marc21Dto {
        const json = this.toJSON();
        let result = new Marc21Dto();
        result.init(json);
        return result;
    }
}

export interface IMarc21Dto {
    mar_id: number;
    mar_code: string | undefined;
    mar_desc: string | undefined;
    mar_sort: number;
    mar_is_delete: boolean;
    subFields: SubFieldMarc21Dto[] | undefined;
    mar_created_at: Date;
    mar_updated_at: Date;
}

export class Marc21DtoPagedResultDto implements IMarc21DtoPagedResultDto {
    items!: Marc21Dto[] | undefined;
    totalCount!: number;

    constructor(data?: IMarc21DtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Marc21Dto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): Marc21DtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new Marc21DtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): Marc21DtoPagedResultDto {
        const json = this.toJSON();
        let result = new Marc21DtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMarc21DtoPagedResultDto {
    items: Marc21Dto[] | undefined;
    totalCount: number;
}

export enum MemberAction {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class MemberCardDto implements IMemberCardDto {
    me_ca_id!: number;
    me_id!: number;
    me_ca_number!: string | undefined;
    me_ca_code!: string | undefined;
    me_ca_status!: MCardStatus;
    me_ca_use_from!: Date;
    me_ca_use_to!: Date;
    me_ca_money!: number;
    me_ca_level!: number;
    me_ca_type!: MCardType;
    me_ca_is_locked!: boolean;
    me_ca_is_active!: boolean;
    me_ca_is_delete!: boolean;
    me_ca_time_receive!: Date | undefined;
    me_ca_time_block!: Date | undefined;
    me_ca_time_extend!: Date | undefined;
    me_ca_created_at!: Date;
    me_ca_updated_at!: Date;

    constructor(data?: IMemberCardDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_ca_id = _data["me_ca_id"];
            this.me_id = _data["me_id"];
            this.me_ca_number = _data["me_ca_number"];
            this.me_ca_code = _data["me_ca_code"];
            this.me_ca_status = _data["me_ca_status"];
            this.me_ca_use_from = _data["me_ca_use_from"] ? new Date(_data["me_ca_use_from"].toString()) : <any>undefined;
            this.me_ca_use_to = _data["me_ca_use_to"] ? new Date(_data["me_ca_use_to"].toString()) : <any>undefined;
            this.me_ca_money = _data["me_ca_money"];
            this.me_ca_level = _data["me_ca_level"];
            this.me_ca_type = _data["me_ca_type"];
            this.me_ca_is_locked = _data["me_ca_is_locked"];
            this.me_ca_is_active = _data["me_ca_is_active"];
            this.me_ca_is_delete = _data["me_ca_is_delete"];
            this.me_ca_time_receive = _data["me_ca_time_receive"] ? new Date(_data["me_ca_time_receive"].toString()) : <any>undefined;
            this.me_ca_time_block = _data["me_ca_time_block"] ? new Date(_data["me_ca_time_block"].toString()) : <any>undefined;
            this.me_ca_time_extend = _data["me_ca_time_extend"] ? new Date(_data["me_ca_time_extend"].toString()) : <any>undefined;
            this.me_ca_created_at = _data["me_ca_created_at"] ? new Date(_data["me_ca_created_at"].toString()) : <any>undefined;
            this.me_ca_updated_at = _data["me_ca_updated_at"] ? new Date(_data["me_ca_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberCardDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCardDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_ca_id"] = this.me_ca_id;
        data["me_id"] = this.me_id;
        data["me_ca_number"] = this.me_ca_number;
        data["me_ca_code"] = this.me_ca_code;
        data["me_ca_status"] = this.me_ca_status;
        data["me_ca_use_from"] = this.me_ca_use_from ? this.me_ca_use_from.toISOString() : <any>undefined;
        data["me_ca_use_to"] = this.me_ca_use_to ? this.me_ca_use_to.toISOString() : <any>undefined;
        data["me_ca_money"] = this.me_ca_money;
        data["me_ca_level"] = this.me_ca_level;
        data["me_ca_type"] = this.me_ca_type;
        data["me_ca_is_locked"] = this.me_ca_is_locked;
        data["me_ca_is_active"] = this.me_ca_is_active;
        data["me_ca_is_delete"] = this.me_ca_is_delete;
        data["me_ca_time_receive"] = this.me_ca_time_receive ? this.me_ca_time_receive.toISOString() : <any>undefined;
        data["me_ca_time_block"] = this.me_ca_time_block ? this.me_ca_time_block.toISOString() : <any>undefined;
        data["me_ca_time_extend"] = this.me_ca_time_extend ? this.me_ca_time_extend.toISOString() : <any>undefined;
        data["me_ca_created_at"] = this.me_ca_created_at ? this.me_ca_created_at.toISOString() : <any>undefined;
        data["me_ca_updated_at"] = this.me_ca_updated_at ? this.me_ca_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): MemberCardDto {
        const json = this.toJSON();
        let result = new MemberCardDto();
        result.init(json);
        return result;
    }
}

export interface IMemberCardDto {
    me_ca_id: number;
    me_id: number;
    me_ca_number: string | undefined;
    me_ca_code: string | undefined;
    me_ca_status: MCardStatus;
    me_ca_use_from: Date;
    me_ca_use_to: Date;
    me_ca_money: number;
    me_ca_level: number;
    me_ca_type: MCardType;
    me_ca_is_locked: boolean;
    me_ca_is_active: boolean;
    me_ca_is_delete: boolean;
    me_ca_time_receive: Date | undefined;
    me_ca_time_block: Date | undefined;
    me_ca_time_extend: Date | undefined;
    me_ca_created_at: Date;
    me_ca_updated_at: Date;
}

export class MemberCardDtoPagedResultDto implements IMemberCardDtoPagedResultDto {
    items!: MemberCardDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMemberCardDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberCardDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MemberCardDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCardDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MemberCardDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MemberCardDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMemberCardDtoPagedResultDto {
    items: MemberCardDto[] | undefined;
    totalCount: number;
}

export class MemberCreateBorrowReturningInput implements IMemberCreateBorrowReturningInput {
    do_id!: number[] | undefined;
    br_re_code!: string | undefined;
    br_re_desc!: string | undefined;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: IMemberCreateBorrowReturningInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["do_id"])) {
                this.do_id = [] as any;
                for (let item of _data["do_id"])
                    this.do_id!.push(item);
            }
            this.br_re_code = _data["br_re_code"];
            this.br_re_desc = _data["br_re_desc"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MemberCreateBorrowReturningInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberCreateBorrowReturningInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.do_id)) {
            data["do_id"] = [];
            for (let item of this.do_id)
                data["do_id"].push(item);
        }
        data["br_re_code"] = this.br_re_code;
        data["br_re_desc"] = this.br_re_desc;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): MemberCreateBorrowReturningInput {
        const json = this.toJSON();
        let result = new MemberCreateBorrowReturningInput();
        result.init(json);
        return result;
    }
}

export interface IMemberCreateBorrowReturningInput {
    do_id: number[] | undefined;
    br_re_code: string | undefined;
    br_re_desc: string | undefined;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class MemberDto implements IMemberDto {
    me_id!: number;
    me_code!: string | undefined;
    me_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    me_status!: MemberRegisterStatus;
    me_has_card!: boolean;
    memberCard!: MemberCardDto;
    me_is_active!: boolean;
    me_is_locked!: boolean;
    me_is_delete!: boolean;
    fi_id!: AttachmentItem;
    me_created_at!: Date;
    me_updated_at!: Date;

    constructor(data?: IMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_code = _data["me_code"];
            this.me_name = _data["me_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.me_status = _data["me_status"];
            this.me_has_card = _data["me_has_card"];
            this.memberCard = _data["memberCard"] ? MemberCardDto.fromJS(_data["memberCard"]) : <any>undefined;
            this.me_is_active = _data["me_is_active"];
            this.me_is_locked = _data["me_is_locked"];
            this.me_is_delete = _data["me_is_delete"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.me_created_at = _data["me_created_at"] ? new Date(_data["me_created_at"].toString()) : <any>undefined;
            this.me_updated_at = _data["me_updated_at"] ? new Date(_data["me_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_code"] = this.me_code;
        data["me_name"] = this.me_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["me_status"] = this.me_status;
        data["me_has_card"] = this.me_has_card;
        data["memberCard"] = this.memberCard ? this.memberCard.toJSON() : <any>undefined;
        data["me_is_active"] = this.me_is_active;
        data["me_is_locked"] = this.me_is_locked;
        data["me_is_delete"] = this.me_is_delete;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["me_created_at"] = this.me_created_at ? this.me_created_at.toISOString() : <any>undefined;
        data["me_updated_at"] = this.me_updated_at ? this.me_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): MemberDto {
        const json = this.toJSON();
        let result = new MemberDto();
        result.init(json);
        return result;
    }
}

export interface IMemberDto {
    me_id: number;
    me_code: string | undefined;
    me_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    me_status: MemberRegisterStatus;
    me_has_card: boolean;
    memberCard: MemberCardDto;
    me_is_active: boolean;
    me_is_locked: boolean;
    me_is_delete: boolean;
    fi_id: AttachmentItem;
    me_created_at: Date;
    me_updated_at: Date;
}

export class MemberDtoPagedResultDto implements IMemberDtoPagedResultDto {
    items!: MemberDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMemberDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MemberDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MemberDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MemberDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMemberDtoPagedResultDto {
    items: MemberDto[] | undefined;
    totalCount: number;
}

export class MemberLogDto implements IMemberLogDto {
    me_lo_id!: number;
    me_id!: number;
    me_lo_action!: MemberAction;
    me_lo_data!: string | undefined;
    me_lo_created_at!: Date;

    constructor(data?: IMemberLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_lo_id = _data["me_lo_id"];
            this.me_id = _data["me_id"];
            this.me_lo_action = _data["me_lo_action"];
            this.me_lo_data = _data["me_lo_data"];
            this.me_lo_created_at = _data["me_lo_created_at"] ? new Date(_data["me_lo_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_lo_id"] = this.me_lo_id;
        data["me_id"] = this.me_id;
        data["me_lo_action"] = this.me_lo_action;
        data["me_lo_data"] = this.me_lo_data;
        data["me_lo_created_at"] = this.me_lo_created_at ? this.me_lo_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): MemberLogDto {
        const json = this.toJSON();
        let result = new MemberLogDto();
        result.init(json);
        return result;
    }
}

export interface IMemberLogDto {
    me_lo_id: number;
    me_id: number;
    me_lo_action: MemberAction;
    me_lo_data: string | undefined;
    me_lo_created_at: Date;
}

export class MemberLogDtoPagedResultDto implements IMemberLogDtoPagedResultDto {
    items!: MemberLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IMemberLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MemberLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): MemberLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): MemberLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new MemberLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IMemberLogDtoPagedResultDto {
    items: MemberLogDto[] | undefined;
    totalCount: number;
}

export enum MemberRegisterStatus {
    _5 = 5,
    _10 = 10,
    _15 = 15,
}

export class MemberSearchBorrowReturningInput implements IMemberSearchBorrowReturningInput {
    skipCount!: number;
    maxResultCount!: number;
    br_re_code!: string | undefined;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    br_re_status!: BorrowReturningProcess;
    br_re_method!: BorrowMethod;

    constructor(data?: IMemberSearchBorrowReturningInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
            this.br_re_code = _data["br_re_code"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            this.br_re_status = _data["br_re_status"];
            this.br_re_method = _data["br_re_method"];
        }
    }

    static fromJS(data: any): MemberSearchBorrowReturningInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberSearchBorrowReturningInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        data["br_re_code"] = this.br_re_code;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        data["br_re_status"] = this.br_re_status;
        data["br_re_method"] = this.br_re_method;
        return data;
    }

    clone(): MemberSearchBorrowReturningInput {
        const json = this.toJSON();
        let result = new MemberSearchBorrowReturningInput();
        result.init(json);
        return result;
    }
}

export interface IMemberSearchBorrowReturningInput {
    skipCount: number;
    maxResultCount: number;
    br_re_code: string | undefined;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    br_re_status: BorrowReturningProcess;
    br_re_method: BorrowMethod;
}

export class MemberSearchBorrowReturningLogInput implements IMemberSearchBorrowReturningLogInput {
    skipCount!: number;
    maxResultCount!: number;
    start_date!: Date | undefined;
    br_re_lo_type!: BorrowReturnLogType;

    constructor(data?: IMemberSearchBorrowReturningLogInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
            this.start_date = _data["start_date"] ? new Date(_data["start_date"].toString()) : <any>undefined;
            this.br_re_lo_type = _data["br_re_lo_type"];
        }
    }

    static fromJS(data: any): MemberSearchBorrowReturningLogInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberSearchBorrowReturningLogInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        data["start_date"] = this.start_date ? this.start_date.toISOString() : <any>undefined;
        data["br_re_lo_type"] = this.br_re_lo_type;
        return data;
    }

    clone(): MemberSearchBorrowReturningLogInput {
        const json = this.toJSON();
        let result = new MemberSearchBorrowReturningLogInput();
        result.init(json);
        return result;
    }
}

export interface IMemberSearchBorrowReturningLogInput {
    skipCount: number;
    maxResultCount: number;
    start_date: Date | undefined;
    br_re_lo_type: BorrowReturnLogType;
}

export class MemberSearchDocumentToBorrowInput implements IMemberSearchDocumentToBorrowInput {
    skipCount!: number;
    maxResultCount!: number;
    do_search!: string | undefined;
    to_id!: number;
    ca_id!: number;
    author!: string | undefined;
    fieldSort!: string | undefined;
    sort!: SORT;

    constructor(data?: IMemberSearchDocumentToBorrowInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skipCount = _data["skipCount"];
            this.maxResultCount = _data["maxResultCount"];
            this.do_search = _data["do_search"];
            this.to_id = _data["to_id"];
            this.ca_id = _data["ca_id"];
            this.author = _data["author"];
            this.fieldSort = _data["fieldSort"];
            this.sort = _data["sort"];
        }
    }

    static fromJS(data: any): MemberSearchDocumentToBorrowInput {
        data = typeof data === 'object' ? data : {};
        let result = new MemberSearchDocumentToBorrowInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skipCount"] = this.skipCount;
        data["maxResultCount"] = this.maxResultCount;
        data["do_search"] = this.do_search;
        data["to_id"] = this.to_id;
        data["ca_id"] = this.ca_id;
        data["author"] = this.author;
        data["fieldSort"] = this.fieldSort;
        data["sort"] = this.sort;
        return data;
    }

    clone(): MemberSearchDocumentToBorrowInput {
        const json = this.toJSON();
        let result = new MemberSearchDocumentToBorrowInput();
        result.init(json);
        return result;
    }
}

export interface IMemberSearchDocumentToBorrowInput {
    skipCount: number;
    maxResultCount: number;
    do_search: string | undefined;
    to_id: number;
    ca_id: number;
    author: string | undefined;
    fieldSort: string | undefined;
    sort: SORT;
}

export class MemberSessionDto implements IMemberSessionDto {
    me_id!: number;
    me_code!: string | undefined;
    me_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    me_pass!: string | undefined;
    me_status!: MemberRegisterStatus;
    me_is_active!: boolean;
    me_is_locked!: boolean;
    me_has_card!: boolean;
    memberCard!: MemberCardDto;
    me_is_delete!: boolean;
    fi_id!: AttachmentItem;
    me_created_at!: Date;
    me_updated_at!: Date;

    constructor(data?: IMemberSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_code = _data["me_code"];
            this.me_name = _data["me_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.me_pass = _data["me_pass"];
            this.me_status = _data["me_status"];
            this.me_is_active = _data["me_is_active"];
            this.me_is_locked = _data["me_is_locked"];
            this.me_has_card = _data["me_has_card"];
            this.memberCard = _data["memberCard"] ? MemberCardDto.fromJS(_data["memberCard"]) : <any>undefined;
            this.me_is_delete = _data["me_is_delete"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.me_created_at = _data["me_created_at"] ? new Date(_data["me_created_at"].toString()) : <any>undefined;
            this.me_updated_at = _data["me_updated_at"] ? new Date(_data["me_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_code"] = this.me_code;
        data["me_name"] = this.me_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["me_pass"] = this.me_pass;
        data["me_status"] = this.me_status;
        data["me_is_active"] = this.me_is_active;
        data["me_is_locked"] = this.me_is_locked;
        data["me_has_card"] = this.me_has_card;
        data["memberCard"] = this.memberCard ? this.memberCard.toJSON() : <any>undefined;
        data["me_is_delete"] = this.me_is_delete;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["me_created_at"] = this.me_created_at ? this.me_created_at.toISOString() : <any>undefined;
        data["me_updated_at"] = this.me_updated_at ? this.me_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): MemberSessionDto {
        const json = this.toJSON();
        let result = new MemberSessionDto();
        result.init(json);
        return result;
    }
}

export interface IMemberSessionDto {
    me_id: number;
    me_code: string | undefined;
    me_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    me_pass: string | undefined;
    me_status: MemberRegisterStatus;
    me_is_active: boolean;
    me_is_locked: boolean;
    me_has_card: boolean;
    memberCard: MemberCardDto;
    me_is_delete: boolean;
    fi_id: AttachmentItem;
    me_created_at: Date;
    me_updated_at: Date;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): NameValueDto {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueDtoPagedResultDto implements INameValueDtoPagedResultDto {
    items!: NameValueDto[] | undefined;
    totalCount!: number;

    constructor(data?: INameValueDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): NameValueDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): NameValueDtoPagedResultDto {
        const json = this.toJSON();
        let result = new NameValueDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDtoPagedResultDto {
    items: NameValueDto[] | undefined;
    totalCount: number;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    lastModificationTime!: Date | undefined;
    lastModifierUserId!: number | undefined;
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        return data;
    }

    clone(): OrganizationUnitDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDto {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
}

export class OrganizationUnitDtoListResultDto implements IOrganizationUnitDtoListResultDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IOrganizationUnitDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrganizationUnitDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): OrganizationUnitDtoListResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitDtoListResultDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    id!: number;
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: Date;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? new Date(_data["addedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): OrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitRoleListDto {
    id: number;
    displayName: string | undefined;
    name: string | undefined;
    addedTime: Date;
}

export class OrganizationUnitRoleListDtoPagedResultDto implements IOrganizationUnitRoleListDtoPagedResultDto {
    items!: OrganizationUnitRoleListDto[] | undefined;
    totalCount!: number;

    constructor(data?: IOrganizationUnitRoleListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): OrganizationUnitRoleListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitRoleListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitRoleListDtoPagedResultDto {
    items: OrganizationUnitRoleListDto[] | undefined;
    totalCount: number;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: Date;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? new Date(_data["addedTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: Date;
}

export class OrganizationUnitUserListDtoPagedResultDto implements IOrganizationUnitUserListDtoPagedResultDto {
    items!: OrganizationUnitUserListDto[] | undefined;
    totalCount!: number;

    constructor(data?: IOrganizationUnitUserListDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): OrganizationUnitUserListDtoPagedResultDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDtoPagedResultDto {
    items: OrganizationUnitUserListDto[] | undefined;
    totalCount: number;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    readonly allowedMinimumLength!: number;
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).allowedMinimumLength = _data["allowedMinimumLength"];
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowedMinimumLength"] = this.allowedMinimumLength;
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }

    clone(): PasswordComplexitySetting {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    allowedMinimumLength: number;
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class PermissionDto implements IPermissionDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class PermissionDtoListResultDto implements IPermissionDtoListResultDto {
    items!: PermissionDto[] | undefined;

    constructor(data?: IPermissionDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PermissionDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PermissionDtoListResultDto {
        const json = this.toJSON();
        let result = new PermissionDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDtoListResultDto {
    items: PermissionDto[] | undefined;
}

export class PlanDetailDto implements IPlanDetailDto {
    pl_de_id!: number;
    pl_id!: number;
    do_id!: ItemDocument;
    pl_de_quantity!: number;
    pl_de_quantity_import!: number;
    pl_de_price!: number;
    pl_de_type!: PlanDetailType;
    pl_de_note!: string | undefined;
    pl_de_status_book!: PlanDetailStatusBook;
    pl_de_status!: PlanDetailStatus;

    constructor(data?: IPlanDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_de_id = _data["pl_de_id"];
            this.pl_id = _data["pl_id"];
            this.do_id = _data["do_id"] ? ItemDocument.fromJS(_data["do_id"]) : <any>undefined;
            this.pl_de_quantity = _data["pl_de_quantity"];
            this.pl_de_quantity_import = _data["pl_de_quantity_import"];
            this.pl_de_price = _data["pl_de_price"];
            this.pl_de_type = _data["pl_de_type"];
            this.pl_de_note = _data["pl_de_note"];
            this.pl_de_status_book = _data["pl_de_status_book"];
            this.pl_de_status = _data["pl_de_status"];
        }
    }

    static fromJS(data: any): PlanDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_de_id"] = this.pl_de_id;
        data["pl_id"] = this.pl_id;
        data["do_id"] = this.do_id ? this.do_id.toJSON() : <any>undefined;
        data["pl_de_quantity"] = this.pl_de_quantity;
        data["pl_de_quantity_import"] = this.pl_de_quantity_import;
        data["pl_de_price"] = this.pl_de_price;
        data["pl_de_type"] = this.pl_de_type;
        data["pl_de_note"] = this.pl_de_note;
        data["pl_de_status_book"] = this.pl_de_status_book;
        data["pl_de_status"] = this.pl_de_status;
        return data;
    }

    clone(): PlanDetailDto {
        const json = this.toJSON();
        let result = new PlanDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPlanDetailDto {
    pl_de_id: number;
    pl_id: number;
    do_id: ItemDocument;
    pl_de_quantity: number;
    pl_de_quantity_import: number;
    pl_de_price: number;
    pl_de_type: PlanDetailType;
    pl_de_note: string | undefined;
    pl_de_status_book: PlanDetailStatusBook;
    pl_de_status: PlanDetailStatus;
}

export class PlanDetailDtoListResultDto implements IPlanDetailDtoListResultDto {
    items!: PlanDetailDto[] | undefined;

    constructor(data?: IPlanDetailDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PlanDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlanDetailDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDetailDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PlanDetailDtoListResultDto {
        const json = this.toJSON();
        let result = new PlanDetailDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPlanDetailDtoListResultDto {
    items: PlanDetailDto[] | undefined;
}

export enum PlanDetailStatus {
    _1 = 1,
    _2 = 2,
}

export enum PlanDetailStatusBook {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export enum PlanDetailType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _7 = 7,
    _8 = 8,
    _9 = 9,
    _10 = 10,
}

export class PlanDto implements IPlanDto {
    pl_id!: number;
    pl_title!: string | undefined;
    pl_process!: PlanProcess;
    us_id_accept!: number;
    us_id_created!: number;
    us_id_updated!: number;
    pl_is_delete!: boolean;
    us_id_delete!: number;
    planDetails!: PlanDetailDto[] | undefined;
    pl_delete_at!: Date | undefined;
    pl_updated_at!: Date;
    pl_created_at!: Date;

    constructor(data?: IPlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_id = _data["pl_id"];
            this.pl_title = _data["pl_title"];
            this.pl_process = _data["pl_process"];
            this.us_id_accept = _data["us_id_accept"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.pl_is_delete = _data["pl_is_delete"];
            this.us_id_delete = _data["us_id_delete"];
            if (Array.isArray(_data["planDetails"])) {
                this.planDetails = [] as any;
                for (let item of _data["planDetails"])
                    this.planDetails!.push(PlanDetailDto.fromJS(item));
            }
            this.pl_delete_at = _data["pl_delete_at"] ? new Date(_data["pl_delete_at"].toString()) : <any>undefined;
            this.pl_updated_at = _data["pl_updated_at"] ? new Date(_data["pl_updated_at"].toString()) : <any>undefined;
            this.pl_created_at = _data["pl_created_at"] ? new Date(_data["pl_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_id"] = this.pl_id;
        data["pl_title"] = this.pl_title;
        data["pl_process"] = this.pl_process;
        data["us_id_accept"] = this.us_id_accept;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["pl_is_delete"] = this.pl_is_delete;
        data["us_id_delete"] = this.us_id_delete;
        if (Array.isArray(this.planDetails)) {
            data["planDetails"] = [];
            for (let item of this.planDetails)
                data["planDetails"].push(item.toJSON());
        }
        data["pl_delete_at"] = this.pl_delete_at ? this.pl_delete_at.toISOString() : <any>undefined;
        data["pl_updated_at"] = this.pl_updated_at ? this.pl_updated_at.toISOString() : <any>undefined;
        data["pl_created_at"] = this.pl_created_at ? this.pl_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): PlanDto {
        const json = this.toJSON();
        let result = new PlanDto();
        result.init(json);
        return result;
    }
}

export interface IPlanDto {
    pl_id: number;
    pl_title: string | undefined;
    pl_process: PlanProcess;
    us_id_accept: number;
    us_id_created: number;
    us_id_updated: number;
    pl_is_delete: boolean;
    us_id_delete: number;
    planDetails: PlanDetailDto[] | undefined;
    pl_delete_at: Date | undefined;
    pl_updated_at: Date;
    pl_created_at: Date;
}

export class PlanDtoListResultDto implements IPlanDtoListResultDto {
    items!: PlanDto[] | undefined;

    constructor(data?: IPlanDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PlanDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PlanDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): PlanDtoListResultDto {
        const json = this.toJSON();
        let result = new PlanDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IPlanDtoListResultDto {
    items: PlanDto[] | undefined;
}

export class PlanDtoPagedResultDto implements IPlanDtoPagedResultDto {
    items!: PlanDto[] | undefined;
    totalCount!: number;

    constructor(data?: IPlanDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PlanDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PlanDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlanDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PlanDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PlanDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPlanDtoPagedResultDto {
    items: PlanDto[] | undefined;
    totalCount: number;
}

export enum PlanProcess {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
    _10 = 10,
}

export class PublishLogDto implements IPublishLogDto {
    pu_lo_id!: number;
    pu_re_id!: number;
    pu_lo_notes!: string | undefined;
    us_id_created!: number;
    pu_lo_created_at!: Date;

    constructor(data?: IPublishLogDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_lo_id = _data["pu_lo_id"];
            this.pu_re_id = _data["pu_re_id"];
            this.pu_lo_notes = _data["pu_lo_notes"];
            this.us_id_created = _data["us_id_created"];
            this.pu_lo_created_at = _data["pu_lo_created_at"] ? new Date(_data["pu_lo_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PublishLogDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishLogDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_lo_id"] = this.pu_lo_id;
        data["pu_re_id"] = this.pu_re_id;
        data["pu_lo_notes"] = this.pu_lo_notes;
        data["us_id_created"] = this.us_id_created;
        data["pu_lo_created_at"] = this.pu_lo_created_at ? this.pu_lo_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): PublishLogDto {
        const json = this.toJSON();
        let result = new PublishLogDto();
        result.init(json);
        return result;
    }
}

export interface IPublishLogDto {
    pu_lo_id: number;
    pu_re_id: number;
    pu_lo_notes: string | undefined;
    us_id_created: number;
    pu_lo_created_at: Date;
}

export class PublishLogDtoPagedResultDto implements IPublishLogDtoPagedResultDto {
    items!: PublishLogDto[] | undefined;
    totalCount!: number;

    constructor(data?: IPublishLogDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PublishLogDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PublishLogDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishLogDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PublishLogDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PublishLogDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPublishLogDtoPagedResultDto {
    items: PublishLogDto[] | undefined;
    totalCount: number;
}

export class PublishRegisterDto implements IPublishRegisterDto {
    pu_re_id!: number;
    pu_re_name!: string | undefined;
    ca_id!: number;
    pu_re_receive_type!: TypePublishRegister;
    me_id!: number;
    pu_re_note!: string | undefined;
    us_id_change_status!: number;
    pu_re_status!: StatusPublishRegister;
    pu_re_change_status_at!: Date;
    pu_re_updated_at!: Date;
    pu_re_created_at!: Date;

    constructor(data?: IPublishRegisterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_re_id = _data["pu_re_id"];
            this.pu_re_name = _data["pu_re_name"];
            this.ca_id = _data["ca_id"];
            this.pu_re_receive_type = _data["pu_re_receive_type"];
            this.me_id = _data["me_id"];
            this.pu_re_note = _data["pu_re_note"];
            this.us_id_change_status = _data["us_id_change_status"];
            this.pu_re_status = _data["pu_re_status"];
            this.pu_re_change_status_at = _data["pu_re_change_status_at"] ? new Date(_data["pu_re_change_status_at"].toString()) : <any>undefined;
            this.pu_re_updated_at = _data["pu_re_updated_at"] ? new Date(_data["pu_re_updated_at"].toString()) : <any>undefined;
            this.pu_re_created_at = _data["pu_re_created_at"] ? new Date(_data["pu_re_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PublishRegisterDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishRegisterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_re_id"] = this.pu_re_id;
        data["pu_re_name"] = this.pu_re_name;
        data["ca_id"] = this.ca_id;
        data["pu_re_receive_type"] = this.pu_re_receive_type;
        data["me_id"] = this.me_id;
        data["pu_re_note"] = this.pu_re_note;
        data["us_id_change_status"] = this.us_id_change_status;
        data["pu_re_status"] = this.pu_re_status;
        data["pu_re_change_status_at"] = this.pu_re_change_status_at ? this.pu_re_change_status_at.toISOString() : <any>undefined;
        data["pu_re_updated_at"] = this.pu_re_updated_at ? this.pu_re_updated_at.toISOString() : <any>undefined;
        data["pu_re_created_at"] = this.pu_re_created_at ? this.pu_re_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): PublishRegisterDto {
        const json = this.toJSON();
        let result = new PublishRegisterDto();
        result.init(json);
        return result;
    }
}

export interface IPublishRegisterDto {
    pu_re_id: number;
    pu_re_name: string | undefined;
    ca_id: number;
    pu_re_receive_type: TypePublishRegister;
    me_id: number;
    pu_re_note: string | undefined;
    us_id_change_status: number;
    pu_re_status: StatusPublishRegister;
    pu_re_change_status_at: Date;
    pu_re_updated_at: Date;
    pu_re_created_at: Date;
}

export class PublishRegisterDtoPagedResultDto implements IPublishRegisterDtoPagedResultDto {
    items!: PublishRegisterDto[] | undefined;
    totalCount!: number;

    constructor(data?: IPublishRegisterDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PublishRegisterDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PublishRegisterDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishRegisterDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PublishRegisterDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PublishRegisterDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPublishRegisterDtoPagedResultDto {
    items: PublishRegisterDto[] | undefined;
    totalCount: number;
}

export class PublishSettingDto implements IPublishSettingDto {
    pu_se_Id!: number;
    ca_id!: number;
    pu_se_note!: string | undefined;
    pu_se_day!: number;
    pu_se_month!: number;
    pu_se_year!: number;
    pu_se_type!: PublishSettingType;
    pu_se_active!: boolean;
    pu_se_condition!: string | undefined;
    us_id_created!: number;
    pu_se_updated_at!: Date;
    pu_se_created_at!: Date;

    constructor(data?: IPublishSettingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_se_Id = _data["pu_se_Id"];
            this.ca_id = _data["ca_id"];
            this.pu_se_note = _data["pu_se_note"];
            this.pu_se_day = _data["pu_se_day"];
            this.pu_se_month = _data["pu_se_month"];
            this.pu_se_year = _data["pu_se_year"];
            this.pu_se_type = _data["pu_se_type"];
            this.pu_se_active = _data["pu_se_active"];
            this.pu_se_condition = _data["pu_se_condition"];
            this.us_id_created = _data["us_id_created"];
            this.pu_se_updated_at = _data["pu_se_updated_at"] ? new Date(_data["pu_se_updated_at"].toString()) : <any>undefined;
            this.pu_se_created_at = _data["pu_se_created_at"] ? new Date(_data["pu_se_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PublishSettingDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishSettingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_se_Id"] = this.pu_se_Id;
        data["ca_id"] = this.ca_id;
        data["pu_se_note"] = this.pu_se_note;
        data["pu_se_day"] = this.pu_se_day;
        data["pu_se_month"] = this.pu_se_month;
        data["pu_se_year"] = this.pu_se_year;
        data["pu_se_type"] = this.pu_se_type;
        data["pu_se_active"] = this.pu_se_active;
        data["pu_se_condition"] = this.pu_se_condition;
        data["us_id_created"] = this.us_id_created;
        data["pu_se_updated_at"] = this.pu_se_updated_at ? this.pu_se_updated_at.toISOString() : <any>undefined;
        data["pu_se_created_at"] = this.pu_se_created_at ? this.pu_se_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): PublishSettingDto {
        const json = this.toJSON();
        let result = new PublishSettingDto();
        result.init(json);
        return result;
    }
}

export interface IPublishSettingDto {
    pu_se_Id: number;
    ca_id: number;
    pu_se_note: string | undefined;
    pu_se_day: number;
    pu_se_month: number;
    pu_se_year: number;
    pu_se_type: PublishSettingType;
    pu_se_active: boolean;
    pu_se_condition: string | undefined;
    us_id_created: number;
    pu_se_updated_at: Date;
    pu_se_created_at: Date;
}

export class PublishSettingDtoPagedResultDto implements IPublishSettingDtoPagedResultDto {
    items!: PublishSettingDto[] | undefined;
    totalCount!: number;

    constructor(data?: IPublishSettingDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PublishSettingDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PublishSettingDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublishSettingDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PublishSettingDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PublishSettingDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPublishSettingDtoPagedResultDto {
    items: PublishSettingDto[] | undefined;
    totalCount: number;
}

export enum PublishSettingType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class PublisherAbtractDto implements IPublisherAbtractDto {
    pu_id!: number;
    pu_short_name!: string | undefined;
    pu_name!: string | undefined;
    pu_address!: string | undefined;
    pu_license!: string | undefined;
    pu_is_delete!: boolean;

    constructor(data?: IPublisherAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_id = _data["pu_id"];
            this.pu_short_name = _data["pu_short_name"];
            this.pu_name = _data["pu_name"];
            this.pu_address = _data["pu_address"];
            this.pu_license = _data["pu_license"];
            this.pu_is_delete = _data["pu_is_delete"];
        }
    }

    static fromJS(data: any): PublisherAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublisherAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_id"] = this.pu_id;
        data["pu_short_name"] = this.pu_short_name;
        data["pu_name"] = this.pu_name;
        data["pu_address"] = this.pu_address;
        data["pu_license"] = this.pu_license;
        data["pu_is_delete"] = this.pu_is_delete;
        return data;
    }

    clone(): PublisherAbtractDto {
        const json = this.toJSON();
        let result = new PublisherAbtractDto();
        result.init(json);
        return result;
    }
}

export interface IPublisherAbtractDto {
    pu_id: number;
    pu_short_name: string | undefined;
    pu_name: string | undefined;
    pu_address: string | undefined;
    pu_license: string | undefined;
    pu_is_delete: boolean;
}

export class PublisherDto implements IPublisherDto {
    pu_id!: number;
    pu_short_name!: string | undefined;
    pu_name!: string | undefined;
    pu_address!: string | undefined;
    pu_license!: string | undefined;
    pu_email!: string | undefined;
    pu_phone!: string | undefined;
    pu_website!: string | undefined;
    pu_infor!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;
    pu_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    pu_created_at!: Date;
    pu_updated_at!: Date;
    pu_delete_at!: Date | undefined;

    constructor(data?: IPublisherDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_id = _data["pu_id"];
            this.pu_short_name = _data["pu_short_name"];
            this.pu_name = _data["pu_name"];
            this.pu_address = _data["pu_address"];
            this.pu_license = _data["pu_license"];
            this.pu_email = _data["pu_email"];
            this.pu_phone = _data["pu_phone"];
            this.pu_website = _data["pu_website"];
            this.pu_infor = _data["pu_infor"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.pu_is_delete = _data["pu_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            this.pu_created_at = _data["pu_created_at"] ? new Date(_data["pu_created_at"].toString()) : <any>undefined;
            this.pu_updated_at = _data["pu_updated_at"] ? new Date(_data["pu_updated_at"].toString()) : <any>undefined;
            this.pu_delete_at = _data["pu_delete_at"] ? new Date(_data["pu_delete_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PublisherDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublisherDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_id"] = this.pu_id;
        data["pu_short_name"] = this.pu_short_name;
        data["pu_name"] = this.pu_name;
        data["pu_address"] = this.pu_address;
        data["pu_license"] = this.pu_license;
        data["pu_email"] = this.pu_email;
        data["pu_phone"] = this.pu_phone;
        data["pu_website"] = this.pu_website;
        data["pu_infor"] = this.pu_infor;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["pu_is_delete"] = this.pu_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        data["pu_created_at"] = this.pu_created_at ? this.pu_created_at.toISOString() : <any>undefined;
        data["pu_updated_at"] = this.pu_updated_at ? this.pu_updated_at.toISOString() : <any>undefined;
        data["pu_delete_at"] = this.pu_delete_at ? this.pu_delete_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): PublisherDto {
        const json = this.toJSON();
        let result = new PublisherDto();
        result.init(json);
        return result;
    }
}

export interface IPublisherDto {
    pu_id: number;
    pu_short_name: string | undefined;
    pu_name: string | undefined;
    pu_address: string | undefined;
    pu_license: string | undefined;
    pu_email: string | undefined;
    pu_phone: string | undefined;
    pu_website: string | undefined;
    pu_infor: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
    pu_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    pu_created_at: Date;
    pu_updated_at: Date;
    pu_delete_at: Date | undefined;
}

export class PublisherDtoPagedResultDto implements IPublisherDtoPagedResultDto {
    items!: PublisherDto[] | undefined;
    totalCount!: number;

    constructor(data?: IPublisherDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PublisherDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PublisherDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PublisherDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PublisherDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PublisherDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPublisherDtoPagedResultDto {
    items: PublisherDto[] | undefined;
    totalCount: number;
}

export class Punish implements IPunish {
    id!: number;
    readonly pun_id!: number;
    us_id_borrow!: number;
    us_id_create!: number;
    br_re_id!: number;
    borrowReturning!: BorrowReturning;
    br_re_de_id!: number;
    borrowReturningDetail!: BorrowReturningDetail;
    pun_reason!: string | undefined;
    pun_error!: PunishError;
    pun_money!: number;
    fi_id_arr!: string | undefined;
    pun_created_at!: Date;
    pun_updated_at!: Date;

    constructor(data?: IPunish) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).pun_id = _data["pun_id"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.us_id_create = _data["us_id_create"];
            this.br_re_id = _data["br_re_id"];
            this.borrowReturning = _data["borrowReturning"] ? BorrowReturning.fromJS(_data["borrowReturning"]) : <any>undefined;
            this.br_re_de_id = _data["br_re_de_id"];
            this.borrowReturningDetail = _data["borrowReturningDetail"] ? BorrowReturningDetail.fromJS(_data["borrowReturningDetail"]) : <any>undefined;
            this.pun_reason = _data["pun_reason"];
            this.pun_error = _data["pun_error"];
            this.pun_money = _data["pun_money"];
            this.fi_id_arr = _data["fi_id_arr"];
            this.pun_created_at = _data["pun_created_at"] ? new Date(_data["pun_created_at"].toString()) : <any>undefined;
            this.pun_updated_at = _data["pun_updated_at"] ? new Date(_data["pun_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Punish {
        data = typeof data === 'object' ? data : {};
        let result = new Punish();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pun_id"] = this.pun_id;
        data["us_id_borrow"] = this.us_id_borrow;
        data["us_id_create"] = this.us_id_create;
        data["br_re_id"] = this.br_re_id;
        data["borrowReturning"] = this.borrowReturning ? this.borrowReturning.toJSON() : <any>undefined;
        data["br_re_de_id"] = this.br_re_de_id;
        data["borrowReturningDetail"] = this.borrowReturningDetail ? this.borrowReturningDetail.toJSON() : <any>undefined;
        data["pun_reason"] = this.pun_reason;
        data["pun_error"] = this.pun_error;
        data["pun_money"] = this.pun_money;
        data["fi_id_arr"] = this.fi_id_arr;
        data["pun_created_at"] = this.pun_created_at ? this.pun_created_at.toISOString() : <any>undefined;
        data["pun_updated_at"] = this.pun_updated_at ? this.pun_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): Punish {
        const json = this.toJSON();
        let result = new Punish();
        result.init(json);
        return result;
    }
}

export interface IPunish {
    id: number;
    pun_id: number;
    us_id_borrow: number;
    us_id_create: number;
    br_re_id: number;
    borrowReturning: BorrowReturning;
    br_re_de_id: number;
    borrowReturningDetail: BorrowReturningDetail;
    pun_reason: string | undefined;
    pun_error: PunishError;
    pun_money: number;
    fi_id_arr: string | undefined;
    pun_created_at: Date;
    pun_updated_at: Date;
}

export class PunishDto implements IPunishDto {
    pun_id!: number;
    us_id_borrow!: number;
    us_id_create!: number;
    br_re_id!: number;
    br_re_de_id!: number;
    pun_reason!: string | undefined;
    pun_error!: PunishError;
    pun_money!: number;
    fi_id_arr!: AttachmentItem[] | undefined;
    pun_created_at!: Date;
    pun_updated_at!: Date;
    borrowReturning!: BorrowReturningDto;
    borrowReturningDetail!: BorrowReturningIDetailDto;

    constructor(data?: IPunishDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pun_id = _data["pun_id"];
            this.us_id_borrow = _data["us_id_borrow"];
            this.us_id_create = _data["us_id_create"];
            this.br_re_id = _data["br_re_id"];
            this.br_re_de_id = _data["br_re_de_id"];
            this.pun_reason = _data["pun_reason"];
            this.pun_error = _data["pun_error"];
            this.pun_money = _data["pun_money"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.pun_created_at = _data["pun_created_at"] ? new Date(_data["pun_created_at"].toString()) : <any>undefined;
            this.pun_updated_at = _data["pun_updated_at"] ? new Date(_data["pun_updated_at"].toString()) : <any>undefined;
            this.borrowReturning = _data["borrowReturning"] ? BorrowReturningDto.fromJS(_data["borrowReturning"]) : <any>undefined;
            this.borrowReturningDetail = _data["borrowReturningDetail"] ? BorrowReturningIDetailDto.fromJS(_data["borrowReturningDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PunishDto {
        data = typeof data === 'object' ? data : {};
        let result = new PunishDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pun_id"] = this.pun_id;
        data["us_id_borrow"] = this.us_id_borrow;
        data["us_id_create"] = this.us_id_create;
        data["br_re_id"] = this.br_re_id;
        data["br_re_de_id"] = this.br_re_de_id;
        data["pun_reason"] = this.pun_reason;
        data["pun_error"] = this.pun_error;
        data["pun_money"] = this.pun_money;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["pun_created_at"] = this.pun_created_at ? this.pun_created_at.toISOString() : <any>undefined;
        data["pun_updated_at"] = this.pun_updated_at ? this.pun_updated_at.toISOString() : <any>undefined;
        data["borrowReturning"] = this.borrowReturning ? this.borrowReturning.toJSON() : <any>undefined;
        data["borrowReturningDetail"] = this.borrowReturningDetail ? this.borrowReturningDetail.toJSON() : <any>undefined;
        return data;
    }

    clone(): PunishDto {
        const json = this.toJSON();
        let result = new PunishDto();
        result.init(json);
        return result;
    }
}

export interface IPunishDto {
    pun_id: number;
    us_id_borrow: number;
    us_id_create: number;
    br_re_id: number;
    br_re_de_id: number;
    pun_reason: string | undefined;
    pun_error: PunishError;
    pun_money: number;
    fi_id_arr: AttachmentItem[] | undefined;
    pun_created_at: Date;
    pun_updated_at: Date;
    borrowReturning: BorrowReturningDto;
    borrowReturningDetail: BorrowReturningIDetailDto;
}

export class PunishDtoPagedResultDto implements IPunishDtoPagedResultDto {
    items!: PunishDto[] | undefined;
    totalCount!: number;

    constructor(data?: IPunishDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(PunishDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): PunishDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PunishDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): PunishDtoPagedResultDto {
        const json = this.toJSON();
        let result = new PunishDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IPunishDtoPagedResultDto {
    items: PunishDto[] | undefined;
    totalCount: number;
}

export enum PunishError {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class Receipt implements IReceipt {
    id!: number;
    readonly rec_id!: number;
    rec_code!: string | undefined;
    rec_reason!: string | undefined;
    rec_import_date!: string | undefined;
    co_id!: number;
    bi_it_id_arr!: string | undefined;
    rec_is_delete!: boolean;
    us_id_created!: number;
    us_id_browser!: number;
    us_id_warehouse!: number;
    rec_status!: ReceiptStatus;
    rec_created_at!: Date;
    rec_updated_at!: Date;

    constructor(data?: IReceipt) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            (<any>this).rec_id = _data["rec_id"];
            this.rec_code = _data["rec_code"];
            this.rec_reason = _data["rec_reason"];
            this.rec_import_date = _data["rec_import_date"];
            this.co_id = _data["co_id"];
            this.bi_it_id_arr = _data["bi_it_id_arr"];
            this.rec_is_delete = _data["rec_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_browser = _data["us_id_browser"];
            this.us_id_warehouse = _data["us_id_warehouse"];
            this.rec_status = _data["rec_status"];
            this.rec_created_at = _data["rec_created_at"] ? new Date(_data["rec_created_at"].toString()) : <any>undefined;
            this.rec_updated_at = _data["rec_updated_at"] ? new Date(_data["rec_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Receipt {
        data = typeof data === 'object' ? data : {};
        let result = new Receipt();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["rec_id"] = this.rec_id;
        data["rec_code"] = this.rec_code;
        data["rec_reason"] = this.rec_reason;
        data["rec_import_date"] = this.rec_import_date;
        data["co_id"] = this.co_id;
        data["bi_it_id_arr"] = this.bi_it_id_arr;
        data["rec_is_delete"] = this.rec_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_browser"] = this.us_id_browser;
        data["us_id_warehouse"] = this.us_id_warehouse;
        data["rec_status"] = this.rec_status;
        data["rec_created_at"] = this.rec_created_at ? this.rec_created_at.toISOString() : <any>undefined;
        data["rec_updated_at"] = this.rec_updated_at ? this.rec_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): Receipt {
        const json = this.toJSON();
        let result = new Receipt();
        result.init(json);
        return result;
    }
}

export interface IReceipt {
    id: number;
    rec_id: number;
    rec_code: string | undefined;
    rec_reason: string | undefined;
    rec_import_date: string | undefined;
    co_id: number;
    bi_it_id_arr: string | undefined;
    rec_is_delete: boolean;
    us_id_created: number;
    us_id_browser: number;
    us_id_warehouse: number;
    rec_status: ReceiptStatus;
    rec_created_at: Date;
    rec_updated_at: Date;
}

export class ReceiptDto implements IReceiptDto {
    rec_id!: number;
    rec_code!: string | undefined;
    rec_reason!: string | undefined;
    rec_import_date!: string | undefined;
    bi_it_id_arr!: number[] | undefined;
    co_id!: number;
    re_is_delete!: boolean;
    us_id_created!: number;
    us_id_browser!: number;
    us_id_warehouse!: number;
    rec_status!: ReceiptStatus;
    rec_created_at!: Date;
    rec_updated_at!: Date;

    constructor(data?: IReceiptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rec_id = _data["rec_id"];
            this.rec_code = _data["rec_code"];
            this.rec_reason = _data["rec_reason"];
            this.rec_import_date = _data["rec_import_date"];
            if (Array.isArray(_data["bi_it_id_arr"])) {
                this.bi_it_id_arr = [] as any;
                for (let item of _data["bi_it_id_arr"])
                    this.bi_it_id_arr!.push(item);
            }
            this.co_id = _data["co_id"];
            this.re_is_delete = _data["re_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_browser = _data["us_id_browser"];
            this.us_id_warehouse = _data["us_id_warehouse"];
            this.rec_status = _data["rec_status"];
            this.rec_created_at = _data["rec_created_at"] ? new Date(_data["rec_created_at"].toString()) : <any>undefined;
            this.rec_updated_at = _data["rec_updated_at"] ? new Date(_data["rec_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReceiptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rec_id"] = this.rec_id;
        data["rec_code"] = this.rec_code;
        data["rec_reason"] = this.rec_reason;
        data["rec_import_date"] = this.rec_import_date;
        if (Array.isArray(this.bi_it_id_arr)) {
            data["bi_it_id_arr"] = [];
            for (let item of this.bi_it_id_arr)
                data["bi_it_id_arr"].push(item);
        }
        data["co_id"] = this.co_id;
        data["re_is_delete"] = this.re_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_browser"] = this.us_id_browser;
        data["us_id_warehouse"] = this.us_id_warehouse;
        data["rec_status"] = this.rec_status;
        data["rec_created_at"] = this.rec_created_at ? this.rec_created_at.toISOString() : <any>undefined;
        data["rec_updated_at"] = this.rec_updated_at ? this.rec_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): ReceiptDto {
        const json = this.toJSON();
        let result = new ReceiptDto();
        result.init(json);
        return result;
    }
}

export interface IReceiptDto {
    rec_id: number;
    rec_code: string | undefined;
    rec_reason: string | undefined;
    rec_import_date: string | undefined;
    bi_it_id_arr: number[] | undefined;
    co_id: number;
    re_is_delete: boolean;
    us_id_created: number;
    us_id_browser: number;
    us_id_warehouse: number;
    rec_status: ReceiptStatus;
    rec_created_at: Date;
    rec_updated_at: Date;
}

export class ReceiptDtoPagedResultDto implements IReceiptDtoPagedResultDto {
    items!: ReceiptDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReceiptDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReceiptDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReceiptDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiptDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReceiptDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReceiptDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReceiptDtoPagedResultDto {
    items: ReceiptDto[] | undefined;
    totalCount: number;
}

export enum ReceiptStatus {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class RechargeCardInput implements IRechargeCardInput {
    me_ca_id!: number;
    me_ca_money!: number;

    constructor(data?: IRechargeCardInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_ca_id = _data["me_ca_id"];
            this.me_ca_money = _data["me_ca_money"];
        }
    }

    static fromJS(data: any): RechargeCardInput {
        data = typeof data === 'object' ? data : {};
        let result = new RechargeCardInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_ca_id"] = this.me_ca_id;
        data["me_ca_money"] = this.me_ca_money;
        return data;
    }

    clone(): RechargeCardInput {
        const json = this.toJSON();
        let result = new RechargeCardInput();
        result.init(json);
        return result;
    }
}

export interface IRechargeCardInput {
    me_ca_id: number;
    me_ca_money: number;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterMemberInput implements IRegisterMemberInput {
    me_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    emailAddress!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: IRegisterMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_name = _data["me_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.emailAddress = _data["emailAddress"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RegisterMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_name"] = this.me_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["emailAddress"] = this.emailAddress;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): RegisterMemberInput {
        const json = this.toJSON();
        let result = new RegisterMemberInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterMemberInput {
    me_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    emailAddress: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    fi_id: AttachmentItem;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ReponsitoryDto implements IReponsitoryDto {
    re_id!: number;
    re_code!: string | undefined;
    re_name!: string | undefined;
    re_desc!: string | undefined;
    re_id_parent!: number;
    re_type!: ReponsitoryType;
    re_sort!: number;
    re_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    re_updated_at!: Date;
    re_created_at!: Date;
    re_delete_at!: Date | undefined;

    constructor(data?: IReponsitoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.re_code = _data["re_code"];
            this.re_name = _data["re_name"];
            this.re_desc = _data["re_desc"];
            this.re_id_parent = _data["re_id_parent"];
            this.re_type = _data["re_type"];
            this.re_sort = _data["re_sort"];
            this.re_is_delete = _data["re_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            this.re_updated_at = _data["re_updated_at"] ? new Date(_data["re_updated_at"].toString()) : <any>undefined;
            this.re_created_at = _data["re_created_at"] ? new Date(_data["re_created_at"].toString()) : <any>undefined;
            this.re_delete_at = _data["re_delete_at"] ? new Date(_data["re_delete_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ReponsitoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReponsitoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["re_code"] = this.re_code;
        data["re_name"] = this.re_name;
        data["re_desc"] = this.re_desc;
        data["re_id_parent"] = this.re_id_parent;
        data["re_type"] = this.re_type;
        data["re_sort"] = this.re_sort;
        data["re_is_delete"] = this.re_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        data["re_updated_at"] = this.re_updated_at ? this.re_updated_at.toISOString() : <any>undefined;
        data["re_created_at"] = this.re_created_at ? this.re_created_at.toISOString() : <any>undefined;
        data["re_delete_at"] = this.re_delete_at ? this.re_delete_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): ReponsitoryDto {
        const json = this.toJSON();
        let result = new ReponsitoryDto();
        result.init(json);
        return result;
    }
}

export interface IReponsitoryDto {
    re_id: number;
    re_code: string | undefined;
    re_name: string | undefined;
    re_desc: string | undefined;
    re_id_parent: number;
    re_type: ReponsitoryType;
    re_sort: number;
    re_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    re_updated_at: Date;
    re_created_at: Date;
    re_delete_at: Date | undefined;
}

export class ReponsitoryDtoPagedResultDto implements IReponsitoryDtoPagedResultDto {
    items!: ReponsitoryDto[] | undefined;
    totalCount!: number;

    constructor(data?: IReponsitoryDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ReponsitoryDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): ReponsitoryDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new ReponsitoryDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): ReponsitoryDtoPagedResultDto {
        const json = this.toJSON();
        let result = new ReponsitoryDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IReponsitoryDtoPagedResultDto {
    items: ReponsitoryDto[] | undefined;
    totalCount: number;
}

export enum ReponsitoryType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
}

export class ResetPasswordDto implements IResetPasswordDto {
    userId!: number;
    newPassword!: string;

    constructor(data?: IResetPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ResetPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["newPassword"] = this.newPassword;
        return data;
    }

    clone(): ResetPasswordDto {
        const json = this.toJSON();
        let result = new ResetPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordDto {
    userId: number;
    newPassword: string;
}

export class ResourceDto implements IResourceDto {
    fo_id!: number;
    fo_name!: string | undefined;
    us_id_owner!: number;
    us_id_last_update!: number;
    fo_ro_type!: ResourceRoleType;
    fo_decs!: string | undefined;
    fo_id_parent!: number;
    fo_link!: string | undefined;
    fo_is_deleted!: boolean;
    fo_created_at!: Date;
    fo_last_updated_at!: Date;
    fo_last_open_at!: Date;
    foldersInside!: FolderDto[] | undefined;
    filesInside!: FilesOfUserDto[] | undefined;

    constructor(data?: IResourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_id = _data["fo_id"];
            this.fo_name = _data["fo_name"];
            this.us_id_owner = _data["us_id_owner"];
            this.us_id_last_update = _data["us_id_last_update"];
            this.fo_ro_type = _data["fo_ro_type"];
            this.fo_decs = _data["fo_decs"];
            this.fo_id_parent = _data["fo_id_parent"];
            this.fo_link = _data["fo_link"];
            this.fo_is_deleted = _data["fo_is_deleted"];
            this.fo_created_at = _data["fo_created_at"] ? new Date(_data["fo_created_at"].toString()) : <any>undefined;
            this.fo_last_updated_at = _data["fo_last_updated_at"] ? new Date(_data["fo_last_updated_at"].toString()) : <any>undefined;
            this.fo_last_open_at = _data["fo_last_open_at"] ? new Date(_data["fo_last_open_at"].toString()) : <any>undefined;
            if (Array.isArray(_data["foldersInside"])) {
                this.foldersInside = [] as any;
                for (let item of _data["foldersInside"])
                    this.foldersInside!.push(FolderDto.fromJS(item));
            }
            if (Array.isArray(_data["filesInside"])) {
                this.filesInside = [] as any;
                for (let item of _data["filesInside"])
                    this.filesInside!.push(FilesOfUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_id"] = this.fo_id;
        data["fo_name"] = this.fo_name;
        data["us_id_owner"] = this.us_id_owner;
        data["us_id_last_update"] = this.us_id_last_update;
        data["fo_ro_type"] = this.fo_ro_type;
        data["fo_decs"] = this.fo_decs;
        data["fo_id_parent"] = this.fo_id_parent;
        data["fo_link"] = this.fo_link;
        data["fo_is_deleted"] = this.fo_is_deleted;
        data["fo_created_at"] = this.fo_created_at ? this.fo_created_at.toISOString() : <any>undefined;
        data["fo_last_updated_at"] = this.fo_last_updated_at ? this.fo_last_updated_at.toISOString() : <any>undefined;
        data["fo_last_open_at"] = this.fo_last_open_at ? this.fo_last_open_at.toISOString() : <any>undefined;
        if (Array.isArray(this.foldersInside)) {
            data["foldersInside"] = [];
            for (let item of this.foldersInside)
                data["foldersInside"].push(item.toJSON());
        }
        if (Array.isArray(this.filesInside)) {
            data["filesInside"] = [];
            for (let item of this.filesInside)
                data["filesInside"].push(item.toJSON());
        }
        return data;
    }

    clone(): ResourceDto {
        const json = this.toJSON();
        let result = new ResourceDto();
        result.init(json);
        return result;
    }
}

export interface IResourceDto {
    fo_id: number;
    fo_name: string | undefined;
    us_id_owner: number;
    us_id_last_update: number;
    fo_ro_type: ResourceRoleType;
    fo_decs: string | undefined;
    fo_id_parent: number;
    fo_link: string | undefined;
    fo_is_deleted: boolean;
    fo_created_at: Date;
    fo_last_updated_at: Date;
    fo_last_open_at: Date;
    foldersInside: FolderDto[] | undefined;
    filesInside: FilesOfUserDto[] | undefined;
}

export enum ResourceRoleStatus {
    _0 = 0,
    _1 = 1,
}

export enum ResourceRoleType {
    _0 = 0,
    _1 = 1,
}

export class ResourceRolesDto implements IResourceRolesDto {
    fo_ro_id!: number;
    us_id!: number;
    fo_id!: number;
    fo_ro_role!: ResourceRoleStatus;
    fo_ro_created_at!: Date;
    fo_ro_updated_at!: Date;
    itemFolder!: FolderDto;
    foldersRolesInside!: FolderRolesDto[] | undefined;
    filesRolesInside!: FilesOfUserRolesDto[] | undefined;

    constructor(data?: IResourceRolesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_ro_id = _data["fo_ro_id"];
            this.us_id = _data["us_id"];
            this.fo_id = _data["fo_id"];
            this.fo_ro_role = _data["fo_ro_role"];
            this.fo_ro_created_at = _data["fo_ro_created_at"] ? new Date(_data["fo_ro_created_at"].toString()) : <any>undefined;
            this.fo_ro_updated_at = _data["fo_ro_updated_at"] ? new Date(_data["fo_ro_updated_at"].toString()) : <any>undefined;
            this.itemFolder = _data["itemFolder"] ? FolderDto.fromJS(_data["itemFolder"]) : <any>undefined;
            if (Array.isArray(_data["foldersRolesInside"])) {
                this.foldersRolesInside = [] as any;
                for (let item of _data["foldersRolesInside"])
                    this.foldersRolesInside!.push(FolderRolesDto.fromJS(item));
            }
            if (Array.isArray(_data["filesRolesInside"])) {
                this.filesRolesInside = [] as any;
                for (let item of _data["filesRolesInside"])
                    this.filesRolesInside!.push(FilesOfUserRolesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResourceRolesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResourceRolesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_ro_id"] = this.fo_ro_id;
        data["us_id"] = this.us_id;
        data["fo_id"] = this.fo_id;
        data["fo_ro_role"] = this.fo_ro_role;
        data["fo_ro_created_at"] = this.fo_ro_created_at ? this.fo_ro_created_at.toISOString() : <any>undefined;
        data["fo_ro_updated_at"] = this.fo_ro_updated_at ? this.fo_ro_updated_at.toISOString() : <any>undefined;
        data["itemFolder"] = this.itemFolder ? this.itemFolder.toJSON() : <any>undefined;
        if (Array.isArray(this.foldersRolesInside)) {
            data["foldersRolesInside"] = [];
            for (let item of this.foldersRolesInside)
                data["foldersRolesInside"].push(item.toJSON());
        }
        if (Array.isArray(this.filesRolesInside)) {
            data["filesRolesInside"] = [];
            for (let item of this.filesRolesInside)
                data["filesRolesInside"].push(item.toJSON());
        }
        return data;
    }

    clone(): ResourceRolesDto {
        const json = this.toJSON();
        let result = new ResourceRolesDto();
        result.init(json);
        return result;
    }
}

export interface IResourceRolesDto {
    fo_ro_id: number;
    us_id: number;
    fo_id: number;
    fo_ro_role: ResourceRoleStatus;
    fo_ro_created_at: Date;
    fo_ro_updated_at: Date;
    itemFolder: FolderDto;
    foldersRolesInside: FolderRolesDto[] | undefined;
    filesRolesInside: FilesOfUserRolesDto[] | undefined;
}

export class ResponsitoryAbtractDto implements IResponsitoryAbtractDto {
    re_id!: number;
    re_code!: string | undefined;
    re_name!: string | undefined;
    re_id_parent!: number;
    re_type!: number;
    re_sort!: number;
    re_is_delete!: boolean;

    constructor(data?: IResponsitoryAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.re_code = _data["re_code"];
            this.re_name = _data["re_name"];
            this.re_id_parent = _data["re_id_parent"];
            this.re_type = _data["re_type"];
            this.re_sort = _data["re_sort"];
            this.re_is_delete = _data["re_is_delete"];
        }
    }

    static fromJS(data: any): ResponsitoryAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponsitoryAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["re_code"] = this.re_code;
        data["re_name"] = this.re_name;
        data["re_id_parent"] = this.re_id_parent;
        data["re_type"] = this.re_type;
        data["re_sort"] = this.re_sort;
        data["re_is_delete"] = this.re_is_delete;
        return data;
    }

    clone(): ResponsitoryAbtractDto {
        const json = this.toJSON();
        let result = new ResponsitoryAbtractDto();
        result.init(json);
        return result;
    }
}

export interface IResponsitoryAbtractDto {
    re_id: number;
    re_code: string | undefined;
    re_name: string | undefined;
    re_id_parent: number;
    re_type: number;
    re_sort: number;
    re_is_delete: boolean;
}

export class ReturnBorrowReturningDetailItem implements IReturnBorrowReturningDetailItem {
    br_re_de_id!: number;
    do_id!: number;
    do_in_id!: number;
    has_lost!: boolean;

    constructor(data?: IReturnBorrowReturningDetailItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_de_id = _data["br_re_de_id"];
            this.do_id = _data["do_id"];
            this.do_in_id = _data["do_in_id"];
            this.has_lost = _data["has_lost"];
        }
    }

    static fromJS(data: any): ReturnBorrowReturningDetailItem {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnBorrowReturningDetailItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_de_id"] = this.br_re_de_id;
        data["do_id"] = this.do_id;
        data["do_in_id"] = this.do_in_id;
        data["has_lost"] = this.has_lost;
        return data;
    }

    clone(): ReturnBorrowReturningDetailItem {
        const json = this.toJSON();
        let result = new ReturnBorrowReturningDetailItem();
        result.init(json);
        return result;
    }
}

export interface IReturnBorrowReturningDetailItem {
    br_re_de_id: number;
    do_id: number;
    do_in_id: number;
    has_lost: boolean;
}

export class ReturnDocumentInput implements IReturnDocumentInput {
    br_re_id!: number;
    fi_id_arr!: AttachmentItem[] | undefined;
    list_document!: ReturnBorrowReturningDetailItem[] | undefined;

    constructor(data?: IReturnDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_id = _data["br_re_id"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["list_document"])) {
                this.list_document = [] as any;
                for (let item of _data["list_document"])
                    this.list_document!.push(ReturnBorrowReturningDetailItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReturnDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new ReturnDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_id"] = this.br_re_id;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.list_document)) {
            data["list_document"] = [];
            for (let item of this.list_document)
                data["list_document"].push(item.toJSON());
        }
        return data;
    }

    clone(): ReturnDocumentInput {
        const json = this.toJSON();
        let result = new ReturnDocumentInput();
        result.init(json);
        return result;
    }
}

export interface IReturnDocumentInput {
    br_re_id: number;
    fi_id_arr: AttachmentItem[] | undefined;
    list_document: ReturnBorrowReturningDetailItem[] | undefined;
}

export class RoleDto implements IRoleDto {
    id!: number;
    name!: string;
    displayName!: string;
    normalizedName!: string | undefined;
    description!: string | undefined;
    isDefault!: boolean;
    isStatic!: boolean;
    typeUserRole!: UserType;
    grantedPermissions!: string[] | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.normalizedName = _data["normalizedName"];
            this.description = _data["description"];
            this.isDefault = _data["isDefault"];
            this.isStatic = _data["isStatic"];
            this.typeUserRole = _data["typeUserRole"];
            if (Array.isArray(_data["grantedPermissions"])) {
                this.grantedPermissions = [] as any;
                for (let item of _data["grantedPermissions"])
                    this.grantedPermissions!.push(item);
            }
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isDefault"] = this.isDefault;
        data["isStatic"] = this.isStatic;
        data["typeUserRole"] = this.typeUserRole;
        if (Array.isArray(this.grantedPermissions)) {
            data["grantedPermissions"] = [];
            for (let item of this.grantedPermissions)
                data["grantedPermissions"].push(item);
        }
        return data;
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    id: number;
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isDefault: boolean;
    isStatic: boolean;
    typeUserRole: UserType;
    grantedPermissions: string[] | undefined;
}

export class RoleDtoListResultDto implements IRoleDtoListResultDto {
    items!: RoleDto[] | undefined;

    constructor(data?: IRoleDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoListResultDto {
    items: RoleDto[] | undefined;
}

export class RoleDtoPagedResultDto implements IRoleDtoPagedResultDto {
    items!: RoleDto[] | undefined;
    totalCount!: number;

    constructor(data?: IRoleDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): RoleDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): RoleDtoPagedResultDto {
        const json = this.toJSON();
        let result = new RoleDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDtoPagedResultDto {
    items: RoleDto[] | undefined;
    totalCount: number;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number;
    name!: string;
    displayName!: string;
    description!: string | undefined;
    isStatic!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isStatic = _data["isStatic"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        return data;
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number;
    name: string;
    displayName: string;
    description: string | undefined;
    isStatic: boolean;
}

export class RoleListDto implements IRoleListDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: Date;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: Date;
}

export class RoleListDtoListResultDto implements IRoleListDtoListResultDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IRoleListDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RoleListDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): RoleListDtoListResultDto {
        const json = this.toJSON();
        let result = new RoleListDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDtoListResultDto {
    items: RoleListDto[] | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): RolesToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new RolesToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export enum SORT {
    _1 = 1,
    _2 = 2,
}

export class SearchStatisticBorrowMostInput implements ISearchStatisticBorrowMostInput {
    day!: number;
    month!: number;
    year!: number;

    constructor(data?: ISearchStatisticBorrowMostInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.day = _data["day"];
            this.month = _data["month"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): SearchStatisticBorrowMostInput {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStatisticBorrowMostInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["day"] = this.day;
        data["month"] = this.month;
        data["year"] = this.year;
        return data;
    }

    clone(): SearchStatisticBorrowMostInput {
        const json = this.toJSON();
        let result = new SearchStatisticBorrowMostInput();
        result.init(json);
        return result;
    }
}

export interface ISearchStatisticBorrowMostInput {
    day: number;
    month: number;
    year: number;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        return data;
    }

    clone(): SecuritySettingsEditDto {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
}

export class SendEmailMemberInput implements ISendEmailMemberInput {
    emailAddress!: string;
    subject_Email!: string | undefined;
    body_Email!: string | undefined;
    replaceBody!: InitDataInput;

    constructor(data?: ISendEmailMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
            this.subject_Email = _data["subject_Email"];
            this.body_Email = _data["body_Email"];
            this.replaceBody = _data["replaceBody"] ? InitDataInput.fromJS(_data["replaceBody"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SendEmailMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["subject_Email"] = this.subject_Email;
        data["body_Email"] = this.body_Email;
        data["replaceBody"] = this.replaceBody ? this.replaceBody.toJSON() : <any>undefined;
        return data;
    }

    clone(): SendEmailMemberInput {
        const json = this.toJSON();
        let result = new SendEmailMemberInput();
        result.init(json);
        return result;
    }
}

export interface ISendEmailMemberInput {
    emailAddress: string;
    subject_Email: string | undefined;
    body_Email: string | undefined;
    replaceBody: InitDataInput;
}

export class SendGmailSettingsEditDto implements ISendGmailSettingsEditDto {
    birthday!: ItemSendGmail;
    createMember!: ItemSendGmail;
    acceptMember!: ItemSendGmail;
    lockMember!: ItemSendGmail;
    editMemberInformation!: ItemSendGmail;
    createMemberCard!: ItemSendGmail;
    acceptMemberCard!: ItemSendGmail;
    expiredCard!: ItemSendGmail;
    lockMemberCard!: ItemSendGmail;
    expiredDocument!: ItemSendGmail;
    recoveredDocument!: ItemSendGmail;
    acceptBorrowDocument!: ItemSendGmail;
    deliverDocument!: ItemSendGmail;
    cancelBorrowDocument!: ItemSendGmail;

    constructor(data?: ISendGmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.birthday = _data["birthday"] ? ItemSendGmail.fromJS(_data["birthday"]) : <any>undefined;
            this.createMember = _data["createMember"] ? ItemSendGmail.fromJS(_data["createMember"]) : <any>undefined;
            this.acceptMember = _data["acceptMember"] ? ItemSendGmail.fromJS(_data["acceptMember"]) : <any>undefined;
            this.lockMember = _data["lockMember"] ? ItemSendGmail.fromJS(_data["lockMember"]) : <any>undefined;
            this.editMemberInformation = _data["editMemberInformation"] ? ItemSendGmail.fromJS(_data["editMemberInformation"]) : <any>undefined;
            this.createMemberCard = _data["createMemberCard"] ? ItemSendGmail.fromJS(_data["createMemberCard"]) : <any>undefined;
            this.acceptMemberCard = _data["acceptMemberCard"] ? ItemSendGmail.fromJS(_data["acceptMemberCard"]) : <any>undefined;
            this.expiredCard = _data["expiredCard"] ? ItemSendGmail.fromJS(_data["expiredCard"]) : <any>undefined;
            this.lockMemberCard = _data["lockMemberCard"] ? ItemSendGmail.fromJS(_data["lockMemberCard"]) : <any>undefined;
            this.expiredDocument = _data["expiredDocument"] ? ItemSendGmail.fromJS(_data["expiredDocument"]) : <any>undefined;
            this.recoveredDocument = _data["recoveredDocument"] ? ItemSendGmail.fromJS(_data["recoveredDocument"]) : <any>undefined;
            this.acceptBorrowDocument = _data["acceptBorrowDocument"] ? ItemSendGmail.fromJS(_data["acceptBorrowDocument"]) : <any>undefined;
            this.deliverDocument = _data["deliverDocument"] ? ItemSendGmail.fromJS(_data["deliverDocument"]) : <any>undefined;
            this.cancelBorrowDocument = _data["cancelBorrowDocument"] ? ItemSendGmail.fromJS(_data["cancelBorrowDocument"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SendGmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendGmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthday"] = this.birthday ? this.birthday.toJSON() : <any>undefined;
        data["createMember"] = this.createMember ? this.createMember.toJSON() : <any>undefined;
        data["acceptMember"] = this.acceptMember ? this.acceptMember.toJSON() : <any>undefined;
        data["lockMember"] = this.lockMember ? this.lockMember.toJSON() : <any>undefined;
        data["editMemberInformation"] = this.editMemberInformation ? this.editMemberInformation.toJSON() : <any>undefined;
        data["createMemberCard"] = this.createMemberCard ? this.createMemberCard.toJSON() : <any>undefined;
        data["acceptMemberCard"] = this.acceptMemberCard ? this.acceptMemberCard.toJSON() : <any>undefined;
        data["expiredCard"] = this.expiredCard ? this.expiredCard.toJSON() : <any>undefined;
        data["lockMemberCard"] = this.lockMemberCard ? this.lockMemberCard.toJSON() : <any>undefined;
        data["expiredDocument"] = this.expiredDocument ? this.expiredDocument.toJSON() : <any>undefined;
        data["recoveredDocument"] = this.recoveredDocument ? this.recoveredDocument.toJSON() : <any>undefined;
        data["acceptBorrowDocument"] = this.acceptBorrowDocument ? this.acceptBorrowDocument.toJSON() : <any>undefined;
        data["deliverDocument"] = this.deliverDocument ? this.deliverDocument.toJSON() : <any>undefined;
        data["cancelBorrowDocument"] = this.cancelBorrowDocument ? this.cancelBorrowDocument.toJSON() : <any>undefined;
        return data;
    }

    clone(): SendGmailSettingsEditDto {
        const json = this.toJSON();
        let result = new SendGmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISendGmailSettingsEditDto {
    birthday: ItemSendGmail;
    createMember: ItemSendGmail;
    acceptMember: ItemSendGmail;
    lockMember: ItemSendGmail;
    editMemberInformation: ItemSendGmail;
    createMemberCard: ItemSendGmail;
    acceptMemberCard: ItemSendGmail;
    expiredCard: ItemSendGmail;
    lockMemberCard: ItemSendGmail;
    expiredDocument: ItemSendGmail;
    recoveredDocument: ItemSendGmail;
    acceptBorrowDocument: ItemSendGmail;
    deliverDocument: ItemSendGmail;
    cancelBorrowDocument: ItemSendGmail;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }

    clone(): SendTestEmailInput {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class Setting implements ISetting {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    lastModificationTime!: Date | undefined;
    lastModifierUserId!: number | undefined;
    tenantId!: number | undefined;
    userId!: number | undefined;
    name!: string;
    value!: string | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
}

export class StatisticBorrowMostDocumentDto implements IStatisticBorrowMostDocumentDto {
    do_id!: number;
    do_title!: string | undefined;
    do_date_publish!: string | undefined;
    do_republish!: number;
    do_identifier!: string | undefined;
    do_translator!: string | undefined;
    do_identifier_citation!: string | undefined;
    do_abstract!: string | undefined;
    do_language_iso!: ItemLanguages[] | undefined;
    do_period_check!: number;
    do_lastest_check!: Date;
    do_date_available!: Date | undefined;
    do_nr_pages!: number;
    fie_id_arr!: ItemField[] | undefined;
    fi_id_arr_cover!: AttachmentItem[] | undefined;
    au_id_arr!: ItemAuthor[] | undefined;
    pu_id!: ItemPublisher;
    to_id!: number;
    ca_id!: number;
    do_num_view!: number;
    do_num_dowload!: number;
    do_num_borrow!: number;
    do_status!: DocumentStatus;
    do_borrow_status!: DocumentBorrowType;
    do_price!: number;
    do_total_book!: number;
    do_total_user_register!: number;
    do_total_book_valid!: number;
    do_remaining_book!: number;
    do_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    fileDocuments!: FileDocumentDto[] | undefined;
    do_created_at!: Date;
    do_updated_at!: Date;
    do_delete_at!: Date;
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    borrowDocuments!: number[] | undefined;

    constructor(data?: IStatisticBorrowMostDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_id = _data["do_id"];
            this.do_title = _data["do_title"];
            this.do_date_publish = _data["do_date_publish"];
            this.do_republish = _data["do_republish"];
            this.do_identifier = _data["do_identifier"];
            this.do_translator = _data["do_translator"];
            this.do_identifier_citation = _data["do_identifier_citation"];
            this.do_abstract = _data["do_abstract"];
            if (Array.isArray(_data["do_language_iso"])) {
                this.do_language_iso = [] as any;
                for (let item of _data["do_language_iso"])
                    this.do_language_iso!.push(ItemLanguages.fromJS(item));
            }
            this.do_period_check = _data["do_period_check"];
            this.do_lastest_check = _data["do_lastest_check"] ? new Date(_data["do_lastest_check"].toString()) : <any>undefined;
            this.do_date_available = _data["do_date_available"] ? new Date(_data["do_date_available"].toString()) : <any>undefined;
            this.do_nr_pages = _data["do_nr_pages"];
            if (Array.isArray(_data["fie_id_arr"])) {
                this.fie_id_arr = [] as any;
                for (let item of _data["fie_id_arr"])
                    this.fie_id_arr!.push(ItemField.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_arr_cover"])) {
                this.fi_id_arr_cover = [] as any;
                for (let item of _data["fi_id_arr_cover"])
                    this.fi_id_arr_cover!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["au_id_arr"])) {
                this.au_id_arr = [] as any;
                for (let item of _data["au_id_arr"])
                    this.au_id_arr!.push(ItemAuthor.fromJS(item));
            }
            this.pu_id = _data["pu_id"] ? ItemPublisher.fromJS(_data["pu_id"]) : <any>undefined;
            this.to_id = _data["to_id"];
            this.ca_id = _data["ca_id"];
            this.do_num_view = _data["do_num_view"];
            this.do_num_dowload = _data["do_num_dowload"];
            this.do_num_borrow = _data["do_num_borrow"];
            this.do_status = _data["do_status"];
            this.do_borrow_status = _data["do_borrow_status"];
            this.do_price = _data["do_price"];
            this.do_total_book = _data["do_total_book"];
            this.do_total_user_register = _data["do_total_user_register"];
            this.do_total_book_valid = _data["do_total_book_valid"];
            this.do_remaining_book = _data["do_remaining_book"];
            this.do_is_delete = _data["do_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            if (Array.isArray(_data["fileDocuments"])) {
                this.fileDocuments = [] as any;
                for (let item of _data["fileDocuments"])
                    this.fileDocuments!.push(FileDocumentDto.fromJS(item));
            }
            this.do_created_at = _data["do_created_at"] ? new Date(_data["do_created_at"].toString()) : <any>undefined;
            this.do_updated_at = _data["do_updated_at"] ? new Date(_data["do_updated_at"].toString()) : <any>undefined;
            this.do_delete_at = _data["do_delete_at"] ? new Date(_data["do_delete_at"].toString()) : <any>undefined;
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["borrowDocuments"])) {
                this.borrowDocuments = [] as any;
                for (let item of _data["borrowDocuments"])
                    this.borrowDocuments!.push(item);
            }
        }
    }

    static fromJS(data: any): StatisticBorrowMostDocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowMostDocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_id"] = this.do_id;
        data["do_title"] = this.do_title;
        data["do_date_publish"] = this.do_date_publish;
        data["do_republish"] = this.do_republish;
        data["do_identifier"] = this.do_identifier;
        data["do_translator"] = this.do_translator;
        data["do_identifier_citation"] = this.do_identifier_citation;
        data["do_abstract"] = this.do_abstract;
        if (Array.isArray(this.do_language_iso)) {
            data["do_language_iso"] = [];
            for (let item of this.do_language_iso)
                data["do_language_iso"].push(item.toJSON());
        }
        data["do_period_check"] = this.do_period_check;
        data["do_lastest_check"] = this.do_lastest_check ? this.do_lastest_check.toISOString() : <any>undefined;
        data["do_date_available"] = this.do_date_available ? this.do_date_available.toISOString() : <any>undefined;
        data["do_nr_pages"] = this.do_nr_pages;
        if (Array.isArray(this.fie_id_arr)) {
            data["fie_id_arr"] = [];
            for (let item of this.fie_id_arr)
                data["fie_id_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_arr_cover)) {
            data["fi_id_arr_cover"] = [];
            for (let item of this.fi_id_arr_cover)
                data["fi_id_arr_cover"].push(item.toJSON());
        }
        if (Array.isArray(this.au_id_arr)) {
            data["au_id_arr"] = [];
            for (let item of this.au_id_arr)
                data["au_id_arr"].push(item.toJSON());
        }
        data["pu_id"] = this.pu_id ? this.pu_id.toJSON() : <any>undefined;
        data["to_id"] = this.to_id;
        data["ca_id"] = this.ca_id;
        data["do_num_view"] = this.do_num_view;
        data["do_num_dowload"] = this.do_num_dowload;
        data["do_num_borrow"] = this.do_num_borrow;
        data["do_status"] = this.do_status;
        data["do_borrow_status"] = this.do_borrow_status;
        data["do_price"] = this.do_price;
        data["do_total_book"] = this.do_total_book;
        data["do_total_user_register"] = this.do_total_user_register;
        data["do_total_book_valid"] = this.do_total_book_valid;
        data["do_remaining_book"] = this.do_remaining_book;
        data["do_is_delete"] = this.do_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        if (Array.isArray(this.fileDocuments)) {
            data["fileDocuments"] = [];
            for (let item of this.fileDocuments)
                data["fileDocuments"].push(item.toJSON());
        }
        data["do_created_at"] = this.do_created_at ? this.do_created_at.toISOString() : <any>undefined;
        data["do_updated_at"] = this.do_updated_at ? this.do_updated_at.toISOString() : <any>undefined;
        data["do_delete_at"] = this.do_delete_at ? this.do_delete_at.toISOString() : <any>undefined;
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.borrowDocuments)) {
            data["borrowDocuments"] = [];
            for (let item of this.borrowDocuments)
                data["borrowDocuments"].push(item);
        }
        return data;
    }

    clone(): StatisticBorrowMostDocumentDto {
        const json = this.toJSON();
        let result = new StatisticBorrowMostDocumentDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowMostDocumentDto {
    do_id: number;
    do_title: string | undefined;
    do_date_publish: string | undefined;
    do_republish: number;
    do_identifier: string | undefined;
    do_translator: string | undefined;
    do_identifier_citation: string | undefined;
    do_abstract: string | undefined;
    do_language_iso: ItemLanguages[] | undefined;
    do_period_check: number;
    do_lastest_check: Date;
    do_date_available: Date | undefined;
    do_nr_pages: number;
    fie_id_arr: ItemField[] | undefined;
    fi_id_arr_cover: AttachmentItem[] | undefined;
    au_id_arr: ItemAuthor[] | undefined;
    pu_id: ItemPublisher;
    to_id: number;
    ca_id: number;
    do_num_view: number;
    do_num_dowload: number;
    do_num_borrow: number;
    do_status: DocumentStatus;
    do_borrow_status: DocumentBorrowType;
    do_price: number;
    do_total_book: number;
    do_total_user_register: number;
    do_total_book_valid: number;
    do_remaining_book: number;
    do_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    fileDocuments: FileDocumentDto[] | undefined;
    do_created_at: Date;
    do_updated_at: Date;
    do_delete_at: Date;
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    borrowDocuments: number[] | undefined;
}

export class StatisticBorrowMostDocumentDtoListResultDto implements IStatisticBorrowMostDocumentDtoListResultDto {
    items!: StatisticBorrowMostDocumentDto[] | undefined;

    constructor(data?: IStatisticBorrowMostDocumentDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticBorrowMostDocumentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticBorrowMostDocumentDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowMostDocumentDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticBorrowMostDocumentDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticBorrowMostDocumentDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowMostDocumentDtoListResultDto {
    items: StatisticBorrowMostDocumentDto[] | undefined;
}

export class StatisticBorrowMostLibrarianDto implements IStatisticBorrowMostLibrarianDto {
    id!: number;
    userName!: string;
    name!: string | undefined;
    surname!: string;
    emailAddress!: string;
    isActive!: boolean;
    fullName!: string | undefined;
    lastLoginTime!: Date | undefined;
    creationTime!: Date;
    roleNames!: string[] | undefined;
    us_address!: string | undefined;
    us_dob!: Date | undefined;
    us_gender!: GENDER;
    us_type!: UserType;
    me_id!: number;
    us_po_id!: number;
    dep_id!: number;
    pr_id!: number;
    isDeleted!: boolean;
    us_avatar!: number;
    us_cmt_locked_default!: boolean;
    us_updated_at!: Date;
    us_created_at!: Date;
    key!: string | undefined;
    nameDisplay!: string | undefined;
    borrowDocuments!: number[] | undefined;

    constructor(data?: IStatisticBorrowMostLibrarianDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? new Date(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.us_address = _data["us_address"];
            this.us_dob = _data["us_dob"] ? new Date(_data["us_dob"].toString()) : <any>undefined;
            this.us_gender = _data["us_gender"];
            this.us_type = _data["us_type"];
            this.me_id = _data["me_id"];
            this.us_po_id = _data["us_po_id"];
            this.dep_id = _data["dep_id"];
            this.pr_id = _data["pr_id"];
            this.isDeleted = _data["isDeleted"];
            this.us_avatar = _data["us_avatar"];
            this.us_cmt_locked_default = _data["us_cmt_locked_default"];
            this.us_updated_at = _data["us_updated_at"] ? new Date(_data["us_updated_at"].toString()) : <any>undefined;
            this.us_created_at = _data["us_created_at"] ? new Date(_data["us_created_at"].toString()) : <any>undefined;
            this.key = _data["key"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["borrowDocuments"])) {
                this.borrowDocuments = [] as any;
                for (let item of _data["borrowDocuments"])
                    this.borrowDocuments!.push(item);
            }
        }
    }

    static fromJS(data: any): StatisticBorrowMostLibrarianDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowMostLibrarianDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["us_address"] = this.us_address;
        data["us_dob"] = this.us_dob ? this.us_dob.toISOString() : <any>undefined;
        data["us_gender"] = this.us_gender;
        data["us_type"] = this.us_type;
        data["me_id"] = this.me_id;
        data["us_po_id"] = this.us_po_id;
        data["dep_id"] = this.dep_id;
        data["pr_id"] = this.pr_id;
        data["isDeleted"] = this.isDeleted;
        data["us_avatar"] = this.us_avatar;
        data["us_cmt_locked_default"] = this.us_cmt_locked_default;
        data["us_updated_at"] = this.us_updated_at ? this.us_updated_at.toISOString() : <any>undefined;
        data["us_created_at"] = this.us_created_at ? this.us_created_at.toISOString() : <any>undefined;
        data["key"] = this.key;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.borrowDocuments)) {
            data["borrowDocuments"] = [];
            for (let item of this.borrowDocuments)
                data["borrowDocuments"].push(item);
        }
        return data;
    }

    clone(): StatisticBorrowMostLibrarianDto {
        const json = this.toJSON();
        let result = new StatisticBorrowMostLibrarianDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowMostLibrarianDto {
    id: number;
    userName: string;
    name: string | undefined;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: Date | undefined;
    creationTime: Date;
    roleNames: string[] | undefined;
    us_address: string | undefined;
    us_dob: Date | undefined;
    us_gender: GENDER;
    us_type: UserType;
    me_id: number;
    us_po_id: number;
    dep_id: number;
    pr_id: number;
    isDeleted: boolean;
    us_avatar: number;
    us_cmt_locked_default: boolean;
    us_updated_at: Date;
    us_created_at: Date;
    key: string | undefined;
    nameDisplay: string | undefined;
    borrowDocuments: number[] | undefined;
}

export class StatisticBorrowMostLibrarianDtoListResultDto implements IStatisticBorrowMostLibrarianDtoListResultDto {
    items!: StatisticBorrowMostLibrarianDto[] | undefined;

    constructor(data?: IStatisticBorrowMostLibrarianDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticBorrowMostLibrarianDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticBorrowMostLibrarianDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowMostLibrarianDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticBorrowMostLibrarianDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticBorrowMostLibrarianDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowMostLibrarianDtoListResultDto {
    items: StatisticBorrowMostLibrarianDto[] | undefined;
}

export class StatisticBorrowMostMemberDto implements IStatisticBorrowMostMemberDto {
    me_id!: number;
    me_code!: string | undefined;
    me_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    me_status!: MemberRegisterStatus;
    me_has_card!: boolean;
    memberCard!: MemberCardDto;
    me_is_active!: boolean;
    me_is_locked!: boolean;
    me_is_delete!: boolean;
    fi_id!: AttachmentItem;
    me_created_at!: Date;
    me_updated_at!: Date;
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    borrowDocuments!: number[] | undefined;

    constructor(data?: IStatisticBorrowMostMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_code = _data["me_code"];
            this.me_name = _data["me_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.me_status = _data["me_status"];
            this.me_has_card = _data["me_has_card"];
            this.memberCard = _data["memberCard"] ? MemberCardDto.fromJS(_data["memberCard"]) : <any>undefined;
            this.me_is_active = _data["me_is_active"];
            this.me_is_locked = _data["me_is_locked"];
            this.me_is_delete = _data["me_is_delete"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
            this.me_created_at = _data["me_created_at"] ? new Date(_data["me_created_at"].toString()) : <any>undefined;
            this.me_updated_at = _data["me_updated_at"] ? new Date(_data["me_updated_at"].toString()) : <any>undefined;
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["borrowDocuments"])) {
                this.borrowDocuments = [] as any;
                for (let item of _data["borrowDocuments"])
                    this.borrowDocuments!.push(item);
            }
        }
    }

    static fromJS(data: any): StatisticBorrowMostMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowMostMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_code"] = this.me_code;
        data["me_name"] = this.me_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["me_status"] = this.me_status;
        data["me_has_card"] = this.me_has_card;
        data["memberCard"] = this.memberCard ? this.memberCard.toJSON() : <any>undefined;
        data["me_is_active"] = this.me_is_active;
        data["me_is_locked"] = this.me_is_locked;
        data["me_is_delete"] = this.me_is_delete;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        data["me_created_at"] = this.me_created_at ? this.me_created_at.toISOString() : <any>undefined;
        data["me_updated_at"] = this.me_updated_at ? this.me_updated_at.toISOString() : <any>undefined;
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.borrowDocuments)) {
            data["borrowDocuments"] = [];
            for (let item of this.borrowDocuments)
                data["borrowDocuments"].push(item);
        }
        return data;
    }

    clone(): StatisticBorrowMostMemberDto {
        const json = this.toJSON();
        let result = new StatisticBorrowMostMemberDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowMostMemberDto {
    me_id: number;
    me_code: string | undefined;
    me_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    me_status: MemberRegisterStatus;
    me_has_card: boolean;
    memberCard: MemberCardDto;
    me_is_active: boolean;
    me_is_locked: boolean;
    me_is_delete: boolean;
    fi_id: AttachmentItem;
    me_created_at: Date;
    me_updated_at: Date;
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    borrowDocuments: number[] | undefined;
}

export class StatisticBorrowMostMemberDtoListResultDto implements IStatisticBorrowMostMemberDtoListResultDto {
    items!: StatisticBorrowMostMemberDto[] | undefined;

    constructor(data?: IStatisticBorrowMostMemberDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticBorrowMostMemberDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticBorrowMostMemberDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowMostMemberDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticBorrowMostMemberDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticBorrowMostMemberDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowMostMemberDtoListResultDto {
    items: StatisticBorrowMostMemberDto[] | undefined;
}

export class StatisticBorrowReturningWithCategoryDto implements IStatisticBorrowReturningWithCategoryDto {
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    borrows!: number[] | undefined;
    overdues!: number[] | undefined;
    needToRecover!: number[] | undefined;
    requestExtensions!: number[] | undefined;
    returnings!: number[] | undefined;
    losts!: number[] | undefined;

    constructor(data?: IStatisticBorrowReturningWithCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["borrows"])) {
                this.borrows = [] as any;
                for (let item of _data["borrows"])
                    this.borrows!.push(item);
            }
            if (Array.isArray(_data["overdues"])) {
                this.overdues = [] as any;
                for (let item of _data["overdues"])
                    this.overdues!.push(item);
            }
            if (Array.isArray(_data["needToRecover"])) {
                this.needToRecover = [] as any;
                for (let item of _data["needToRecover"])
                    this.needToRecover!.push(item);
            }
            if (Array.isArray(_data["requestExtensions"])) {
                this.requestExtensions = [] as any;
                for (let item of _data["requestExtensions"])
                    this.requestExtensions!.push(item);
            }
            if (Array.isArray(_data["returnings"])) {
                this.returnings = [] as any;
                for (let item of _data["returnings"])
                    this.returnings!.push(item);
            }
            if (Array.isArray(_data["losts"])) {
                this.losts = [] as any;
                for (let item of _data["losts"])
                    this.losts!.push(item);
            }
        }
    }

    static fromJS(data: any): StatisticBorrowReturningWithCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowReturningWithCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.borrows)) {
            data["borrows"] = [];
            for (let item of this.borrows)
                data["borrows"].push(item);
        }
        if (Array.isArray(this.overdues)) {
            data["overdues"] = [];
            for (let item of this.overdues)
                data["overdues"].push(item);
        }
        if (Array.isArray(this.needToRecover)) {
            data["needToRecover"] = [];
            for (let item of this.needToRecover)
                data["needToRecover"].push(item);
        }
        if (Array.isArray(this.requestExtensions)) {
            data["requestExtensions"] = [];
            for (let item of this.requestExtensions)
                data["requestExtensions"].push(item);
        }
        if (Array.isArray(this.returnings)) {
            data["returnings"] = [];
            for (let item of this.returnings)
                data["returnings"].push(item);
        }
        if (Array.isArray(this.losts)) {
            data["losts"] = [];
            for (let item of this.losts)
                data["losts"].push(item);
        }
        return data;
    }

    clone(): StatisticBorrowReturningWithCategoryDto {
        const json = this.toJSON();
        let result = new StatisticBorrowReturningWithCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowReturningWithCategoryDto {
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    borrows: number[] | undefined;
    overdues: number[] | undefined;
    needToRecover: number[] | undefined;
    requestExtensions: number[] | undefined;
    returnings: number[] | undefined;
    losts: number[] | undefined;
}

export class StatisticBorrowReturningWithCategoryDtoListResultDto implements IStatisticBorrowReturningWithCategoryDtoListResultDto {
    items!: StatisticBorrowReturningWithCategoryDto[] | undefined;

    constructor(data?: IStatisticBorrowReturningWithCategoryDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticBorrowReturningWithCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticBorrowReturningWithCategoryDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowReturningWithCategoryDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticBorrowReturningWithCategoryDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticBorrowReturningWithCategoryDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowReturningWithCategoryDtoListResultDto {
    items: StatisticBorrowReturningWithCategoryDto[] | undefined;
}

export class StatisticBorrowReturningWithMonthDto implements IStatisticBorrowReturningWithMonthDto {
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    borrows!: number[] | undefined;
    returnings!: number[] | undefined;

    constructor(data?: IStatisticBorrowReturningWithMonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["borrows"])) {
                this.borrows = [] as any;
                for (let item of _data["borrows"])
                    this.borrows!.push(item);
            }
            if (Array.isArray(_data["returnings"])) {
                this.returnings = [] as any;
                for (let item of _data["returnings"])
                    this.returnings!.push(item);
            }
        }
    }

    static fromJS(data: any): StatisticBorrowReturningWithMonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowReturningWithMonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.borrows)) {
            data["borrows"] = [];
            for (let item of this.borrows)
                data["borrows"].push(item);
        }
        if (Array.isArray(this.returnings)) {
            data["returnings"] = [];
            for (let item of this.returnings)
                data["returnings"].push(item);
        }
        return data;
    }

    clone(): StatisticBorrowReturningWithMonthDto {
        const json = this.toJSON();
        let result = new StatisticBorrowReturningWithMonthDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowReturningWithMonthDto {
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    borrows: number[] | undefined;
    returnings: number[] | undefined;
}

export class StatisticBorrowReturningWithMonthDtoListResultDto implements IStatisticBorrowReturningWithMonthDtoListResultDto {
    items!: StatisticBorrowReturningWithMonthDto[] | undefined;

    constructor(data?: IStatisticBorrowReturningWithMonthDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticBorrowReturningWithMonthDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticBorrowReturningWithMonthDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticBorrowReturningWithMonthDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticBorrowReturningWithMonthDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticBorrowReturningWithMonthDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticBorrowReturningWithMonthDtoListResultDto {
    items: StatisticBorrowReturningWithMonthDto[] | undefined;
}

export class StatisticContractWithSupplierDto implements IStatisticContractWithSupplierDto {
    pl_id!: number;
    pl_title!: string | undefined;
    pl_process!: PlanProcess;
    us_id_accept!: number;
    us_id_created!: number;
    us_id_updated!: number;
    pl_is_delete!: boolean;
    us_id_delete!: number;
    planDetails!: PlanDetailDto[] | undefined;
    pl_delete_at!: Date | undefined;
    pl_updated_at!: Date;
    pl_created_at!: Date;
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    plansDetail!: number[] | undefined;
    totalPricePlan!: number;

    constructor(data?: IStatisticContractWithSupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_id = _data["pl_id"];
            this.pl_title = _data["pl_title"];
            this.pl_process = _data["pl_process"];
            this.us_id_accept = _data["us_id_accept"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.pl_is_delete = _data["pl_is_delete"];
            this.us_id_delete = _data["us_id_delete"];
            if (Array.isArray(_data["planDetails"])) {
                this.planDetails = [] as any;
                for (let item of _data["planDetails"])
                    this.planDetails!.push(PlanDetailDto.fromJS(item));
            }
            this.pl_delete_at = _data["pl_delete_at"] ? new Date(_data["pl_delete_at"].toString()) : <any>undefined;
            this.pl_updated_at = _data["pl_updated_at"] ? new Date(_data["pl_updated_at"].toString()) : <any>undefined;
            this.pl_created_at = _data["pl_created_at"] ? new Date(_data["pl_created_at"].toString()) : <any>undefined;
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["plansDetail"])) {
                this.plansDetail = [] as any;
                for (let item of _data["plansDetail"])
                    this.plansDetail!.push(item);
            }
            this.totalPricePlan = _data["totalPricePlan"];
        }
    }

    static fromJS(data: any): StatisticContractWithSupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticContractWithSupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_id"] = this.pl_id;
        data["pl_title"] = this.pl_title;
        data["pl_process"] = this.pl_process;
        data["us_id_accept"] = this.us_id_accept;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["pl_is_delete"] = this.pl_is_delete;
        data["us_id_delete"] = this.us_id_delete;
        if (Array.isArray(this.planDetails)) {
            data["planDetails"] = [];
            for (let item of this.planDetails)
                data["planDetails"].push(item.toJSON());
        }
        data["pl_delete_at"] = this.pl_delete_at ? this.pl_delete_at.toISOString() : <any>undefined;
        data["pl_updated_at"] = this.pl_updated_at ? this.pl_updated_at.toISOString() : <any>undefined;
        data["pl_created_at"] = this.pl_created_at ? this.pl_created_at.toISOString() : <any>undefined;
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.plansDetail)) {
            data["plansDetail"] = [];
            for (let item of this.plansDetail)
                data["plansDetail"].push(item);
        }
        data["totalPricePlan"] = this.totalPricePlan;
        return data;
    }

    clone(): StatisticContractWithSupplierDto {
        const json = this.toJSON();
        let result = new StatisticContractWithSupplierDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticContractWithSupplierDto {
    pl_id: number;
    pl_title: string | undefined;
    pl_process: PlanProcess;
    us_id_accept: number;
    us_id_created: number;
    us_id_updated: number;
    pl_is_delete: boolean;
    us_id_delete: number;
    planDetails: PlanDetailDto[] | undefined;
    pl_delete_at: Date | undefined;
    pl_updated_at: Date;
    pl_created_at: Date;
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    plansDetail: number[] | undefined;
    totalPricePlan: number;
}

export class StatisticContractWithSupplierDtoListResultDto implements IStatisticContractWithSupplierDtoListResultDto {
    items!: StatisticContractWithSupplierDto[] | undefined;

    constructor(data?: IStatisticContractWithSupplierDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticContractWithSupplierDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticContractWithSupplierDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticContractWithSupplierDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticContractWithSupplierDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticContractWithSupplierDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticContractWithSupplierDtoListResultDto {
    items: StatisticContractWithSupplierDto[] | undefined;
}

export class StatisticPlanMostMoneyDto implements IStatisticPlanMostMoneyDto {
    pl_id!: number;
    pl_title!: string | undefined;
    pl_process!: PlanProcess;
    us_id_accept!: number;
    us_id_created!: number;
    us_id_updated!: number;
    pl_is_delete!: boolean;
    us_id_delete!: number;
    planDetails!: PlanDetailDto[] | undefined;
    pl_delete_at!: Date | undefined;
    pl_updated_at!: Date;
    pl_created_at!: Date;
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    moneyTotal!: number;

    constructor(data?: IStatisticPlanMostMoneyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_id = _data["pl_id"];
            this.pl_title = _data["pl_title"];
            this.pl_process = _data["pl_process"];
            this.us_id_accept = _data["us_id_accept"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.pl_is_delete = _data["pl_is_delete"];
            this.us_id_delete = _data["us_id_delete"];
            if (Array.isArray(_data["planDetails"])) {
                this.planDetails = [] as any;
                for (let item of _data["planDetails"])
                    this.planDetails!.push(PlanDetailDto.fromJS(item));
            }
            this.pl_delete_at = _data["pl_delete_at"] ? new Date(_data["pl_delete_at"].toString()) : <any>undefined;
            this.pl_updated_at = _data["pl_updated_at"] ? new Date(_data["pl_updated_at"].toString()) : <any>undefined;
            this.pl_created_at = _data["pl_created_at"] ? new Date(_data["pl_created_at"].toString()) : <any>undefined;
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            this.moneyTotal = _data["moneyTotal"];
        }
    }

    static fromJS(data: any): StatisticPlanMostMoneyDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticPlanMostMoneyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_id"] = this.pl_id;
        data["pl_title"] = this.pl_title;
        data["pl_process"] = this.pl_process;
        data["us_id_accept"] = this.us_id_accept;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["pl_is_delete"] = this.pl_is_delete;
        data["us_id_delete"] = this.us_id_delete;
        if (Array.isArray(this.planDetails)) {
            data["planDetails"] = [];
            for (let item of this.planDetails)
                data["planDetails"].push(item.toJSON());
        }
        data["pl_delete_at"] = this.pl_delete_at ? this.pl_delete_at.toISOString() : <any>undefined;
        data["pl_updated_at"] = this.pl_updated_at ? this.pl_updated_at.toISOString() : <any>undefined;
        data["pl_created_at"] = this.pl_created_at ? this.pl_created_at.toISOString() : <any>undefined;
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        data["moneyTotal"] = this.moneyTotal;
        return data;
    }

    clone(): StatisticPlanMostMoneyDto {
        const json = this.toJSON();
        let result = new StatisticPlanMostMoneyDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticPlanMostMoneyDto {
    pl_id: number;
    pl_title: string | undefined;
    pl_process: PlanProcess;
    us_id_accept: number;
    us_id_created: number;
    us_id_updated: number;
    pl_is_delete: boolean;
    us_id_delete: number;
    planDetails: PlanDetailDto[] | undefined;
    pl_delete_at: Date | undefined;
    pl_updated_at: Date;
    pl_created_at: Date;
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    moneyTotal: number;
}

export class StatisticPlanMostMoneyDtoListResultDto implements IStatisticPlanMostMoneyDtoListResultDto {
    items!: StatisticPlanMostMoneyDto[] | undefined;

    constructor(data?: IStatisticPlanMostMoneyDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticPlanMostMoneyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticPlanMostMoneyDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticPlanMostMoneyDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticPlanMostMoneyDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticPlanMostMoneyDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticPlanMostMoneyDtoListResultDto {
    items: StatisticPlanMostMoneyDto[] | undefined;
}

export class StatisticPlanWithMonthDto implements IStatisticPlanWithMonthDto {
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    plans!: number[] | undefined;
    totalPriceplans!: number;

    constructor(data?: IStatisticPlanWithMonthDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["plans"])) {
                this.plans = [] as any;
                for (let item of _data["plans"])
                    this.plans!.push(item);
            }
            this.totalPriceplans = _data["totalPriceplans"];
        }
    }

    static fromJS(data: any): StatisticPlanWithMonthDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticPlanWithMonthDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.plans)) {
            data["plans"] = [];
            for (let item of this.plans)
                data["plans"].push(item);
        }
        data["totalPriceplans"] = this.totalPriceplans;
        return data;
    }

    clone(): StatisticPlanWithMonthDto {
        const json = this.toJSON();
        let result = new StatisticPlanWithMonthDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticPlanWithMonthDto {
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    plans: number[] | undefined;
    totalPriceplans: number;
}

export class StatisticPlanWithMonthDtoListResultDto implements IStatisticPlanWithMonthDtoListResultDto {
    items!: StatisticPlanWithMonthDto[] | undefined;

    constructor(data?: IStatisticPlanWithMonthDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticPlanWithMonthDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticPlanWithMonthDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticPlanWithMonthDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticPlanWithMonthDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticPlanWithMonthDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticPlanWithMonthDtoListResultDto {
    items: StatisticPlanWithMonthDto[] | undefined;
}

export class StatisticStatusOfDocumentsWithCategoryDto implements IStatisticStatusOfDocumentsWithCategoryDto {
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    lostOfDocument!: number[] | undefined;
    borrowOfDocument!: number[] | undefined;
    brokenOfDocument!: number[] | undefined;
    validOfDocument!: number[] | undefined;
    totalDocument!: number[] | undefined;

    constructor(data?: IStatisticStatusOfDocumentsWithCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["lostOfDocument"])) {
                this.lostOfDocument = [] as any;
                for (let item of _data["lostOfDocument"])
                    this.lostOfDocument!.push(item);
            }
            if (Array.isArray(_data["borrowOfDocument"])) {
                this.borrowOfDocument = [] as any;
                for (let item of _data["borrowOfDocument"])
                    this.borrowOfDocument!.push(item);
            }
            if (Array.isArray(_data["brokenOfDocument"])) {
                this.brokenOfDocument = [] as any;
                for (let item of _data["brokenOfDocument"])
                    this.brokenOfDocument!.push(item);
            }
            if (Array.isArray(_data["validOfDocument"])) {
                this.validOfDocument = [] as any;
                for (let item of _data["validOfDocument"])
                    this.validOfDocument!.push(item);
            }
            if (Array.isArray(_data["totalDocument"])) {
                this.totalDocument = [] as any;
                for (let item of _data["totalDocument"])
                    this.totalDocument!.push(item);
            }
        }
    }

    static fromJS(data: any): StatisticStatusOfDocumentsWithCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticStatusOfDocumentsWithCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.lostOfDocument)) {
            data["lostOfDocument"] = [];
            for (let item of this.lostOfDocument)
                data["lostOfDocument"].push(item);
        }
        if (Array.isArray(this.borrowOfDocument)) {
            data["borrowOfDocument"] = [];
            for (let item of this.borrowOfDocument)
                data["borrowOfDocument"].push(item);
        }
        if (Array.isArray(this.brokenOfDocument)) {
            data["brokenOfDocument"] = [];
            for (let item of this.brokenOfDocument)
                data["brokenOfDocument"].push(item);
        }
        if (Array.isArray(this.validOfDocument)) {
            data["validOfDocument"] = [];
            for (let item of this.validOfDocument)
                data["validOfDocument"].push(item);
        }
        if (Array.isArray(this.totalDocument)) {
            data["totalDocument"] = [];
            for (let item of this.totalDocument)
                data["totalDocument"].push(item);
        }
        return data;
    }

    clone(): StatisticStatusOfDocumentsWithCategoryDto {
        const json = this.toJSON();
        let result = new StatisticStatusOfDocumentsWithCategoryDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticStatusOfDocumentsWithCategoryDto {
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    lostOfDocument: number[] | undefined;
    borrowOfDocument: number[] | undefined;
    brokenOfDocument: number[] | undefined;
    validOfDocument: number[] | undefined;
    totalDocument: number[] | undefined;
}

export class StatisticStatusOfDocumentsWithCategoryDtoListResultDto implements IStatisticStatusOfDocumentsWithCategoryDtoListResultDto {
    items!: StatisticStatusOfDocumentsWithCategoryDto[] | undefined;

    constructor(data?: IStatisticStatusOfDocumentsWithCategoryDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticStatusOfDocumentsWithCategoryDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticStatusOfDocumentsWithCategoryDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticStatusOfDocumentsWithCategoryDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticStatusOfDocumentsWithCategoryDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticStatusOfDocumentsWithCategoryDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticStatusOfDocumentsWithCategoryDtoListResultDto {
    items: StatisticStatusOfDocumentsWithCategoryDto[] | undefined;
}

export class StatisticStatusOfMembersDto implements IStatisticStatusOfMembersDto {
    key!: string | undefined;
    name!: string | undefined;
    nameDisplay!: string | undefined;
    newMember!: number[] | undefined;
    newMemberCard!: number[] | undefined;
    memberCardExtend!: number[] | undefined;
    memberCardBlock!: number[] | undefined;

    constructor(data?: IStatisticStatusOfMembersDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.name = _data["name"];
            this.nameDisplay = _data["nameDisplay"];
            if (Array.isArray(_data["newMember"])) {
                this.newMember = [] as any;
                for (let item of _data["newMember"])
                    this.newMember!.push(item);
            }
            if (Array.isArray(_data["newMemberCard"])) {
                this.newMemberCard = [] as any;
                for (let item of _data["newMemberCard"])
                    this.newMemberCard!.push(item);
            }
            if (Array.isArray(_data["memberCardExtend"])) {
                this.memberCardExtend = [] as any;
                for (let item of _data["memberCardExtend"])
                    this.memberCardExtend!.push(item);
            }
            if (Array.isArray(_data["memberCardBlock"])) {
                this.memberCardBlock = [] as any;
                for (let item of _data["memberCardBlock"])
                    this.memberCardBlock!.push(item);
            }
        }
    }

    static fromJS(data: any): StatisticStatusOfMembersDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticStatusOfMembersDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["name"] = this.name;
        data["nameDisplay"] = this.nameDisplay;
        if (Array.isArray(this.newMember)) {
            data["newMember"] = [];
            for (let item of this.newMember)
                data["newMember"].push(item);
        }
        if (Array.isArray(this.newMemberCard)) {
            data["newMemberCard"] = [];
            for (let item of this.newMemberCard)
                data["newMemberCard"].push(item);
        }
        if (Array.isArray(this.memberCardExtend)) {
            data["memberCardExtend"] = [];
            for (let item of this.memberCardExtend)
                data["memberCardExtend"].push(item);
        }
        if (Array.isArray(this.memberCardBlock)) {
            data["memberCardBlock"] = [];
            for (let item of this.memberCardBlock)
                data["memberCardBlock"].push(item);
        }
        return data;
    }

    clone(): StatisticStatusOfMembersDto {
        const json = this.toJSON();
        let result = new StatisticStatusOfMembersDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticStatusOfMembersDto {
    key: string | undefined;
    name: string | undefined;
    nameDisplay: string | undefined;
    newMember: number[] | undefined;
    newMemberCard: number[] | undefined;
    memberCardExtend: number[] | undefined;
    memberCardBlock: number[] | undefined;
}

export class StatisticStatusOfMembersDtoListResultDto implements IStatisticStatusOfMembersDtoListResultDto {
    items!: StatisticStatusOfMembersDto[] | undefined;

    constructor(data?: IStatisticStatusOfMembersDtoListResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticStatusOfMembersDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatisticStatusOfMembersDtoListResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticStatusOfMembersDtoListResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }

    clone(): StatisticStatusOfMembersDtoListResultDto {
        const json = this.toJSON();
        let result = new StatisticStatusOfMembersDtoListResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticStatusOfMembersDtoListResultDto {
    items: StatisticStatusOfMembersDto[] | undefined;
}

export class StatisticStorageDto implements IStatisticStorageDto {
    sta_id!: number;
    sta_name!: string | undefined;
    sta_code!: string | undefined;
    sta_content!: string | undefined;
    sta_is_delete!: boolean;
    us_id_created!: number;
    sta_updated_at!: Date;
    sta_created_at!: Date;

    constructor(data?: IStatisticStorageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sta_id = _data["sta_id"];
            this.sta_name = _data["sta_name"];
            this.sta_code = _data["sta_code"];
            this.sta_content = _data["sta_content"];
            this.sta_is_delete = _data["sta_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.sta_updated_at = _data["sta_updated_at"] ? new Date(_data["sta_updated_at"].toString()) : <any>undefined;
            this.sta_created_at = _data["sta_created_at"] ? new Date(_data["sta_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StatisticStorageDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticStorageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sta_id"] = this.sta_id;
        data["sta_name"] = this.sta_name;
        data["sta_code"] = this.sta_code;
        data["sta_content"] = this.sta_content;
        data["sta_is_delete"] = this.sta_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["sta_updated_at"] = this.sta_updated_at ? this.sta_updated_at.toISOString() : <any>undefined;
        data["sta_created_at"] = this.sta_created_at ? this.sta_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): StatisticStorageDto {
        const json = this.toJSON();
        let result = new StatisticStorageDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticStorageDto {
    sta_id: number;
    sta_name: string | undefined;
    sta_code: string | undefined;
    sta_content: string | undefined;
    sta_is_delete: boolean;
    us_id_created: number;
    sta_updated_at: Date;
    sta_created_at: Date;
}

export class StatisticStorageDtoPagedResultDto implements IStatisticStorageDtoPagedResultDto {
    items!: StatisticStorageDto[] | undefined;
    totalCount!: number;

    constructor(data?: IStatisticStorageDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(StatisticStorageDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): StatisticStorageDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatisticStorageDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): StatisticStorageDtoPagedResultDto {
        const json = this.toJSON();
        let result = new StatisticStorageDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatisticStorageDtoPagedResultDto {
    items: StatisticStorageDto[] | undefined;
    totalCount: number;
}

export enum StatisticStorageStatus {
    _0 = 0,
    _5 = 5,
    _10 = 10,
    _15 = 15,
}

export enum StatusPublishRegister {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class SubFieldMarc21Dto implements ISubFieldMarc21Dto {
    sub_id!: number;
    mar_id!: number;
    sub_code!: string | undefined;
    sub_desc!: string | undefined;
    sub_is_delete!: boolean;
    marc21!: Marc21Dto;
    sub_created_at!: Date;
    sub_updated_at!: Date;

    constructor(data?: ISubFieldMarc21Dto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sub_id = _data["sub_id"];
            this.mar_id = _data["mar_id"];
            this.sub_code = _data["sub_code"];
            this.sub_desc = _data["sub_desc"];
            this.sub_is_delete = _data["sub_is_delete"];
            this.marc21 = _data["marc21"] ? Marc21Dto.fromJS(_data["marc21"]) : <any>undefined;
            this.sub_created_at = _data["sub_created_at"] ? new Date(_data["sub_created_at"].toString()) : <any>undefined;
            this.sub_updated_at = _data["sub_updated_at"] ? new Date(_data["sub_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SubFieldMarc21Dto {
        data = typeof data === 'object' ? data : {};
        let result = new SubFieldMarc21Dto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sub_id"] = this.sub_id;
        data["mar_id"] = this.mar_id;
        data["sub_code"] = this.sub_code;
        data["sub_desc"] = this.sub_desc;
        data["sub_is_delete"] = this.sub_is_delete;
        data["marc21"] = this.marc21 ? this.marc21.toJSON() : <any>undefined;
        data["sub_created_at"] = this.sub_created_at ? this.sub_created_at.toISOString() : <any>undefined;
        data["sub_updated_at"] = this.sub_updated_at ? this.sub_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): SubFieldMarc21Dto {
        const json = this.toJSON();
        let result = new SubFieldMarc21Dto();
        result.init(json);
        return result;
    }
}

export interface ISubFieldMarc21Dto {
    sub_id: number;
    mar_id: number;
    sub_code: string | undefined;
    sub_desc: string | undefined;
    sub_is_delete: boolean;
    marc21: Marc21Dto;
    sub_created_at: Date;
    sub_updated_at: Date;
}

export class SubFieldMarc21DtoPagedResultDto implements ISubFieldMarc21DtoPagedResultDto {
    items!: SubFieldMarc21Dto[] | undefined;
    totalCount!: number;

    constructor(data?: ISubFieldMarc21DtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubFieldMarc21Dto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SubFieldMarc21DtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubFieldMarc21DtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): SubFieldMarc21DtoPagedResultDto {
        const json = this.toJSON();
        let result = new SubFieldMarc21DtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISubFieldMarc21DtoPagedResultDto {
    items: SubFieldMarc21Dto[] | undefined;
    totalCount: number;
}

export class SupplierAbtractDto implements ISupplierAbtractDto {
    su_id!: number;
    su_short_name!: string | undefined;
    su_name!: string | undefined;
    su_is_delete!: boolean;

    constructor(data?: ISupplierAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.su_short_name = _data["su_short_name"];
            this.su_name = _data["su_name"];
            this.su_is_delete = _data["su_is_delete"];
        }
    }

    static fromJS(data: any): SupplierAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["su_short_name"] = this.su_short_name;
        data["su_name"] = this.su_name;
        data["su_is_delete"] = this.su_is_delete;
        return data;
    }

    clone(): SupplierAbtractDto {
        const json = this.toJSON();
        let result = new SupplierAbtractDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierAbtractDto {
    su_id: number;
    su_short_name: string | undefined;
    su_name: string | undefined;
    su_is_delete: boolean;
}

export class SupplierDto implements ISupplierDto {
    su_id!: number;
    su_short_name!: string | undefined;
    su_name!: string | undefined;
    su_contact_name!: string | undefined;
    su_contact_possition!: string | undefined;
    su_contact_address!: string | undefined;
    su_contact_phone!: string | undefined;
    su_contact_fax!: string | undefined;
    su_contact_email!: string | undefined;
    su_contact_note!: string | undefined;
    su_tax_code!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;
    su_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    su_created_at!: Date;
    su_updated_at!: Date;

    constructor(data?: ISupplierDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.su_short_name = _data["su_short_name"];
            this.su_name = _data["su_name"];
            this.su_contact_name = _data["su_contact_name"];
            this.su_contact_possition = _data["su_contact_possition"];
            this.su_contact_address = _data["su_contact_address"];
            this.su_contact_phone = _data["su_contact_phone"];
            this.su_contact_fax = _data["su_contact_fax"];
            this.su_contact_email = _data["su_contact_email"];
            this.su_contact_note = _data["su_contact_note"];
            this.su_tax_code = _data["su_tax_code"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.su_is_delete = _data["su_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.su_created_at = _data["su_created_at"] ? new Date(_data["su_created_at"].toString()) : <any>undefined;
            this.su_updated_at = _data["su_updated_at"] ? new Date(_data["su_updated_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["su_short_name"] = this.su_short_name;
        data["su_name"] = this.su_name;
        data["su_contact_name"] = this.su_contact_name;
        data["su_contact_possition"] = this.su_contact_possition;
        data["su_contact_address"] = this.su_contact_address;
        data["su_contact_phone"] = this.su_contact_phone;
        data["su_contact_fax"] = this.su_contact_fax;
        data["su_contact_email"] = this.su_contact_email;
        data["su_contact_note"] = this.su_contact_note;
        data["su_tax_code"] = this.su_tax_code;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["su_is_delete"] = this.su_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["su_created_at"] = this.su_created_at ? this.su_created_at.toISOString() : <any>undefined;
        data["su_updated_at"] = this.su_updated_at ? this.su_updated_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): SupplierDto {
        const json = this.toJSON();
        let result = new SupplierDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierDto {
    su_id: number;
    su_short_name: string | undefined;
    su_name: string | undefined;
    su_contact_name: string | undefined;
    su_contact_possition: string | undefined;
    su_contact_address: string | undefined;
    su_contact_phone: string | undefined;
    su_contact_fax: string | undefined;
    su_contact_email: string | undefined;
    su_contact_note: string | undefined;
    su_tax_code: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
    su_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    su_created_at: Date;
    su_updated_at: Date;
}

export class SupplierDtoPagedResultDto implements ISupplierDtoPagedResultDto {
    items!: SupplierDto[] | undefined;
    totalCount!: number;

    constructor(data?: ISupplierDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SupplierDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): SupplierDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): SupplierDtoPagedResultDto {
        const json = this.toJSON();
        let result = new SupplierDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ISupplierDtoPagedResultDto {
    items: SupplierDto[] | undefined;
    totalCount: number;
}

export enum TenantAvailabilityState {
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class TenantDto implements ITenantDto {
    id!: number;
    tenancyName!: string;
    name!: string;
    isActive!: boolean;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        return data;
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    id: number;
    tenancyName: string;
    name: string;
    isActive: boolean;
}

export class TenantDtoPagedResultDto implements ITenantDtoPagedResultDto {
    items!: TenantDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITenantDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TenantDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TenantDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TenantDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDtoPagedResultDto {
    items: TenantDto[] | undefined;
    totalCount: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    id!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        return data;
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    id: number;
    tenancyName: string | undefined;
    name: string | undefined;
}

export class TopicAbtractDto implements ITopicAbtractDto {
    to_id!: number;
    to_name!: string | undefined;
    to_code!: string | undefined;
    to_is_active!: boolean;

    constructor(data?: ITopicAbtractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.to_id = _data["to_id"];
            this.to_name = _data["to_name"];
            this.to_code = _data["to_code"];
            this.to_is_active = _data["to_is_active"];
        }
    }

    static fromJS(data: any): TopicAbtractDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopicAbtractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["to_id"] = this.to_id;
        data["to_name"] = this.to_name;
        data["to_code"] = this.to_code;
        data["to_is_active"] = this.to_is_active;
        return data;
    }

    clone(): TopicAbtractDto {
        const json = this.toJSON();
        let result = new TopicAbtractDto();
        result.init(json);
        return result;
    }
}

export interface ITopicAbtractDto {
    to_id: number;
    to_name: string | undefined;
    to_code: string | undefined;
    to_is_active: boolean;
}

export class TopicDto implements ITopicDto {
    to_id!: number;
    to_name!: string | undefined;
    to_code!: string | undefined;
    to_desc!: string | undefined;
    to_is_active!: boolean;
    to_is_delete!: boolean;
    us_id_created!: number;
    us_id_updated!: number;
    us_id_delete!: number;
    to_updated_at!: Date;
    to_created_at!: Date;

    constructor(data?: ITopicDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.to_id = _data["to_id"];
            this.to_name = _data["to_name"];
            this.to_code = _data["to_code"];
            this.to_desc = _data["to_desc"];
            this.to_is_active = _data["to_is_active"];
            this.to_is_delete = _data["to_is_delete"];
            this.us_id_created = _data["us_id_created"];
            this.us_id_updated = _data["us_id_updated"];
            this.us_id_delete = _data["us_id_delete"];
            this.to_updated_at = _data["to_updated_at"] ? new Date(_data["to_updated_at"].toString()) : <any>undefined;
            this.to_created_at = _data["to_created_at"] ? new Date(_data["to_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TopicDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopicDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["to_id"] = this.to_id;
        data["to_name"] = this.to_name;
        data["to_code"] = this.to_code;
        data["to_desc"] = this.to_desc;
        data["to_is_active"] = this.to_is_active;
        data["to_is_delete"] = this.to_is_delete;
        data["us_id_created"] = this.us_id_created;
        data["us_id_updated"] = this.us_id_updated;
        data["us_id_delete"] = this.us_id_delete;
        data["to_updated_at"] = this.to_updated_at ? this.to_updated_at.toISOString() : <any>undefined;
        data["to_created_at"] = this.to_created_at ? this.to_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): TopicDto {
        const json = this.toJSON();
        let result = new TopicDto();
        result.init(json);
        return result;
    }
}

export interface ITopicDto {
    to_id: number;
    to_name: string | undefined;
    to_code: string | undefined;
    to_desc: string | undefined;
    to_is_active: boolean;
    to_is_delete: boolean;
    us_id_created: number;
    us_id_updated: number;
    us_id_delete: number;
    to_updated_at: Date;
    to_created_at: Date;
}

export class TopicDtoPagedResultDto implements ITopicDtoPagedResultDto {
    items!: TopicDto[] | undefined;
    totalCount!: number;

    constructor(data?: ITopicDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TopicDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): TopicDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new TopicDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): TopicDtoPagedResultDto {
        const json = this.toJSON();
        let result = new TopicDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface ITopicDtoPagedResultDto {
    items: TopicDto[] | undefined;
    totalCount: number;
}

export enum TypeFileFolder {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export enum TypePublishRegister {
    _0 = 0,
    _1 = 1,
}

export class UpdateApplicationExtInput implements IUpdateApplicationExtInput {
    ap_id!: number;
    ap_code!: string | undefined;
    ap_secret!: string | undefined;
    ap_callback_url!: string | undefined;
    ap_trust!: boolean;
    ap_confidential!: boolean;

    constructor(data?: IUpdateApplicationExtInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ap_id = _data["ap_id"];
            this.ap_code = _data["ap_code"];
            this.ap_secret = _data["ap_secret"];
            this.ap_callback_url = _data["ap_callback_url"];
            this.ap_trust = _data["ap_trust"];
            this.ap_confidential = _data["ap_confidential"];
        }
    }

    static fromJS(data: any): UpdateApplicationExtInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationExtInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ap_id"] = this.ap_id;
        data["ap_code"] = this.ap_code;
        data["ap_secret"] = this.ap_secret;
        data["ap_callback_url"] = this.ap_callback_url;
        data["ap_trust"] = this.ap_trust;
        data["ap_confidential"] = this.ap_confidential;
        return data;
    }

    clone(): UpdateApplicationExtInput {
        const json = this.toJSON();
        let result = new UpdateApplicationExtInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateApplicationExtInput {
    ap_id: number;
    ap_code: string | undefined;
    ap_secret: string | undefined;
    ap_callback_url: string | undefined;
    ap_trust: boolean;
    ap_confidential: boolean;
}

export class UpdateAuthorInput implements IUpdateAuthorInput {
    au_id!: number;
    au_name!: string | undefined;
    au_dob!: string | undefined;
    au_address!: string | undefined;
    au_decs!: string | undefined;
    au_email!: string | undefined;
    au_academic_rank!: string | undefined;
    au_degree!: string | undefined;
    au_pen_name!: string | undefined;
    au_infor!: string | undefined;
    fi_id!: AttachmentItem;

    constructor(data?: IUpdateAuthorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.au_id = _data["au_id"];
            this.au_name = _data["au_name"];
            this.au_dob = _data["au_dob"];
            this.au_address = _data["au_address"];
            this.au_decs = _data["au_decs"];
            this.au_email = _data["au_email"];
            this.au_academic_rank = _data["au_academic_rank"];
            this.au_degree = _data["au_degree"];
            this.au_pen_name = _data["au_pen_name"];
            this.au_infor = _data["au_infor"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateAuthorInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAuthorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["au_id"] = this.au_id;
        data["au_name"] = this.au_name;
        data["au_dob"] = this.au_dob;
        data["au_address"] = this.au_address;
        data["au_decs"] = this.au_decs;
        data["au_email"] = this.au_email;
        data["au_academic_rank"] = this.au_academic_rank;
        data["au_degree"] = this.au_degree;
        data["au_pen_name"] = this.au_pen_name;
        data["au_infor"] = this.au_infor;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateAuthorInput {
        const json = this.toJSON();
        let result = new UpdateAuthorInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateAuthorInput {
    au_id: number;
    au_name: string | undefined;
    au_dob: string | undefined;
    au_address: string | undefined;
    au_decs: string | undefined;
    au_email: string | undefined;
    au_academic_rank: string | undefined;
    au_degree: string | undefined;
    au_pen_name: string | undefined;
    au_infor: string | undefined;
    fi_id: AttachmentItem;
}

export class UpdateAvataInput implements IUpdateAvataInput {
    id!: number;
    us_avatar!: number;

    constructor(data?: IUpdateAvataInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.us_avatar = _data["us_avatar"];
        }
    }

    static fromJS(data: any): UpdateAvataInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAvataInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["us_avatar"] = this.us_avatar;
        return data;
    }

    clone(): UpdateAvataInput {
        const json = this.toJSON();
        let result = new UpdateAvataInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateAvataInput {
    id: number;
    us_avatar: number;
}

export class UpdateBillingInput implements IUpdateBillingInput {
    bi_id!: number;
    bi_code!: string | undefined;
    bi_desc!: string | undefined;
    bi_note!: string | undefined;
    bi_export!: Date;
    bi_status!: BillStatus;
    supplier!: ItemSupplier;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: IUpdateBillingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_id = _data["bi_id"];
            this.bi_code = _data["bi_code"];
            this.bi_desc = _data["bi_desc"];
            this.bi_note = _data["bi_note"];
            this.bi_export = _data["bi_export"] ? new Date(_data["bi_export"].toString()) : <any>undefined;
            this.bi_status = _data["bi_status"];
            this.supplier = _data["supplier"] ? ItemSupplier.fromJS(_data["supplier"]) : <any>undefined;
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateBillingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBillingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_id"] = this.bi_id;
        data["bi_code"] = this.bi_code;
        data["bi_desc"] = this.bi_desc;
        data["bi_note"] = this.bi_note;
        data["bi_export"] = this.bi_export ? this.bi_export.toISOString() : <any>undefined;
        data["bi_status"] = this.bi_status;
        data["supplier"] = this.supplier ? this.supplier.toJSON() : <any>undefined;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateBillingInput {
        const json = this.toJSON();
        let result = new UpdateBillingInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateBillingInput {
    bi_id: number;
    bi_code: string | undefined;
    bi_desc: string | undefined;
    bi_note: string | undefined;
    bi_export: Date;
    bi_status: BillStatus;
    supplier: ItemSupplier;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class UpdateBillingItemInput implements IUpdateBillingItemInput {
    bi_it_id!: number;
    bi_it_name!: string | undefined;
    bi_it_cost!: number;
    bi_it_amount!: number;
    bi_it_unit!: string | undefined;

    constructor(data?: IUpdateBillingItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_it_id = _data["bi_it_id"];
            this.bi_it_name = _data["bi_it_name"];
            this.bi_it_cost = _data["bi_it_cost"];
            this.bi_it_amount = _data["bi_it_amount"];
            this.bi_it_unit = _data["bi_it_unit"];
        }
    }

    static fromJS(data: any): UpdateBillingItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBillingItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_it_id"] = this.bi_it_id;
        data["bi_it_name"] = this.bi_it_name;
        data["bi_it_cost"] = this.bi_it_cost;
        data["bi_it_amount"] = this.bi_it_amount;
        data["bi_it_unit"] = this.bi_it_unit;
        return data;
    }

    clone(): UpdateBillingItemInput {
        const json = this.toJSON();
        let result = new UpdateBillingItemInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateBillingItemInput {
    bi_it_id: number;
    bi_it_name: string | undefined;
    bi_it_cost: number;
    bi_it_amount: number;
    bi_it_unit: string | undefined;
}

export class UpdateBorrowReturningInput implements IUpdateBorrowReturningInput {
    br_re_id!: number;
    br_re_desc!: string | undefined;
    br_re_start_at!: Date | undefined;
    br_re_end_at!: Date | undefined;
    br_re_method!: BorrowMethod;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: IUpdateBorrowReturningInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.br_re_id = _data["br_re_id"];
            this.br_re_desc = _data["br_re_desc"];
            this.br_re_start_at = _data["br_re_start_at"] ? new Date(_data["br_re_start_at"].toString()) : <any>undefined;
            this.br_re_end_at = _data["br_re_end_at"] ? new Date(_data["br_re_end_at"].toString()) : <any>undefined;
            this.br_re_method = _data["br_re_method"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateBorrowReturningInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBorrowReturningInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["br_re_id"] = this.br_re_id;
        data["br_re_desc"] = this.br_re_desc;
        data["br_re_start_at"] = this.br_re_start_at ? this.br_re_start_at.toISOString() : <any>undefined;
        data["br_re_end_at"] = this.br_re_end_at ? this.br_re_end_at.toISOString() : <any>undefined;
        data["br_re_method"] = this.br_re_method;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateBorrowReturningInput {
        const json = this.toJSON();
        let result = new UpdateBorrowReturningInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateBorrowReturningInput {
    br_re_id: number;
    br_re_desc: string | undefined;
    br_re_start_at: Date | undefined;
    br_re_end_at: Date | undefined;
    br_re_method: BorrowMethod;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class UpdateCatalogingInput implements IUpdateCatalogingInput {
    cata_id!: number;
    cata_content!: string | undefined;
    cata_resultDDC!: string | undefined;
    cata_resultTitle!: string | undefined;
    cata_resultColor!: string | undefined;

    constructor(data?: IUpdateCatalogingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cata_id = _data["cata_id"];
            this.cata_content = _data["cata_content"];
            this.cata_resultDDC = _data["cata_resultDDC"];
            this.cata_resultTitle = _data["cata_resultTitle"];
            this.cata_resultColor = _data["cata_resultColor"];
        }
    }

    static fromJS(data: any): UpdateCatalogingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCatalogingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cata_id"] = this.cata_id;
        data["cata_content"] = this.cata_content;
        data["cata_resultDDC"] = this.cata_resultDDC;
        data["cata_resultTitle"] = this.cata_resultTitle;
        data["cata_resultColor"] = this.cata_resultColor;
        return data;
    }

    clone(): UpdateCatalogingInput {
        const json = this.toJSON();
        let result = new UpdateCatalogingInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateCatalogingInput {
    cata_id: number;
    cata_content: string | undefined;
    cata_resultDDC: string | undefined;
    cata_resultTitle: string | undefined;
    cata_resultColor: string | undefined;
}

export class UpdateCategoryInput implements IUpdateCategoryInput {
    ca_id!: number;
    ca_title!: string | undefined;
    dkcb_code!: string | undefined;
    dkcb_start!: number;
    ca_abstract!: string | undefined;
    ca_id_parent!: number;
    ca_enable!: boolean;

    constructor(data?: IUpdateCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ca_id = _data["ca_id"];
            this.ca_title = _data["ca_title"];
            this.dkcb_code = _data["dkcb_code"];
            this.dkcb_start = _data["dkcb_start"];
            this.ca_abstract = _data["ca_abstract"];
            this.ca_id_parent = _data["ca_id_parent"];
            this.ca_enable = _data["ca_enable"];
        }
    }

    static fromJS(data: any): UpdateCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ca_id"] = this.ca_id;
        data["ca_title"] = this.ca_title;
        data["dkcb_code"] = this.dkcb_code;
        data["dkcb_start"] = this.dkcb_start;
        data["ca_abstract"] = this.ca_abstract;
        data["ca_id_parent"] = this.ca_id_parent;
        data["ca_enable"] = this.ca_enable;
        return data;
    }

    clone(): UpdateCategoryInput {
        const json = this.toJSON();
        let result = new UpdateCategoryInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateCategoryInput {
    ca_id: number;
    ca_title: string | undefined;
    dkcb_code: string | undefined;
    dkcb_start: number;
    ca_abstract: string | undefined;
    ca_id_parent: number;
    ca_enable: boolean;
}

export class UpdateCheckInput implements IUpdateCheckInput {
    ck_id!: number;
    ck_name!: string | undefined;
    ck_desc!: string | undefined;
    ck_start_at!: Date;
    us_id_created!: number;
    us_id_participant!: ItemUser[] | undefined;
    us_id_approved!: number;
    ck_note!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: IUpdateCheckInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ck_id = _data["ck_id"];
            this.ck_name = _data["ck_name"];
            this.ck_desc = _data["ck_desc"];
            this.ck_start_at = _data["ck_start_at"] ? new Date(_data["ck_start_at"].toString()) : <any>undefined;
            this.us_id_created = _data["us_id_created"];
            if (Array.isArray(_data["us_id_participant"])) {
                this.us_id_participant = [] as any;
                for (let item of _data["us_id_participant"])
                    this.us_id_participant!.push(ItemUser.fromJS(item));
            }
            this.us_id_approved = _data["us_id_approved"];
            this.ck_note = _data["ck_note"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateCheckInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCheckInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ck_id"] = this.ck_id;
        data["ck_name"] = this.ck_name;
        data["ck_desc"] = this.ck_desc;
        data["ck_start_at"] = this.ck_start_at ? this.ck_start_at.toISOString() : <any>undefined;
        data["us_id_created"] = this.us_id_created;
        if (Array.isArray(this.us_id_participant)) {
            data["us_id_participant"] = [];
            for (let item of this.us_id_participant)
                data["us_id_participant"].push(item.toJSON());
        }
        data["us_id_approved"] = this.us_id_approved;
        data["ck_note"] = this.ck_note;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateCheckInput {
        const json = this.toJSON();
        let result = new UpdateCheckInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateCheckInput {
    ck_id: number;
    ck_name: string | undefined;
    ck_desc: string | undefined;
    ck_start_at: Date;
    us_id_created: number;
    us_id_participant: ItemUser[] | undefined;
    us_id_approved: number;
    ck_note: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class UpdateCheckItemInput implements IUpdateCheckItemInput {
    ck_it_id!: number;
    ck_id!: number;
    do_id!: ItemDocument;
    ck_it_status!: CheckItemStatus;
    ck_it_note!: string | undefined;

    constructor(data?: IUpdateCheckItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ck_it_id = _data["ck_it_id"];
            this.ck_id = _data["ck_id"];
            this.do_id = _data["do_id"] ? ItemDocument.fromJS(_data["do_id"]) : <any>undefined;
            this.ck_it_status = _data["ck_it_status"];
            this.ck_it_note = _data["ck_it_note"];
        }
    }

    static fromJS(data: any): UpdateCheckItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCheckItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ck_it_id"] = this.ck_it_id;
        data["ck_id"] = this.ck_id;
        data["do_id"] = this.do_id ? this.do_id.toJSON() : <any>undefined;
        data["ck_it_status"] = this.ck_it_status;
        data["ck_it_note"] = this.ck_it_note;
        return data;
    }

    clone(): UpdateCheckItemInput {
        const json = this.toJSON();
        let result = new UpdateCheckItemInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateCheckItemInput {
    ck_it_id: number;
    ck_id: number;
    do_id: ItemDocument;
    ck_it_status: CheckItemStatus;
    ck_it_note: string | undefined;
}

export class UpdateContractInput implements IUpdateContractInput {
    co_id!: number;
    co_name!: string | undefined;
    co_desc!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;
    pl_id!: number;
    us_id_accept!: number;
    co_signed_at!: Date;
    su_id!: number;

    constructor(data?: IUpdateContractInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.co_id = _data["co_id"];
            this.co_name = _data["co_name"];
            this.co_desc = _data["co_desc"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
            this.pl_id = _data["pl_id"];
            this.us_id_accept = _data["us_id_accept"];
            this.co_signed_at = _data["co_signed_at"] ? new Date(_data["co_signed_at"].toString()) : <any>undefined;
            this.su_id = _data["su_id"];
        }
    }

    static fromJS(data: any): UpdateContractInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateContractInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["co_id"] = this.co_id;
        data["co_name"] = this.co_name;
        data["co_desc"] = this.co_desc;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        data["pl_id"] = this.pl_id;
        data["us_id_accept"] = this.us_id_accept;
        data["co_signed_at"] = this.co_signed_at ? this.co_signed_at.toISOString() : <any>undefined;
        data["su_id"] = this.su_id;
        return data;
    }

    clone(): UpdateContractInput {
        const json = this.toJSON();
        let result = new UpdateContractInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateContractInput {
    co_id: number;
    co_name: string | undefined;
    co_desc: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
    pl_id: number;
    us_id_accept: number;
    co_signed_at: Date;
    su_id: number;
}

export class UpdateDictionariesInput implements IUpdateDictionariesInput {
    dic_id!: number;
    dic_ty_id!: number;
    dic_name!: string | undefined;
    dic_short_des!: string | undefined;
    dic_desc!: string | undefined;
    fi_id_symbol!: AttachmentItem;
    dic_ref!: string | undefined;

    constructor(data?: IUpdateDictionariesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dic_id = _data["dic_id"];
            this.dic_ty_id = _data["dic_ty_id"];
            this.dic_name = _data["dic_name"];
            this.dic_short_des = _data["dic_short_des"];
            this.dic_desc = _data["dic_desc"];
            this.fi_id_symbol = _data["fi_id_symbol"] ? AttachmentItem.fromJS(_data["fi_id_symbol"]) : <any>undefined;
            this.dic_ref = _data["dic_ref"];
        }
    }

    static fromJS(data: any): UpdateDictionariesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDictionariesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dic_id"] = this.dic_id;
        data["dic_ty_id"] = this.dic_ty_id;
        data["dic_name"] = this.dic_name;
        data["dic_short_des"] = this.dic_short_des;
        data["dic_desc"] = this.dic_desc;
        data["fi_id_symbol"] = this.fi_id_symbol ? this.fi_id_symbol.toJSON() : <any>undefined;
        data["dic_ref"] = this.dic_ref;
        return data;
    }

    clone(): UpdateDictionariesInput {
        const json = this.toJSON();
        let result = new UpdateDictionariesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateDictionariesInput {
    dic_id: number;
    dic_ty_id: number;
    dic_name: string | undefined;
    dic_short_des: string | undefined;
    dic_desc: string | undefined;
    fi_id_symbol: AttachmentItem;
    dic_ref: string | undefined;
}

export class UpdateDictionaryTypeInput implements IUpdateDictionaryTypeInput {
    dic_ty_id!: number;
    dic_ty_name!: string | undefined;
    dic_ty_desc!: string | undefined;
    dic_ty_is_active!: boolean;

    constructor(data?: IUpdateDictionaryTypeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dic_ty_id = _data["dic_ty_id"];
            this.dic_ty_name = _data["dic_ty_name"];
            this.dic_ty_desc = _data["dic_ty_desc"];
            this.dic_ty_is_active = _data["dic_ty_is_active"];
        }
    }

    static fromJS(data: any): UpdateDictionaryTypeInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDictionaryTypeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dic_ty_id"] = this.dic_ty_id;
        data["dic_ty_name"] = this.dic_ty_name;
        data["dic_ty_desc"] = this.dic_ty_desc;
        data["dic_ty_is_active"] = this.dic_ty_is_active;
        return data;
    }

    clone(): UpdateDictionaryTypeInput {
        const json = this.toJSON();
        let result = new UpdateDictionaryTypeInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateDictionaryTypeInput {
    dic_ty_id: number;
    dic_ty_name: string | undefined;
    dic_ty_desc: string | undefined;
    dic_ty_is_active: boolean;
}

export class UpdateDocumentInforInput implements IUpdateDocumentInforInput {
    do_in_id!: number;
    do_in_isbn!: string | undefined;
    do_in_note!: string | undefined;

    constructor(data?: IUpdateDocumentInforInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_in_id = _data["do_in_id"];
            this.do_in_isbn = _data["do_in_isbn"];
            this.do_in_note = _data["do_in_note"];
        }
    }

    static fromJS(data: any): UpdateDocumentInforInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentInforInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_in_id"] = this.do_in_id;
        data["do_in_isbn"] = this.do_in_isbn;
        data["do_in_note"] = this.do_in_note;
        return data;
    }

    clone(): UpdateDocumentInforInput {
        const json = this.toJSON();
        let result = new UpdateDocumentInforInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateDocumentInforInput {
    do_in_id: number;
    do_in_isbn: string | undefined;
    do_in_note: string | undefined;
}

export class UpdateDocumentInput implements IUpdateDocumentInput {
    do_id!: number;
    do_title!: string | undefined;
    do_date_publish!: string | undefined;
    do_republish!: number;
    do_identifier!: string | undefined;
    do_translator!: string | undefined;
    do_identifier_citation!: string | undefined;
    do_abstract!: string | undefined;
    do_period_check!: number;
    do_date_available!: Date;
    do_nr_pages!: number;
    do_language_iso!: ItemLanguages[] | undefined;
    fie_id_arr!: ItemField[] | undefined;
    fi_id_arr_cover!: AttachmentItem[] | undefined;
    au_id_arr!: ItemAuthor[] | undefined;
    pu_id!: ItemPublisher;
    to_id!: number;
    ca_id!: number;
    do_borrow_status!: DocumentBorrowType;
    do_price!: number;

    constructor(data?: IUpdateDocumentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.do_id = _data["do_id"];
            this.do_title = _data["do_title"];
            this.do_date_publish = _data["do_date_publish"];
            this.do_republish = _data["do_republish"];
            this.do_identifier = _data["do_identifier"];
            this.do_translator = _data["do_translator"];
            this.do_identifier_citation = _data["do_identifier_citation"];
            this.do_abstract = _data["do_abstract"];
            this.do_period_check = _data["do_period_check"];
            this.do_date_available = _data["do_date_available"] ? new Date(_data["do_date_available"].toString()) : <any>undefined;
            this.do_nr_pages = _data["do_nr_pages"];
            if (Array.isArray(_data["do_language_iso"])) {
                this.do_language_iso = [] as any;
                for (let item of _data["do_language_iso"])
                    this.do_language_iso!.push(ItemLanguages.fromJS(item));
            }
            if (Array.isArray(_data["fie_id_arr"])) {
                this.fie_id_arr = [] as any;
                for (let item of _data["fie_id_arr"])
                    this.fie_id_arr!.push(ItemField.fromJS(item));
            }
            if (Array.isArray(_data["fi_id_arr_cover"])) {
                this.fi_id_arr_cover = [] as any;
                for (let item of _data["fi_id_arr_cover"])
                    this.fi_id_arr_cover!.push(AttachmentItem.fromJS(item));
            }
            if (Array.isArray(_data["au_id_arr"])) {
                this.au_id_arr = [] as any;
                for (let item of _data["au_id_arr"])
                    this.au_id_arr!.push(ItemAuthor.fromJS(item));
            }
            this.pu_id = _data["pu_id"] ? ItemPublisher.fromJS(_data["pu_id"]) : <any>undefined;
            this.to_id = _data["to_id"];
            this.ca_id = _data["ca_id"];
            this.do_borrow_status = _data["do_borrow_status"];
            this.do_price = _data["do_price"];
        }
    }

    static fromJS(data: any): UpdateDocumentInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDocumentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["do_id"] = this.do_id;
        data["do_title"] = this.do_title;
        data["do_date_publish"] = this.do_date_publish;
        data["do_republish"] = this.do_republish;
        data["do_identifier"] = this.do_identifier;
        data["do_translator"] = this.do_translator;
        data["do_identifier_citation"] = this.do_identifier_citation;
        data["do_abstract"] = this.do_abstract;
        data["do_period_check"] = this.do_period_check;
        data["do_date_available"] = this.do_date_available ? this.do_date_available.toISOString() : <any>undefined;
        data["do_nr_pages"] = this.do_nr_pages;
        if (Array.isArray(this.do_language_iso)) {
            data["do_language_iso"] = [];
            for (let item of this.do_language_iso)
                data["do_language_iso"].push(item.toJSON());
        }
        if (Array.isArray(this.fie_id_arr)) {
            data["fie_id_arr"] = [];
            for (let item of this.fie_id_arr)
                data["fie_id_arr"].push(item.toJSON());
        }
        if (Array.isArray(this.fi_id_arr_cover)) {
            data["fi_id_arr_cover"] = [];
            for (let item of this.fi_id_arr_cover)
                data["fi_id_arr_cover"].push(item.toJSON());
        }
        if (Array.isArray(this.au_id_arr)) {
            data["au_id_arr"] = [];
            for (let item of this.au_id_arr)
                data["au_id_arr"].push(item.toJSON());
        }
        data["pu_id"] = this.pu_id ? this.pu_id.toJSON() : <any>undefined;
        data["to_id"] = this.to_id;
        data["ca_id"] = this.ca_id;
        data["do_borrow_status"] = this.do_borrow_status;
        data["do_price"] = this.do_price;
        return data;
    }

    clone(): UpdateDocumentInput {
        const json = this.toJSON();
        let result = new UpdateDocumentInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateDocumentInput {
    do_id: number;
    do_title: string | undefined;
    do_date_publish: string | undefined;
    do_republish: number;
    do_identifier: string | undefined;
    do_translator: string | undefined;
    do_identifier_citation: string | undefined;
    do_abstract: string | undefined;
    do_period_check: number;
    do_date_available: Date;
    do_nr_pages: number;
    do_language_iso: ItemLanguages[] | undefined;
    fie_id_arr: ItemField[] | undefined;
    fi_id_arr_cover: AttachmentItem[] | undefined;
    au_id_arr: ItemAuthor[] | undefined;
    pu_id: ItemPublisher;
    to_id: number;
    ca_id: number;
    do_borrow_status: DocumentBorrowType;
    do_price: number;
}

export class UpdateFieldsInput implements IUpdateFieldsInput {
    fie_id!: number;
    fie_name!: string | undefined;
    fie_desc!: string | undefined;

    constructor(data?: IUpdateFieldsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fie_id = _data["fie_id"];
            this.fie_name = _data["fie_name"];
            this.fie_desc = _data["fie_desc"];
        }
    }

    static fromJS(data: any): UpdateFieldsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFieldsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fie_id"] = this.fie_id;
        data["fie_name"] = this.fie_name;
        data["fie_desc"] = this.fie_desc;
        return data;
    }

    clone(): UpdateFieldsInput {
        const json = this.toJSON();
        let result = new UpdateFieldsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateFieldsInput {
    fie_id: number;
    fie_name: string | undefined;
    fie_desc: string | undefined;
}

export class UpdateFilesOfUserInput implements IUpdateFilesOfUserInput {
    fi_us_id!: number;
    fi_us_name!: string | undefined;
    fi_us_decs!: string | undefined;

    constructor(data?: IUpdateFilesOfUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_us_id = _data["fi_us_id"];
            this.fi_us_name = _data["fi_us_name"];
            this.fi_us_decs = _data["fi_us_decs"];
        }
    }

    static fromJS(data: any): UpdateFilesOfUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFilesOfUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_us_id"] = this.fi_us_id;
        data["fi_us_name"] = this.fi_us_name;
        data["fi_us_decs"] = this.fi_us_decs;
        return data;
    }

    clone(): UpdateFilesOfUserInput {
        const json = this.toJSON();
        let result = new UpdateFilesOfUserInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateFilesOfUserInput {
    fi_us_id: number;
    fi_us_name: string | undefined;
    fi_us_decs: string | undefined;
}

export class UpdateFilesOfUserRolesInput implements IUpdateFilesOfUserRolesInput {
    fi_ro_id!: number;
    fi_us_id!: number;
    fi_ro_role!: ResourceRoleStatus;

    constructor(data?: IUpdateFilesOfUserRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_ro_id = _data["fi_ro_id"];
            this.fi_us_id = _data["fi_us_id"];
            this.fi_ro_role = _data["fi_ro_role"];
        }
    }

    static fromJS(data: any): UpdateFilesOfUserRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFilesOfUserRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_ro_id"] = this.fi_ro_id;
        data["fi_us_id"] = this.fi_us_id;
        data["fi_ro_role"] = this.fi_ro_role;
        return data;
    }

    clone(): UpdateFilesOfUserRolesInput {
        const json = this.toJSON();
        let result = new UpdateFilesOfUserRolesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateFilesOfUserRolesInput {
    fi_ro_id: number;
    fi_us_id: number;
    fi_ro_role: ResourceRoleStatus;
}

export class UpdateFilesOfUserWithRolesInput implements IUpdateFilesOfUserWithRolesInput {
    fi_ro_id!: number;
    fi_us_name!: string | undefined;
    fi_us_decs!: string | undefined;

    constructor(data?: IUpdateFilesOfUserWithRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fi_ro_id = _data["fi_ro_id"];
            this.fi_us_name = _data["fi_us_name"];
            this.fi_us_decs = _data["fi_us_decs"];
        }
    }

    static fromJS(data: any): UpdateFilesOfUserWithRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFilesOfUserWithRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fi_ro_id"] = this.fi_ro_id;
        data["fi_us_name"] = this.fi_us_name;
        data["fi_us_decs"] = this.fi_us_decs;
        return data;
    }

    clone(): UpdateFilesOfUserWithRolesInput {
        const json = this.toJSON();
        let result = new UpdateFilesOfUserWithRolesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateFilesOfUserWithRolesInput {
    fi_ro_id: number;
    fi_us_name: string | undefined;
    fi_us_decs: string | undefined;
}

export class UpdateFolderInput implements IUpdateFolderInput {
    fo_id!: number;
    fo_name!: string | undefined;
    fo_decs!: string | undefined;

    constructor(data?: IUpdateFolderInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_id = _data["fo_id"];
            this.fo_name = _data["fo_name"];
            this.fo_decs = _data["fo_decs"];
        }
    }

    static fromJS(data: any): UpdateFolderInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFolderInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_id"] = this.fo_id;
        data["fo_name"] = this.fo_name;
        data["fo_decs"] = this.fo_decs;
        return data;
    }

    clone(): UpdateFolderInput {
        const json = this.toJSON();
        let result = new UpdateFolderInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateFolderInput {
    fo_id: number;
    fo_name: string | undefined;
    fo_decs: string | undefined;
}

export class UpdateFolderRolesInput implements IUpdateFolderRolesInput {
    fo_ro_id!: number;
    fo_ro_role!: ResourceRoleStatus;

    constructor(data?: IUpdateFolderRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_ro_id = _data["fo_ro_id"];
            this.fo_ro_role = _data["fo_ro_role"];
        }
    }

    static fromJS(data: any): UpdateFolderRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFolderRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_ro_id"] = this.fo_ro_id;
        data["fo_ro_role"] = this.fo_ro_role;
        return data;
    }

    clone(): UpdateFolderRolesInput {
        const json = this.toJSON();
        let result = new UpdateFolderRolesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateFolderRolesInput {
    fo_ro_id: number;
    fo_ro_role: ResourceRoleStatus;
}

export class UpdateFolderWithRolesInput implements IUpdateFolderWithRolesInput {
    fo_ro_id!: number;
    fo_name!: string | undefined;
    fo_decs!: string | undefined;

    constructor(data?: IUpdateFolderWithRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fo_ro_id = _data["fo_ro_id"];
            this.fo_name = _data["fo_name"];
            this.fo_decs = _data["fo_decs"];
        }
    }

    static fromJS(data: any): UpdateFolderWithRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFolderWithRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fo_ro_id"] = this.fo_ro_id;
        data["fo_name"] = this.fo_name;
        data["fo_decs"] = this.fo_decs;
        return data;
    }

    clone(): UpdateFolderWithRolesInput {
        const json = this.toJSON();
        let result = new UpdateFolderWithRolesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateFolderWithRolesInput {
    fo_ro_id: number;
    fo_name: string | undefined;
    fo_decs: string | undefined;
}

export class UpdateLanguagesInput implements IUpdateLanguagesInput {
    la_id!: number;
    la_title!: string | undefined;
    la_flag!: string | undefined;
    la_enable!: boolean;

    constructor(data?: IUpdateLanguagesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.la_id = _data["la_id"];
            this.la_title = _data["la_title"];
            this.la_flag = _data["la_flag"];
            this.la_enable = _data["la_enable"];
        }
    }

    static fromJS(data: any): UpdateLanguagesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguagesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["la_id"] = this.la_id;
        data["la_title"] = this.la_title;
        data["la_flag"] = this.la_flag;
        data["la_enable"] = this.la_enable;
        return data;
    }

    clone(): UpdateLanguagesInput {
        const json = this.toJSON();
        let result = new UpdateLanguagesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateLanguagesInput {
    la_id: number;
    la_title: string | undefined;
    la_flag: string | undefined;
    la_enable: boolean;
}

export class UpdateMarc21Input implements IUpdateMarc21Input {
    mar_id!: number;
    mar_code!: string | undefined;
    mar_desc!: string | undefined;

    constructor(data?: IUpdateMarc21Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mar_id = _data["mar_id"];
            this.mar_code = _data["mar_code"];
            this.mar_desc = _data["mar_desc"];
        }
    }

    static fromJS(data: any): UpdateMarc21Input {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMarc21Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mar_id"] = this.mar_id;
        data["mar_code"] = this.mar_code;
        data["mar_desc"] = this.mar_desc;
        return data;
    }

    clone(): UpdateMarc21Input {
        const json = this.toJSON();
        let result = new UpdateMarc21Input();
        result.init(json);
        return result;
    }
}

export interface IUpdateMarc21Input {
    mar_id: number;
    mar_code: string | undefined;
    mar_desc: string | undefined;
}

export class UpdateMemberAvatarSesionInput implements IUpdateMemberAvatarSesionInput {
    me_id!: number;
    fi_id!: AttachmentItem;

    constructor(data?: IUpdateMemberAvatarSesionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateMemberAvatarSesionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberAvatarSesionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateMemberAvatarSesionInput {
        const json = this.toJSON();
        let result = new UpdateMemberAvatarSesionInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateMemberAvatarSesionInput {
    me_id: number;
    fi_id: AttachmentItem;
}

export class UpdateMemberInput implements IUpdateMemberInput {
    me_id!: number;
    me_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    me_is_active!: boolean;
    me_is_locked!: boolean;
    fi_id!: AttachmentItem;

    constructor(data?: IUpdateMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_name = _data["me_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.me_is_active = _data["me_is_active"];
            this.me_is_locked = _data["me_is_locked"];
            this.fi_id = _data["fi_id"] ? AttachmentItem.fromJS(_data["fi_id"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_name"] = this.me_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["me_is_active"] = this.me_is_active;
        data["me_is_locked"] = this.me_is_locked;
        data["fi_id"] = this.fi_id ? this.fi_id.toJSON() : <any>undefined;
        return data;
    }

    clone(): UpdateMemberInput {
        const json = this.toJSON();
        let result = new UpdateMemberInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateMemberInput {
    me_id: number;
    me_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    me_is_active: boolean;
    me_is_locked: boolean;
    fi_id: AttachmentItem;
}

export class UpdateMemberSesionInput implements IUpdateMemberSesionInput {
    me_id!: number;
    me_name!: string | undefined;
    me_identify!: string | undefined;
    me_birthday!: string | undefined;
    me_sex!: GENDER;
    me_address!: string | undefined;
    me_more_infor!: string | undefined;
    me_phone!: string | undefined;
    me_note!: string | undefined;
    me_pass!: string | undefined;
    me_is_active!: boolean;

    constructor(data?: IUpdateMemberSesionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.me_id = _data["me_id"];
            this.me_name = _data["me_name"];
            this.me_identify = _data["me_identify"];
            this.me_birthday = _data["me_birthday"];
            this.me_sex = _data["me_sex"];
            this.me_address = _data["me_address"];
            this.me_more_infor = _data["me_more_infor"];
            this.me_phone = _data["me_phone"];
            this.me_note = _data["me_note"];
            this.me_pass = _data["me_pass"];
            this.me_is_active = _data["me_is_active"];
        }
    }

    static fromJS(data: any): UpdateMemberSesionInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMemberSesionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["me_id"] = this.me_id;
        data["me_name"] = this.me_name;
        data["me_identify"] = this.me_identify;
        data["me_birthday"] = this.me_birthday;
        data["me_sex"] = this.me_sex;
        data["me_address"] = this.me_address;
        data["me_more_infor"] = this.me_more_infor;
        data["me_phone"] = this.me_phone;
        data["me_note"] = this.me_note;
        data["me_pass"] = this.me_pass;
        data["me_is_active"] = this.me_is_active;
        return data;
    }

    clone(): UpdateMemberSesionInput {
        const json = this.toJSON();
        let result = new UpdateMemberSesionInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateMemberSesionInput {
    me_id: number;
    me_name: string | undefined;
    me_identify: string | undefined;
    me_birthday: string | undefined;
    me_sex: GENDER;
    me_address: string | undefined;
    me_more_infor: string | undefined;
    me_phone: string | undefined;
    me_note: string | undefined;
    me_pass: string | undefined;
    me_is_active: boolean;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class UpdatePassword2Input implements IUpdatePassword2Input {
    id!: number;
    password!: string | undefined;

    constructor(data?: IUpdatePassword2Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UpdatePassword2Input {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePassword2Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["password"] = this.password;
        return data;
    }

    clone(): UpdatePassword2Input {
        const json = this.toJSON();
        let result = new UpdatePassword2Input();
        result.init(json);
        return result;
    }
}

export interface IUpdatePassword2Input {
    id: number;
    password: string | undefined;
}

export class UpdatePlanDetailInput implements IUpdatePlanDetailInput {
    pl_de_id!: number;
    pl_id!: number;
    do_id!: ItemDocument;
    pl_de_quantity!: number;
    pl_de_price!: number;
    pl_de_type!: PlanDetailType;
    pl_de_note!: string | undefined;
    pl_de_status_book!: PlanDetailStatusBook;

    constructor(data?: IUpdatePlanDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_de_id = _data["pl_de_id"];
            this.pl_id = _data["pl_id"];
            this.do_id = _data["do_id"] ? ItemDocument.fromJS(_data["do_id"]) : <any>undefined;
            this.pl_de_quantity = _data["pl_de_quantity"];
            this.pl_de_price = _data["pl_de_price"];
            this.pl_de_type = _data["pl_de_type"];
            this.pl_de_note = _data["pl_de_note"];
            this.pl_de_status_book = _data["pl_de_status_book"];
        }
    }

    static fromJS(data: any): UpdatePlanDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePlanDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_de_id"] = this.pl_de_id;
        data["pl_id"] = this.pl_id;
        data["do_id"] = this.do_id ? this.do_id.toJSON() : <any>undefined;
        data["pl_de_quantity"] = this.pl_de_quantity;
        data["pl_de_price"] = this.pl_de_price;
        data["pl_de_type"] = this.pl_de_type;
        data["pl_de_note"] = this.pl_de_note;
        data["pl_de_status_book"] = this.pl_de_status_book;
        return data;
    }

    clone(): UpdatePlanDetailInput {
        const json = this.toJSON();
        let result = new UpdatePlanDetailInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePlanDetailInput {
    pl_de_id: number;
    pl_id: number;
    do_id: ItemDocument;
    pl_de_quantity: number;
    pl_de_price: number;
    pl_de_type: PlanDetailType;
    pl_de_note: string | undefined;
    pl_de_status_book: PlanDetailStatusBook;
}

export class UpdatePlanInput implements IUpdatePlanInput {
    pl_id!: number;
    pl_title!: string | undefined;

    constructor(data?: IUpdatePlanInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pl_id = _data["pl_id"];
            this.pl_title = _data["pl_title"];
        }
    }

    static fromJS(data: any): UpdatePlanInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePlanInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pl_id"] = this.pl_id;
        data["pl_title"] = this.pl_title;
        return data;
    }

    clone(): UpdatePlanInput {
        const json = this.toJSON();
        let result = new UpdatePlanInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePlanInput {
    pl_id: number;
    pl_title: string | undefined;
}

export class UpdatePositionAuthorInput implements IUpdatePositionAuthorInput {
    au_id!: number;
    au_id2!: number;

    constructor(data?: IUpdatePositionAuthorInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.au_id = _data["au_id"];
            this.au_id2 = _data["au_id2"];
        }
    }

    static fromJS(data: any): UpdatePositionAuthorInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionAuthorInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["au_id"] = this.au_id;
        data["au_id2"] = this.au_id2;
        return data;
    }

    clone(): UpdatePositionAuthorInput {
        const json = this.toJSON();
        let result = new UpdatePositionAuthorInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionAuthorInput {
    au_id: number;
    au_id2: number;
}

export class UpdatePositionBillingInput implements IUpdatePositionBillingInput {
    bi_id!: number;
    bi_id2!: number;

    constructor(data?: IUpdatePositionBillingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_id = _data["bi_id"];
            this.bi_id2 = _data["bi_id2"];
        }
    }

    static fromJS(data: any): UpdatePositionBillingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionBillingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_id"] = this.bi_id;
        data["bi_id2"] = this.bi_id2;
        return data;
    }

    clone(): UpdatePositionBillingInput {
        const json = this.toJSON();
        let result = new UpdatePositionBillingInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionBillingInput {
    bi_id: number;
    bi_id2: number;
}

export class UpdatePositionBillingItemInput implements IUpdatePositionBillingItemInput {
    bi_it_id!: number;
    bi_it_id2!: number;

    constructor(data?: IUpdatePositionBillingItemInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bi_it_id = _data["bi_it_id"];
            this.bi_it_id2 = _data["bi_it_id2"];
        }
    }

    static fromJS(data: any): UpdatePositionBillingItemInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionBillingItemInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bi_it_id"] = this.bi_it_id;
        data["bi_it_id2"] = this.bi_it_id2;
        return data;
    }

    clone(): UpdatePositionBillingItemInput {
        const json = this.toJSON();
        let result = new UpdatePositionBillingItemInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionBillingItemInput {
    bi_it_id: number;
    bi_it_id2: number;
}

export class UpdatePositionCategoryInput implements IUpdatePositionCategoryInput {
    ca_id!: number;
    ca_id2!: number;

    constructor(data?: IUpdatePositionCategoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ca_id = _data["ca_id"];
            this.ca_id2 = _data["ca_id2"];
        }
    }

    static fromJS(data: any): UpdatePositionCategoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionCategoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ca_id"] = this.ca_id;
        data["ca_id2"] = this.ca_id2;
        return data;
    }

    clone(): UpdatePositionCategoryInput {
        const json = this.toJSON();
        let result = new UpdatePositionCategoryInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionCategoryInput {
    ca_id: number;
    ca_id2: number;
}

export class UpdatePositionFieldInput implements IUpdatePositionFieldInput {
    fieldIDChangedList!: number[];

    constructor(data?: IUpdatePositionFieldInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.fieldIDChangedList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["fieldIDChangedList"])) {
                this.fieldIDChangedList = [] as any;
                for (let item of _data["fieldIDChangedList"])
                    this.fieldIDChangedList!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdatePositionFieldInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionFieldInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.fieldIDChangedList)) {
            data["fieldIDChangedList"] = [];
            for (let item of this.fieldIDChangedList)
                data["fieldIDChangedList"].push(item);
        }
        return data;
    }

    clone(): UpdatePositionFieldInput {
        const json = this.toJSON();
        let result = new UpdatePositionFieldInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionFieldInput {
    fieldIDChangedList: number[];
}

export class UpdatePositionMarc21Input implements IUpdatePositionMarc21Input {
    mar_id!: number;
    mar_id2!: number;

    constructor(data?: IUpdatePositionMarc21Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mar_id = _data["mar_id"];
            this.mar_id2 = _data["mar_id2"];
        }
    }

    static fromJS(data: any): UpdatePositionMarc21Input {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionMarc21Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mar_id"] = this.mar_id;
        data["mar_id2"] = this.mar_id2;
        return data;
    }

    clone(): UpdatePositionMarc21Input {
        const json = this.toJSON();
        let result = new UpdatePositionMarc21Input();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionMarc21Input {
    mar_id: number;
    mar_id2: number;
}

export class UpdatePositionReponsitoryInput implements IUpdatePositionReponsitoryInput {
    re_id!: number;
    re_id2!: number;

    constructor(data?: IUpdatePositionReponsitoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.re_id2 = _data["re_id2"];
        }
    }

    static fromJS(data: any): UpdatePositionReponsitoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePositionReponsitoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["re_id2"] = this.re_id2;
        return data;
    }

    clone(): UpdatePositionReponsitoryInput {
        const json = this.toJSON();
        let result = new UpdatePositionReponsitoryInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePositionReponsitoryInput {
    re_id: number;
    re_id2: number;
}

export class UpdatePublishRegisterInput implements IUpdatePublishRegisterInput {
    pu_re_id!: number;
    pu_re_name!: string | undefined;
    ca_id!: number;
    pu_re_receive_type!: TypePublishRegister;
    me_id!: number;
    pu_re_note!: string | undefined;
    us_id_change_status!: number;
    pu_re_status!: StatusPublishRegister;

    constructor(data?: IUpdatePublishRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_re_id = _data["pu_re_id"];
            this.pu_re_name = _data["pu_re_name"];
            this.ca_id = _data["ca_id"];
            this.pu_re_receive_type = _data["pu_re_receive_type"];
            this.me_id = _data["me_id"];
            this.pu_re_note = _data["pu_re_note"];
            this.us_id_change_status = _data["us_id_change_status"];
            this.pu_re_status = _data["pu_re_status"];
        }
    }

    static fromJS(data: any): UpdatePublishRegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePublishRegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_re_id"] = this.pu_re_id;
        data["pu_re_name"] = this.pu_re_name;
        data["ca_id"] = this.ca_id;
        data["pu_re_receive_type"] = this.pu_re_receive_type;
        data["me_id"] = this.me_id;
        data["pu_re_note"] = this.pu_re_note;
        data["us_id_change_status"] = this.us_id_change_status;
        data["pu_re_status"] = this.pu_re_status;
        return data;
    }

    clone(): UpdatePublishRegisterInput {
        const json = this.toJSON();
        let result = new UpdatePublishRegisterInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePublishRegisterInput {
    pu_re_id: number;
    pu_re_name: string | undefined;
    ca_id: number;
    pu_re_receive_type: TypePublishRegister;
    me_id: number;
    pu_re_note: string | undefined;
    us_id_change_status: number;
    pu_re_status: StatusPublishRegister;
}

export class UpdatePublishSettingInput implements IUpdatePublishSettingInput {
    pu_se_Id!: number;
    ca_id!: number;
    pu_se_note!: string | undefined;
    pu_se_day!: number;
    pu_se_month!: number;
    pu_se_year!: number;
    pu_se_type!: PublishSettingType;
    pu_se_active!: boolean;
    pu_se_condition!: string | undefined;

    constructor(data?: IUpdatePublishSettingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_se_Id = _data["pu_se_Id"];
            this.ca_id = _data["ca_id"];
            this.pu_se_note = _data["pu_se_note"];
            this.pu_se_day = _data["pu_se_day"];
            this.pu_se_month = _data["pu_se_month"];
            this.pu_se_year = _data["pu_se_year"];
            this.pu_se_type = _data["pu_se_type"];
            this.pu_se_active = _data["pu_se_active"];
            this.pu_se_condition = _data["pu_se_condition"];
        }
    }

    static fromJS(data: any): UpdatePublishSettingInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePublishSettingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_se_Id"] = this.pu_se_Id;
        data["ca_id"] = this.ca_id;
        data["pu_se_note"] = this.pu_se_note;
        data["pu_se_day"] = this.pu_se_day;
        data["pu_se_month"] = this.pu_se_month;
        data["pu_se_year"] = this.pu_se_year;
        data["pu_se_type"] = this.pu_se_type;
        data["pu_se_active"] = this.pu_se_active;
        data["pu_se_condition"] = this.pu_se_condition;
        return data;
    }

    clone(): UpdatePublishSettingInput {
        const json = this.toJSON();
        let result = new UpdatePublishSettingInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePublishSettingInput {
    pu_se_Id: number;
    ca_id: number;
    pu_se_note: string | undefined;
    pu_se_day: number;
    pu_se_month: number;
    pu_se_year: number;
    pu_se_type: PublishSettingType;
    pu_se_active: boolean;
    pu_se_condition: string | undefined;
}

export class UpdatePublisherInput implements IUpdatePublisherInput {
    pu_id!: number;
    pu_short_name!: string | undefined;
    pu_name!: string | undefined;
    pu_address!: string | undefined;
    pu_license!: string | undefined;
    pu_email!: string | undefined;
    pu_phone!: string | undefined;
    pu_website!: string | undefined;
    pu_infor!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: IUpdatePublisherInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pu_id = _data["pu_id"];
            this.pu_short_name = _data["pu_short_name"];
            this.pu_name = _data["pu_name"];
            this.pu_address = _data["pu_address"];
            this.pu_license = _data["pu_license"];
            this.pu_email = _data["pu_email"];
            this.pu_phone = _data["pu_phone"];
            this.pu_website = _data["pu_website"];
            this.pu_infor = _data["pu_infor"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePublisherInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePublisherInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pu_id"] = this.pu_id;
        data["pu_short_name"] = this.pu_short_name;
        data["pu_name"] = this.pu_name;
        data["pu_address"] = this.pu_address;
        data["pu_license"] = this.pu_license;
        data["pu_email"] = this.pu_email;
        data["pu_phone"] = this.pu_phone;
        data["pu_website"] = this.pu_website;
        data["pu_infor"] = this.pu_infor;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdatePublisherInput {
        const json = this.toJSON();
        let result = new UpdatePublisherInput();
        result.init(json);
        return result;
    }
}

export interface IUpdatePublisherInput {
    pu_id: number;
    pu_short_name: string | undefined;
    pu_name: string | undefined;
    pu_address: string | undefined;
    pu_license: string | undefined;
    pu_email: string | undefined;
    pu_phone: string | undefined;
    pu_website: string | undefined;
    pu_infor: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class UpdateReceiptInput implements IUpdateReceiptInput {
    rec_id!: number;
    rec_reason!: string | undefined;
    rec_import_date!: string | undefined;
    bi_it_id_arr!: number[] | undefined;
    co_id!: number;
    us_id_browser!: number;

    constructor(data?: IUpdateReceiptInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rec_id = _data["rec_id"];
            this.rec_reason = _data["rec_reason"];
            this.rec_import_date = _data["rec_import_date"];
            if (Array.isArray(_data["bi_it_id_arr"])) {
                this.bi_it_id_arr = [] as any;
                for (let item of _data["bi_it_id_arr"])
                    this.bi_it_id_arr!.push(item);
            }
            this.co_id = _data["co_id"];
            this.us_id_browser = _data["us_id_browser"];
        }
    }

    static fromJS(data: any): UpdateReceiptInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReceiptInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rec_id"] = this.rec_id;
        data["rec_reason"] = this.rec_reason;
        data["rec_import_date"] = this.rec_import_date;
        if (Array.isArray(this.bi_it_id_arr)) {
            data["bi_it_id_arr"] = [];
            for (let item of this.bi_it_id_arr)
                data["bi_it_id_arr"].push(item);
        }
        data["co_id"] = this.co_id;
        data["us_id_browser"] = this.us_id_browser;
        return data;
    }

    clone(): UpdateReceiptInput {
        const json = this.toJSON();
        let result = new UpdateReceiptInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateReceiptInput {
    rec_id: number;
    rec_reason: string | undefined;
    rec_import_date: string | undefined;
    bi_it_id_arr: number[] | undefined;
    co_id: number;
    us_id_browser: number;
}

export class UpdateReponsitoryInput implements IUpdateReponsitoryInput {
    re_id!: number;
    re_code!: string | undefined;
    re_name!: string | undefined;
    re_desc!: string | undefined;
    re_id_parent!: number;
    re_type!: ReponsitoryType;

    constructor(data?: IUpdateReponsitoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.re_id = _data["re_id"];
            this.re_code = _data["re_code"];
            this.re_name = _data["re_name"];
            this.re_desc = _data["re_desc"];
            this.re_id_parent = _data["re_id_parent"];
            this.re_type = _data["re_type"];
        }
    }

    static fromJS(data: any): UpdateReponsitoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateReponsitoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["re_id"] = this.re_id;
        data["re_code"] = this.re_code;
        data["re_name"] = this.re_name;
        data["re_desc"] = this.re_desc;
        data["re_id_parent"] = this.re_id_parent;
        data["re_type"] = this.re_type;
        return data;
    }

    clone(): UpdateReponsitoryInput {
        const json = this.toJSON();
        let result = new UpdateReponsitoryInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateReponsitoryInput {
    re_id: number;
    re_code: string | undefined;
    re_name: string | undefined;
    re_desc: string | undefined;
    re_id_parent: number;
    re_type: ReponsitoryType;
}

export class UpdateStatisticStorageInput implements IUpdateStatisticStorageInput {
    sta_id!: number;
    sta_name!: string | undefined;
    sta_code!: string | undefined;
    sta_content!: string | undefined;
    sta_status!: StatisticStorageStatus;
    pr_id!: number;

    constructor(data?: IUpdateStatisticStorageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sta_id = _data["sta_id"];
            this.sta_name = _data["sta_name"];
            this.sta_code = _data["sta_code"];
            this.sta_content = _data["sta_content"];
            this.sta_status = _data["sta_status"];
            this.pr_id = _data["pr_id"];
        }
    }

    static fromJS(data: any): UpdateStatisticStorageInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStatisticStorageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sta_id"] = this.sta_id;
        data["sta_name"] = this.sta_name;
        data["sta_code"] = this.sta_code;
        data["sta_content"] = this.sta_content;
        data["sta_status"] = this.sta_status;
        data["pr_id"] = this.pr_id;
        return data;
    }

    clone(): UpdateStatisticStorageInput {
        const json = this.toJSON();
        let result = new UpdateStatisticStorageInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateStatisticStorageInput {
    sta_id: number;
    sta_name: string | undefined;
    sta_code: string | undefined;
    sta_content: string | undefined;
    sta_status: StatisticStorageStatus;
    pr_id: number;
}

export class UpdateSubFieldMarc21Input implements IUpdateSubFieldMarc21Input {
    sub_id!: number;
    mar_id!: number;
    sub_code!: string | undefined;
    sub_desc!: string | undefined;

    constructor(data?: IUpdateSubFieldMarc21Input) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sub_id = _data["sub_id"];
            this.mar_id = _data["mar_id"];
            this.sub_code = _data["sub_code"];
            this.sub_desc = _data["sub_desc"];
        }
    }

    static fromJS(data: any): UpdateSubFieldMarc21Input {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSubFieldMarc21Input();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sub_id"] = this.sub_id;
        data["mar_id"] = this.mar_id;
        data["sub_code"] = this.sub_code;
        data["sub_desc"] = this.sub_desc;
        return data;
    }

    clone(): UpdateSubFieldMarc21Input {
        const json = this.toJSON();
        let result = new UpdateSubFieldMarc21Input();
        result.init(json);
        return result;
    }
}

export interface IUpdateSubFieldMarc21Input {
    sub_id: number;
    mar_id: number;
    sub_code: string | undefined;
    sub_desc: string | undefined;
}

export class UpdateSupplierInput implements IUpdateSupplierInput {
    su_id!: number;
    su_short_name!: string | undefined;
    su_name!: string | undefined;
    su_contact_name!: string | undefined;
    su_contact_possition!: string | undefined;
    su_contact_address!: string | undefined;
    su_contact_phone!: string | undefined;
    su_contact_fax!: string | undefined;
    su_contact_email!: string | undefined;
    su_contact_note!: string | undefined;
    su_tax_code!: string | undefined;
    fi_id_arr!: AttachmentItem[] | undefined;

    constructor(data?: IUpdateSupplierInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.su_id = _data["su_id"];
            this.su_short_name = _data["su_short_name"];
            this.su_name = _data["su_name"];
            this.su_contact_name = _data["su_contact_name"];
            this.su_contact_possition = _data["su_contact_possition"];
            this.su_contact_address = _data["su_contact_address"];
            this.su_contact_phone = _data["su_contact_phone"];
            this.su_contact_fax = _data["su_contact_fax"];
            this.su_contact_email = _data["su_contact_email"];
            this.su_contact_note = _data["su_contact_note"];
            this.su_tax_code = _data["su_tax_code"];
            if (Array.isArray(_data["fi_id_arr"])) {
                this.fi_id_arr = [] as any;
                for (let item of _data["fi_id_arr"])
                    this.fi_id_arr!.push(AttachmentItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSupplierInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSupplierInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["su_id"] = this.su_id;
        data["su_short_name"] = this.su_short_name;
        data["su_name"] = this.su_name;
        data["su_contact_name"] = this.su_contact_name;
        data["su_contact_possition"] = this.su_contact_possition;
        data["su_contact_address"] = this.su_contact_address;
        data["su_contact_phone"] = this.su_contact_phone;
        data["su_contact_fax"] = this.su_contact_fax;
        data["su_contact_email"] = this.su_contact_email;
        data["su_contact_note"] = this.su_contact_note;
        data["su_tax_code"] = this.su_tax_code;
        if (Array.isArray(this.fi_id_arr)) {
            data["fi_id_arr"] = [];
            for (let item of this.fi_id_arr)
                data["fi_id_arr"].push(item.toJSON());
        }
        return data;
    }

    clone(): UpdateSupplierInput {
        const json = this.toJSON();
        let result = new UpdateSupplierInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateSupplierInput {
    su_id: number;
    su_short_name: string | undefined;
    su_name: string | undefined;
    su_contact_name: string | undefined;
    su_contact_possition: string | undefined;
    su_contact_address: string | undefined;
    su_contact_phone: string | undefined;
    su_contact_fax: string | undefined;
    su_contact_email: string | undefined;
    su_contact_note: string | undefined;
    su_tax_code: string | undefined;
    fi_id_arr: AttachmentItem[] | undefined;
}

export class UpdateTopicInput implements IUpdateTopicInput {
    to_id!: number;
    to_name!: string | undefined;
    to_code!: string | undefined;
    to_desc!: string | undefined;
    to_is_active!: boolean;

    constructor(data?: IUpdateTopicInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.to_id = _data["to_id"];
            this.to_name = _data["to_name"];
            this.to_code = _data["to_code"];
            this.to_desc = _data["to_desc"];
            this.to_is_active = _data["to_is_active"];
        }
    }

    static fromJS(data: any): UpdateTopicInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTopicInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["to_id"] = this.to_id;
        data["to_name"] = this.to_name;
        data["to_code"] = this.to_code;
        data["to_desc"] = this.to_desc;
        data["to_is_active"] = this.to_is_active;
        return data;
    }

    clone(): UpdateTopicInput {
        const json = this.toJSON();
        let result = new UpdateTopicInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTopicInput {
    to_id: number;
    to_name: string | undefined;
    to_code: string | undefined;
    to_desc: string | undefined;
    to_is_active: boolean;
}

export class UpdateUserInput implements IUpdateUserInput {
    id!: number;
    userName!: string;
    name!: string;
    surname!: string;
    emailAddress!: string;
    isActive!: boolean;
    roleNames!: string[] | undefined;
    us_address!: string | undefined;
    us_dob!: Date | undefined;
    us_gender!: GENDER;
    us_po_id!: number;
    dep_id!: number;
    pr_id!: number;
    us_cmt_locked_default!: boolean;

    constructor(data?: IUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.us_address = _data["us_address"];
            this.us_dob = _data["us_dob"] ? new Date(_data["us_dob"].toString()) : <any>undefined;
            this.us_gender = _data["us_gender"];
            this.us_po_id = _data["us_po_id"];
            this.dep_id = _data["dep_id"];
            this.pr_id = _data["pr_id"];
            this.us_cmt_locked_default = _data["us_cmt_locked_default"];
        }
    }

    static fromJS(data: any): UpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["us_address"] = this.us_address;
        data["us_dob"] = this.us_dob ? this.us_dob.toISOString() : <any>undefined;
        data["us_gender"] = this.us_gender;
        data["us_po_id"] = this.us_po_id;
        data["dep_id"] = this.dep_id;
        data["pr_id"] = this.pr_id;
        data["us_cmt_locked_default"] = this.us_cmt_locked_default;
        return data;
    }

    clone(): UpdateUserInput {
        const json = this.toJSON();
        let result = new UpdateUserInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserInput {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    roleNames: string[] | undefined;
    us_address: string | undefined;
    us_dob: Date | undefined;
    us_gender: GENDER;
    us_po_id: number;
    dep_id: number;
    pr_id: number;
    us_cmt_locked_default: boolean;
}

export class User implements IUser {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    lastModificationTime!: Date | undefined;
    lastModifierUserId!: number | undefined;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: Date | undefined;
    authenticationSource!: string | undefined;
    userName!: string;
    tenantId!: number | undefined;
    emailAddress!: string;
    name!: string;
    surname!: string;
    readonly fullName!: string | undefined;
    password!: string;
    emailConfirmationCode!: string | undefined;
    passwordResetCode!: string | undefined;
    lockoutEndDateUtc!: Date | undefined;
    accessFailedCount!: number;
    isLockoutEnabled!: boolean;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    securityStamp!: string | undefined;
    isTwoFactorEnabled!: boolean;
    logins!: UserLogin[] | undefined;
    roles!: UserRole[] | undefined;
    claims!: UserClaim[] | undefined;
    permissions!: UserPermissionSetting[] | undefined;
    settings!: Setting[] | undefined;
    isEmailConfirmed!: boolean;
    isActive!: boolean;
    normalizedUserName!: string;
    normalizedEmailAddress!: string;
    concurrencyStamp!: string | undefined;
    tokens!: UserToken[] | undefined;
    deleterUser!: User;
    creatorUser!: User;
    lastModifierUser!: User;
    us_avatar!: number;
    us_address!: string | undefined;
    us_dob!: Date | undefined;
    us_gender!: GENDER;
    us_po_id!: number;
    dep_id!: number;
    pr_id!: number;
    us_type!: UserType;
    me_id!: number;
    password2!: string | undefined;
    us_cmt_locked_default!: boolean;
    us_updated_at!: Date;
    us_created_at!: Date;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.lastModificationTime = _data["lastModificationTime"] ? new Date(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
            this.authenticationSource = _data["authenticationSource"];
            this.userName = _data["userName"];
            this.tenantId = _data["tenantId"];
            this.emailAddress = _data["emailAddress"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            (<any>this).fullName = _data["fullName"];
            this.password = _data["password"];
            this.emailConfirmationCode = _data["emailConfirmationCode"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? new Date(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = _data["accessFailedCount"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.securityStamp = _data["securityStamp"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            if (Array.isArray(_data["logins"])) {
                this.logins = [] as any;
                for (let item of _data["logins"])
                    this.logins!.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRole.fromJS(item));
            }
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(_data["settings"])) {
                this.settings = [] as any;
                for (let item of _data["settings"])
                    this.settings!.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            this.isActive = _data["isActive"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.normalizedEmailAddress = _data["normalizedEmailAddress"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            if (Array.isArray(_data["tokens"])) {
                this.tokens = [] as any;
                for (let item of _data["tokens"])
                    this.tokens!.push(UserToken.fromJS(item));
            }
            this.deleterUser = _data["deleterUser"] ? User.fromJS(_data["deleterUser"]) : <any>undefined;
            this.creatorUser = _data["creatorUser"] ? User.fromJS(_data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = _data["lastModifierUser"] ? User.fromJS(_data["lastModifierUser"]) : <any>undefined;
            this.us_avatar = _data["us_avatar"];
            this.us_address = _data["us_address"];
            this.us_dob = _data["us_dob"] ? new Date(_data["us_dob"].toString()) : <any>undefined;
            this.us_gender = _data["us_gender"];
            this.us_po_id = _data["us_po_id"];
            this.dep_id = _data["dep_id"];
            this.pr_id = _data["pr_id"];
            this.us_type = _data["us_type"];
            this.me_id = _data["me_id"];
            this.password2 = _data["password2"];
            this.us_cmt_locked_default = _data["us_cmt_locked_default"];
            this.us_updated_at = _data["us_updated_at"] ? new Date(_data["us_updated_at"].toString()) : <any>undefined;
            this.us_created_at = _data["us_created_at"] ? new Date(_data["us_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["us_avatar"] = this.us_avatar;
        data["us_address"] = this.us_address;
        data["us_dob"] = this.us_dob ? this.us_dob.toISOString() : <any>undefined;
        data["us_gender"] = this.us_gender;
        data["us_po_id"] = this.us_po_id;
        data["dep_id"] = this.dep_id;
        data["pr_id"] = this.pr_id;
        data["us_type"] = this.us_type;
        data["me_id"] = this.me_id;
        data["password2"] = this.password2;
        data["us_cmt_locked_default"] = this.us_cmt_locked_default;
        data["us_updated_at"] = this.us_updated_at ? this.us_updated_at.toISOString() : <any>undefined;
        data["us_created_at"] = this.us_created_at ? this.us_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    lastModificationTime: Date | undefined;
    lastModifierUserId: number | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: Date | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: Date | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    us_avatar: number;
    us_address: string | undefined;
    us_dob: Date | undefined;
    us_gender: GENDER;
    us_po_id: number;
    dep_id: number;
    pr_id: number;
    us_type: UserType;
    me_id: number;
    password2: string | undefined;
    us_cmt_locked_default: boolean;
    us_updated_at: Date;
    us_created_at: Date;
}

export class UserClaim implements IUserClaim {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    tenantId!: number | undefined;
    userId!: number;
    claimType!: string | undefined;
    claimValue!: string | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.claimType = _data["claimType"];
            this.claimValue = _data["claimValue"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        return data;
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
}

export class UserDto implements IUserDto {
    id!: number;
    userName!: string;
    name!: string;
    surname!: string;
    emailAddress!: string;
    isActive!: boolean;
    fullName!: string | undefined;
    lastLoginTime!: Date | undefined;
    creationTime!: Date;
    roleNames!: string[] | undefined;
    us_address!: string | undefined;
    us_dob!: Date | undefined;
    us_gender!: GENDER;
    us_type!: UserType;
    me_id!: number;
    us_po_id!: number;
    dep_id!: number;
    pr_id!: number;
    isDeleted!: boolean;
    us_avatar!: number;
    us_cmt_locked_default!: boolean;
    us_updated_at!: Date;
    us_created_at!: Date;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.emailAddress = _data["emailAddress"];
            this.isActive = _data["isActive"];
            this.fullName = _data["fullName"];
            this.lastLoginTime = _data["lastLoginTime"] ? new Date(_data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["roleNames"])) {
                this.roleNames = [] as any;
                for (let item of _data["roleNames"])
                    this.roleNames!.push(item);
            }
            this.us_address = _data["us_address"];
            this.us_dob = _data["us_dob"] ? new Date(_data["us_dob"].toString()) : <any>undefined;
            this.us_gender = _data["us_gender"];
            this.us_type = _data["us_type"];
            this.me_id = _data["me_id"];
            this.us_po_id = _data["us_po_id"];
            this.dep_id = _data["dep_id"];
            this.pr_id = _data["pr_id"];
            this.isDeleted = _data["isDeleted"];
            this.us_avatar = _data["us_avatar"];
            this.us_cmt_locked_default = _data["us_cmt_locked_default"];
            this.us_updated_at = _data["us_updated_at"] ? new Date(_data["us_updated_at"].toString()) : <any>undefined;
            this.us_created_at = _data["us_created_at"] ? new Date(_data["us_created_at"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (Array.isArray(this.roleNames)) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["us_address"] = this.us_address;
        data["us_dob"] = this.us_dob ? this.us_dob.toISOString() : <any>undefined;
        data["us_gender"] = this.us_gender;
        data["us_type"] = this.us_type;
        data["me_id"] = this.me_id;
        data["us_po_id"] = this.us_po_id;
        data["dep_id"] = this.dep_id;
        data["pr_id"] = this.pr_id;
        data["isDeleted"] = this.isDeleted;
        data["us_avatar"] = this.us_avatar;
        data["us_cmt_locked_default"] = this.us_cmt_locked_default;
        data["us_updated_at"] = this.us_updated_at ? this.us_updated_at.toISOString() : <any>undefined;
        data["us_created_at"] = this.us_created_at ? this.us_created_at.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    id: number;
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean;
    fullName: string | undefined;
    lastLoginTime: Date | undefined;
    creationTime: Date;
    roleNames: string[] | undefined;
    us_address: string | undefined;
    us_dob: Date | undefined;
    us_gender: GENDER;
    us_type: UserType;
    me_id: number;
    us_po_id: number;
    dep_id: number;
    pr_id: number;
    isDeleted: boolean;
    us_avatar: number;
    us_cmt_locked_default: boolean;
    us_updated_at: Date;
    us_created_at: Date;
}

export class UserDtoPagedResultDto implements IUserDtoPagedResultDto {
    items!: UserDto[] | undefined;
    totalCount!: number;

    constructor(data?: IUserDtoPagedResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDto.fromJS(item));
            }
            this.totalCount = _data["totalCount"];
        }
    }

    static fromJS(data: any): UserDtoPagedResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoPagedResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["totalCount"] = this.totalCount;
        return data;
    }

    clone(): UserDtoPagedResultDto {
        const json = this.toJSON();
        let result = new UserDtoPagedResultDto();
        result.init(json);
        return result;
    }
}

export interface IUserDtoPagedResultDto {
    items: UserDto[] | undefined;
    totalCount: number;
}

export class UserLogin implements IUserLogin {
    id!: number;
    tenantId!: number | undefined;
    userId!: number;
    loginProvider!: string;
    providerKey!: string;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.providerKey = _data["providerKey"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        return data;
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string;
    providerKey: string;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    id!: number;
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    us_avatar!: number;
    us_address!: string | undefined;
    hasPassword2!: boolean;
    isActive!: boolean;
    us_dob!: Date | undefined;
    us_gender!: GENDER;
    us_type!: UserType;
    me_id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.us_avatar = _data["us_avatar"];
            this.us_address = _data["us_address"];
            this.hasPassword2 = _data["hasPassword2"];
            this.isActive = _data["isActive"];
            this.us_dob = _data["us_dob"] ? new Date(_data["us_dob"].toString()) : <any>undefined;
            this.us_gender = _data["us_gender"];
            this.us_type = _data["us_type"];
            this.me_id = _data["me_id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["us_avatar"] = this.us_avatar;
        data["us_address"] = this.us_address;
        data["hasPassword2"] = this.hasPassword2;
        data["isActive"] = this.isActive;
        data["us_dob"] = this.us_dob ? this.us_dob.toISOString() : <any>undefined;
        data["us_gender"] = this.us_gender;
        data["us_type"] = this.us_type;
        data["me_id"] = this.me_id;
        return data;
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    id: number;
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    us_avatar: number;
    us_address: string | undefined;
    hasPassword2: boolean;
    isActive: boolean;
    us_dob: Date | undefined;
    us_gender: GENDER;
    us_type: UserType;
    me_id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    tenantId!: number | undefined;
    name!: string;
    isGranted!: boolean;
    userId!: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.isGranted = _data["isGranted"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["userId"] = this.userId;
        return data;
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean;
    userId: number;
}

export class UserRole implements IUserRole {
    id!: number;
    creationTime!: Date;
    creatorUserId!: number | undefined;
    tenantId!: number | undefined;
    userId!: number;
    roleId!: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    id: number;
    creationTime: Date;
    creatorUserId: number | undefined;
    tenantId: number | undefined;
    userId: number;
    roleId: number;
}

export class UserToken implements IUserToken {
    id!: number;
    tenantId!: number | undefined;
    userId!: number;
    loginProvider!: string | undefined;
    name!: string | undefined;
    value!: string | undefined;
    expireDate!: Date | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.loginProvider = _data["loginProvider"];
            this.name = _data["name"];
            this.value = _data["value"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        return data;
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    id: number;
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: Date | undefined;
}

export enum UserType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class WebhookEvent implements IWebhookEvent {
    id!: string;
    webhookName!: string;
    data!: string | undefined;
    creationTime!: Date;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deletionTime!: Date | undefined;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? new Date(_data["creationTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? new Date(_data["deletionTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        return data;
    }

    clone(): WebhookEvent {
        const json = this.toJSON();
        let result = new WebhookEvent();
        result.init(json);
        return result;
    }
}

export interface IWebhookEvent {
    id: string;
    webhookName: string;
    data: string | undefined;
    creationTime: Date;
    tenantId: number | undefined;
    isDeleted: boolean;
    deletionTime: Date | undefined;
}

export class WebhookSubscription implements IWebhookSubscription {
    id!: string;
    tenantId!: number | undefined;
    webhookUri!: string | undefined;
    secret!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    headers!: { [key: string]: string; } | undefined;

    constructor(data?: IWebhookSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tenantId = _data["tenantId"];
            this.webhookUri = _data["webhookUri"];
            this.secret = _data["secret"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
        }
    }

    static fromJS(data: any): WebhookSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tenantId"] = this.tenantId;
        data["webhookUri"] = this.webhookUri;
        data["secret"] = this.secret;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        return data;
    }

    clone(): WebhookSubscription {
        const json = this.toJSON();
        let result = new WebhookSubscription();
        result.init(json);
        return result;
    }
}

export interface IWebhookSubscription {
    id: string;
    tenantId: number | undefined;
    webhookUri: string | undefined;
    secret: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    headers: { [key: string]: string; } | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}